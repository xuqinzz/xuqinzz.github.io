<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="c5yB2B-3tswoQK7D0ZfZDqbSGvVzLxh-kwnbxyeTdaU" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="格物致知">
<meta property="og:type" content="website">
<meta property="og:title" content="跬步">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="跬步">
<meta property="og:description" content="格物致知">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="跬步">
<meta name="twitter:description" content="格物致知">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>




<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #ffffff; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #ffffff, 0 0 5px #ffffff; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #ffffff;    /*上边框颜色*/
        border-left-color: #ffffff;    /*左边框颜色*/
    }
</style>
  <title>跬步</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-113549877-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">跬步</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程表
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/07/自定View之绘制顺序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="作茧自缚">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/07/自定View之绘制顺序/" itemprop="url">自定View之绘制顺序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-07T21:53:49+08:00">
                2018-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/自定义View/" itemprop="url" rel="index">
                    <span itemprop="name">自定义View</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/07/自定View之绘制顺序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/02/07/自定View之绘制顺序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="super-onDraw-前-or-后？"><a href="#super-onDraw-前-or-后？" class="headerlink" title="super.onDraw() 前 or 后？"></a>super.onDraw() 前 or 后？</h2><blockquote>
<p><code>View</code> 这个类中，<code>onDraw()</code> 是空实现，但是基于已有控件的自定义绘制，就不能不考虑 <code>super.onDraw()</code> 了：你需要根据自己的需求，判断出你绘制的内容需要盖住控件原有的内容还是需要被控件原有的内容盖住，从而确定你的绘制代码是应该写在 <code>super.onDraw()</code> 的上面还是下面。</p>
</blockquote>
<h3 id="写在-super-onDraw-的下面"><a href="#写在-super-onDraw-的下面" class="headerlink" title="写在 super.onDraw() 的下面"></a>写在 super.onDraw() 的下面</h3><blockquote>
<p>把绘制代码写在 <code>super.onDraw()</code> 的下面，由于绘制代码会在原有内容绘制结束之后才执行，所以绘制内容就会盖住控件原来的内容。</p>
</blockquote>
<h3 id="写在-super-onDraw-的上面"><a href="#写在-super-onDraw-的上面" class="headerlink" title="写在 super.onDraw() 的上面"></a>写在 super.onDraw() 的上面</h3><blockquote>
<p>如果把绘制代码写在 <code>super.onDraw()</code> 的上面，由于绘制代码会执行在原有内容的绘制之前，所以绘制的内容会被控件的原内容盖住。</p>
</blockquote>
<h2 id="dispatchDraw-：绘制子-View-的方法"><a href="#dispatchDraw-：绘制子-View-的方法" class="headerlink" title="dispatchDraw()：绘制子 View 的方法"></a>dispatchDraw()：绘制子 View 的方法</h2><blockquote>
<p>Android 的绘制顺序：在绘制过程中，每一个 ViewGroup 会先调用自己的 <code>onDraw()</code>来绘制完自己的主体之后再去绘制它的子 View。对于上面这个例子来说，就是你的 <code>LinearLayout</code> 会在绘制完斑点后再去绘制它的子 View。那么在子 View 绘制完成之后，先前绘制的斑点就被子 View 盖住了。</p>
<p>「绘制子 View」是通过另一个绘制方法的调用来发生的，这个绘制方法叫做：<code>dispatchDraw()</code>。也就是说，在绘制过程中，每个 View 和 ViewGroup 都会先调用 <code>onDraw()</code> 方法来绘制主体，再调用 <code>dispatchDraw()</code> 方法来绘制子 View。注：虽然 <code>View</code> 和 <code>ViewGroup</code> 都有 <code>dispatchDraw()</code> 方法，不过由于 View 是没有子 View 的，所以一般来说 <code>dispatchDraw()</code> 这个方法只对 <code>ViewGroup</code>（以及它的子类）有意义。</p>
</blockquote>
<h3 id="写在-super-dispatchDraw-的下面"><a href="#写在-super-dispatchDraw-的下面" class="headerlink" title="写在 super.dispatchDraw() 的下面"></a>写在 super.dispatchDraw() 的下面</h3><blockquote>
<p>只要重写 <code>dispatchDraw()</code>，并在 <code>super.dispatchDraw()</code> 的下面写上你的绘制代码，这段绘制代码就会发生在子 View 的绘制之后，从而让绘制内容盖住子 View 了。</p>
</blockquote>
<h2 id="写在-super-dispatchDraw-的上面"><a href="#写在-super-dispatchDraw-的上面" class="headerlink" title="写在 super.dispatchDraw() 的上面"></a>写在 super.dispatchDraw() 的上面</h2><blockquote>
<p>把绘制代码写在 <code>super.dispatchDraw()</code> 的上面，这段绘制就会在 <code>onDraw()</code> 之后、 <code>super.dispatchDraw()</code> 之前发生，也就是绘制内容会出现在主体内容和子 View 之间</p>
</blockquote>
<h2 id="绘制过程简述"><a href="#绘制过程简述" class="headerlink" title="绘制过程简述"></a>绘制过程简述</h2><ul>
<li>个完整的绘制过程会依次绘制以下几个内容：<ol>
<li>背景（drawBackground()）</li>
<li>主体（<code>onDraw()</code>）</li>
<li>子 View（<code>dispatchDraw()</code>）</li>
<li>滑动边缘渐变和滑动条</li>
<li>前景</li>
</ol>
</li>
</ul>
<blockquote>
<p>关于绘制方法，有两点需要注意一下：</p>
<ol>
<li>出于效率的考虑，<code>ViewGroup</code> 默认会绕过 <code>draw()</code> 方法，换而直接执行 <code>dispatchDraw()</code>，以此来简化绘制流程。所以如果你自定义了某个 <code>ViewGroup</code> 的子类（比如 <code>LinearLayout</code>）并且需要在它的除 <code>dispatchDraw()</code> 以外的任何一个绘制方法内绘制内容，可能会需要调用 <code>View.setWillNotDraw(false)</code>这行代码来切换到完整的绘制流程（是「可能」而不是「必须」的原因是，有些 ViewGroup 是已经调用过 <code>setWillNotDraw(false)</code> 了的，例如 <code>ScrollView</code>）。</li>
<li>有的时候，一段绘制代码写在不同的绘制方法中效果是一样的，这时你可以选一个自己喜欢或者习惯的绘制方法来重写。但有一个例外：如果绘制代码既可以写在 <code>onDraw()</code> 里，也可以写在其他绘制方法里，那么优先写在 <code>onDraw()</code> ，因为 Android 有相关的优化，可以在不需要重绘的时候自动跳过 <code>onDraw()</code> 的重复执行，以提升开发效率。享受这种优化的只有 <code>onDraw()</code> 一个方法。</li>
</ol>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/07/自定View之Canvas对绘制的辅助/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="作茧自缚">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/07/自定View之Canvas对绘制的辅助/" itemprop="url">自定View之Canvas对绘制的辅助</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-07T21:53:22+08:00">
                2018-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/自定义View/" itemprop="url" rel="index">
                    <span itemprop="name">自定义View</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/07/自定View之Canvas对绘制的辅助/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/02/07/自定View之Canvas对绘制的辅助/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="范围剪裁"><a href="#范围剪裁" class="headerlink" title="范围剪裁"></a>范围剪裁</h2><blockquote>
<p>范围裁切有两个方法： <code>clipRect()</code> 和 <code>clipPath()</code>。裁切方法之后的绘制代码，都会被限制在裁切范围内。</p>
</blockquote>
<h3 id="clipRect"><a href="#clipRect" class="headerlink" title="clipRect()"></a>clipRect()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">canvas.save();  </span><br><span class="line">canvas.clipRect(left, top, right, bottom);  </span><br><span class="line">canvas.drawBitmap(bitmap, x, y, paint);  </span><br><span class="line">canvas.restore();</span><br></pre></td></tr></table></figure>
<h3 id="clipPath"><a href="#clipPath" class="headerlink" title="clipPath()"></a>clipPath()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">canvas.save();  </span><br><span class="line">canvas.clipPath(path1);  </span><br><span class="line">canvas.drawBitmap(bitmap, point1.x, point1.y, paint);  </span><br><span class="line">canvas.restore();</span><br><span class="line"></span><br><span class="line">canvas.save();  </span><br><span class="line">canvas.clipPath(path2);  </span><br><span class="line">canvas.drawBitmap(bitmap, point2.x, point2.y, paint);  </span><br><span class="line">canvas.restore();</span><br></pre></td></tr></table></figure>
<h2 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h2><blockquote>
<p>几何变换的使用大概分为三类：</p>
<ol>
<li>使用 <code>Canvas</code> 来做常见的二维变换；</li>
<li>使用 <code>Matrix</code> 来做常见和不常见的二维变换；</li>
<li>使用 <code>Camera</code> 来做三维变换。</li>
</ol>
</blockquote>
<h3 id="使用-Canvas-来做常见的二维变换"><a href="#使用-Canvas-来做常见的二维变换" class="headerlink" title="使用 Canvas 来做常见的二维变换"></a>使用 Canvas 来做常见的二维变换</h3><h4 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h4><blockquote>
<p>Canvas.translate(float dx, float dy) </p>
<p>参数里的 <code>dx</code> 和 <code>dy</code> 表示横向和纵向的位移。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; canvas.save();  </span><br><span class="line">&gt; canvas.translate(200, 0);  </span><br><span class="line">&gt; canvas.drawBitmap(bitmap, x, y, paint);  </span><br><span class="line">&gt; canvas.restore();  </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
</blockquote>
<h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><blockquote>
<p>Canvas.translate(float x, float y, float z) </p>
</blockquote>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><blockquote>
<p>Canvas.rotate(float degrees, float px, float py) </p>
<p>参数里的 <code>degrees</code> 是旋转角度，单位是度（也就是一周有 360° 的那个单位），方向是顺时针为正向； <code>px</code>和 <code>py</code> 是轴心的位置。</p>
</blockquote>
<h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><blockquote>
<p>Canvas.scale(float sx, float sy, float px, float py)</p>
<p>参数里的 <code>sx</code> <code>sy</code> 是横向和纵向的放缩倍数； <code>px</code> <code>py</code> 是放缩的轴心。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; canvas.save();  </span><br><span class="line">&gt; canvas.scale(1.3f, 1.3f, x + bitmapWidth / 2, y + bitmapHeight / 2);  </span><br><span class="line">&gt; canvas.drawBitmap(bitmap, x, y, paint);  </span><br><span class="line">&gt; canvas.restore();  </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="错切"><a href="#错切" class="headerlink" title="错切"></a>错切</h4><blockquote>
<p>skew(float sx, float sy)</p>
<p>参数里的 <code>sx</code> 和 <code>sy</code> 是 x 方向和 y 方向的错切系数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; canvas.save();  </span><br><span class="line">&gt; canvas.skew(0, 0.5f);  </span><br><span class="line">&gt; canvas.drawBitmap(bitmap, x, y, paint);  </span><br><span class="line">&gt; canvas.restore();  </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="使用-Matrix-来做变换"><a href="#使用-Matrix-来做变换" class="headerlink" title="使用 Matrix 来做变换"></a>使用 Matrix 来做变换</h3><h4 id="使用-Matrix-来做常见变换"><a href="#使用-Matrix-来做常见变换" class="headerlink" title="使用 Matrix 来做常见变换"></a>使用 Matrix 来做常见变换</h4><ul>
<li><code>Matrix</code> 做常见变换的方式：<ol>
<li>创建 <code>Matrix</code> 对象；</li>
<li>调用 <code>Matrix</code> 的 <code>pre/postTranslate/Rotate/Scale/Skew()</code> 方法来设置几何变换；</li>
<li>使用 <code>Canvas.setMatrix(matrix)</code> 或 <code>Canvas.concat(matrix)</code> 来把几何变换应用到 <code>Canvas</code>。</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Matrix matrix = new Matrix();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">matrix.reset();  </span><br><span class="line">matrix.postTranslate();  </span><br><span class="line">matrix.postRotate();</span><br><span class="line"></span><br><span class="line">canvas.save();  </span><br><span class="line">canvas.concat(matrix);  </span><br><span class="line">canvas.drawBitmap(bitmap, x, y, paint);  </span><br><span class="line">canvas.restore();</span><br></pre></td></tr></table></figure>
<ul>
<li>把 <code>Matrix</code> 应用到 <code>Canvas</code> 有两个方法： <code>Canvas.setMatrix(matrix)</code> 和 <code>Canvas.concat(matrix)</code>。<ol>
<li><code>Canvas.setMatrix(matrix)</code>：用 <code>Matrix</code> 直接替换 <code>Canvas</code> 当前的变换矩阵，即抛弃 <code>Canvas</code> 当前的变换，改用 <code>Matrix</code> 的变换（注：根据下面评论里以及我在微信公众号中收到的反馈，不同的系统中 <code>setMatrix(matrix)</code> 的行为可能不一致，所以还是尽量用 <code>concat(matrix)</code> 吧）；</li>
<li><code>Canvas.concat(matrix)</code>：用 <code>Canvas</code> 当前的变换矩阵和 <code>Matrix</code> 相乘，即基于 <code>Canvas</code> 当前的变换，叠加上 <code>Matrix</code> 中的变换。</li>
</ol>
</li>
</ul>
<h4 id="使用-Matrix-来做自定义变换"><a href="#使用-Matrix-来做自定义变换" class="headerlink" title="使用 Matrix 来做自定义变换"></a>使用 Matrix 来做自定义变换</h4><blockquote>
<p><code>Matrix</code> 的自定义变换使用的是 <code>setPolyToPoly()</code> 方法。</p>
</blockquote>
<ul>
<li><p>用点对点映射的方式设置变换</p>
<ul>
<li><p>Matrix.setPolyToPoly(float[] src, int srcIndex, float[] dst, int dstIndex, int pointCount)</p>
</li>
<li><p><code>poly</code> 就是「多」的意思。<code>setPolyToPoly()</code> 的作用是通过多点的映射的方式来直接设置变换。「多点映射」的意思就是把指定的点移动到给出的位置，从而发生形变。例如：(0, 0) -&gt; (100, 100) 表示把 (0, 0) 位置的像素移动到 (100, 100) 的位置，这个是单点的映射，单点映射可以实现平移。而多点的映射，就可以让绘制内容任意地扭曲。</p>
</li>
<li><p>参数里，<code>src</code> 和 <code>dst</code> 是源点集合目标点集；<code>srcIndex</code> 和 <code>dstIndex</code> 是第一个点的偏移；<code>pointCount</code> 是采集的点的个数（个数不能大于 4，因为大于 4 个点就无法计算变换了）。</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Matrix matrix = new Matrix();  </span><br><span class="line">float pointsSrc = &#123;left, top, right, top, left, bottom, right, bottom&#125;;  </span><br><span class="line">float pointsDst = &#123;left - 10, top + 50, right + 120, top - 90, left + 20, bottom + 30, right + 20, bottom + 60&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">matrix.reset();  </span><br><span class="line">matrix.setPolyToPoly(pointsSrc, 0, pointsDst, 0, 4);</span><br><span class="line"></span><br><span class="line">canvas.save();  </span><br><span class="line">canvas.concat(matrix);  </span><br><span class="line">canvas.drawBitmap(bitmap, x, y, paint);  </span><br><span class="line">canvas.restore();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>​</p>
</li>
</ul>
<h3 id="使用-Camera-来做三维变换"><a href="#使用-Camera-来做三维变换" class="headerlink" title="使用 Camera 来做三维变换"></a>使用 Camera 来做三维变换</h3><blockquote>
<p><code>Camera</code> 的三维变换有三类：旋转、平移、移动相机。</p>
</blockquote>
<h4 id="三维旋转"><a href="#三维旋转" class="headerlink" title="三维旋转"></a>三维旋转</h4><ul>
<li><p>Camera.rotate<em>()</em></p>
</li>
<li><p><em>`Camera.rotate</em>()<code>一共有四个方法：</code>rotateX(deg)rotateY(deg)rotateZ(deg)rotate(x, y, z)</p>
</li>
<li><p><code>Camera</code> 和 <code>Canvas</code> 一样也需要保存和恢复状态才能正常绘制，不然在界面刷新之后绘制就会出现问题。</p>
</li>
<li><p>如果你需要图形左右对称，需要配合上 <code>Canvas.translate()</code>，在三维旋转之前把绘制内容的中心点移动到原点，即旋转的轴心，然后在三维旋转后再把投影移动回来：</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">canvas.save();</span><br><span class="line"></span><br><span class="line">camera.save(); // 保存 Camera 的状态  </span><br><span class="line">camera.rotateX(30); // 旋转 Camera 的三维空间  </span><br><span class="line">canvas.translate(centerX, centerY); // 旋转之后把投影移动回来  </span><br><span class="line">camera.applyToCanvas(canvas); // 把旋转投影到 Canvas  </span><br><span class="line">canvas.translate(-centerX, -centerY); // 旋转之前把绘制内容移动到轴心（原点）  </span><br><span class="line">camera.restore(); // 恢复 Camera 的状态</span><br><span class="line"></span><br><span class="line">canvas.drawBitmap(bitmap, point1.x, point1.y, paint);  </span><br><span class="line">canvas.restore();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="平移-1"><a href="#平移-1" class="headerlink" title="平移"></a>平移</h4><ul>
<li>Camera.translate(float x, float y, float z)</li>
</ul>
<h4 id="设置虚拟相机的位置"><a href="#设置虚拟相机的位置" class="headerlink" title="设置虚拟相机的位置"></a>设置虚拟相机的位置</h4><blockquote>
<p>Camera.setLocation(x, y, z) </p>
</blockquote>
<ul>
<li>参数的单位不是像素，而是 inch，英寸。这种设计源自 Android 底层的图像引擎 <a href="https://skia.org/" target="_blank" rel="noopener">Skia</a> 。在 Skia 中，Camera 的位置单位是英寸，英寸和像素的换算单位在 Skia 中被写死为了 72 像素，而 Android 中把这个换算单位照搬了过来。是的，它写死了。</li>
<li>在 <code>Camera</code> 中，相机的默认位置是 (0, 0, -8)（英寸）。8 x 72 = 576，所以它的默认位置是 (0, 0, -576)（像素）。如果绘制的内容过大，当它翻转起来的时候，就有可能出现图像投影过大的「糊脸」效果。而且由于换算单位被写死成了 72 像素，而不是和设备 dpi 相关的，所以在像素越大的手机上，这种「糊脸」效果会越明显。而使用 <code>setLocation()</code> 方法来把相机往后移动，就可以修复这种问题。<code>Camera.setLocation(x, y, z)</code> 的 <code>x</code> 和 <code>y</code> 参数一般不会改变，直接填 0 就好。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/07/自定View之Paint详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="作茧自缚">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/07/自定View之Paint详解/" itemprop="url">自定View之Paint详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-07T21:52:37+08:00">
                2018-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/自定义View/" itemprop="url" rel="index">
                    <span itemprop="name">自定义View</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/07/自定View之Paint详解/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/02/07/自定View之Paint详解/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/07/自定View之Canvas的系列方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="作茧自缚">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/07/自定View之Canvas的系列方法/" itemprop="url">自定View之Canvas的系列方法及 Paint最常见的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-07T21:51:48+08:00">
                2018-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/自定义View/" itemprop="url" rel="index">
                    <span itemprop="name">自定义View</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/07/自定View之Canvas的系列方法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/02/07/自定View之Canvas的系列方法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><code>Canvas.drawXXX()</code> 是自定义绘制最基本的操作。通过该方法可以绘制圆、方、图像、和文字，并且组合这些内容，在通过Paint的一些常见方法来对绘制内容的颜色和风格进行简单配置。</p>
</blockquote>
<h2 id="View的坐标系"><a href="#View的坐标系" class="headerlink" title="View的坐标系"></a>View的坐标系</h2><ul>
<li>在 Android 里，每个 View 都有一个自己的坐标系，彼此之间是不影响的。这个坐标系的原点是 View 左上角的那个点；水平方向是 x 轴，右正左负；竖直方向是 y 轴，下正上负。</li>
<li>Canvas.translate(dx,dy)：View的坐标系原点移动指定距离，dx为移动的x方向距离，dy为移动的y方向的问题。</li>
</ul>
<h2 id="Canvas-drawXXX-和-Paint-基础"><a href="#Canvas-drawXXX-和-Paint-基础" class="headerlink" title="Canvas.drawXXX() 和 Paint 基础"></a>Canvas.drawXXX() 和 Paint 基础</h2><ol>
<li><p><code>Canvas</code> 类下的所有 <code>draw-</code> 开头的方法：</p>
<ul>
<li><code>drawCircle()</code> </li>
<li><code>drawBitmap()</code></li>
<li><code>drawOval()</code></li>
<li><code>drawPoint()</code></li>
<li><code>drawRect()</code></li>
<li><code>drawArc()</code></li>
<li><code>drawPath()</code></li>
</ul>
</li>
<li><p><code>Paint</code> 类的几个最常用的方法：</p>
<ul>
<li><code>Paint.setStyle(Style style)</code> 设置绘制模式<ul>
<li>Paint.Style.STROK：画线模式</li>
<li>Paint.Style.FILL：填充末世</li>
<li>FILL_AND_STROKE：既画线又填充</li>
</ul>
</li>
<li><code>Paint.setColor(int color)</code> 设置颜色</li>
<li><code>Paint.setStrokeWidth(float width)</code> 设置线条宽度</li>
<li><code>Paint.setTextSize(float textSize)</code> 设置文字大小</li>
<li><code>Paint.setAntiAlias(boolean aa)</code> 设置抗锯齿开关</li>
<li><code>Paint.setTextAlign(Align align)</code>设置文字居中，左对齐，右对齐</li>
</ul>
<p>​</p>
</li>
</ol>
<h2 id="颜色填充"><a href="#颜色填充" class="headerlink" title="颜色填充"></a>颜色填充</h2><blockquote>
<p><strong>Canvas.drawColor(@ColorInt int color)</strong></p>
</blockquote>
<ul>
<li>在整个绘制区域统一涂上指定的颜色,这类颜色填充方法一般用于在绘制之前设置底色，或者在绘制之后为界面设置半透明蒙版。</li>
</ul>
<ul>
<li>类似的方法还有 <code>drawRGB(int r, int g, int b)</code> 和 <code>drawARGB(int a, int r, int g, int b)</code> ，它们和 <code>drawColor(color)</code> 只是使用方式不同，作用都是一样的。</li>
</ul>
<h2 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h2><blockquote>
<p>drawCircle(float centerX, float centerY, float radius, Paint paint)</p>
</blockquote>
<ul>
<li>centerX , centerY：圆的圆心坐标（单位像素）。</li>
<li>radius：圆的半径（单位像素）。</li>
</ul>
<h2 id="画矩形"><a href="#画矩形" class="headerlink" title="画矩形"></a>画矩形</h2><blockquote>
<p><strong>drawRect(float left, float top, float right, float bottom, Paint paint)</strong></p>
</blockquote>
<ul>
<li><code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> 是矩形四条边的坐标。</li>
<li>两个重载方法 <code>drawRect(RectF rect, Paint paint)</code> 和 <code>drawRect(Rect rect, Paint paint)</code>，直接设置<code>RectF</code> 或 <code>Rect</code> 对象来绘制矩形。</li>
</ul>
<h2 id="画点"><a href="#画点" class="headerlink" title="画点"></a>画点</h2><blockquote>
<p><strong>drawPoint(float x, float y, Paint paint)</strong></p>
</blockquote>
<ul>
<li><code>x</code> 和 <code>y</code> 是点的坐标。点的大小可以通过 <code>paint.setStrokeWidth(width)</code> 来设置；</li>
<li>点的形状可以通过 <code>paint.setStrokeCap(cap)</code> 来设置：<code>ROUND</code> 画出来是圆形的点，<code>SQUARE</code> 或 <code>BUTT</code> 画出来是方形的点</li>
<li><code>Paint.setStrokeCap(cap)</code> 可以设置点的形状，但这个方法并不是专门用来设置点的形状的，而是一个设置线条端点形状的方法。端点有圆头 (<code>ROUND</code>)、平头 (<code>BUTT</code>) 和方头 (<code>SQUARE</code>) 三种。</li>
<li>drawPoints(float[] pts, int offset, int count, Paint paint) / drawPoints(float[] pts, Paint paint) 批量画点,<code>pts</code> 这个数组是点的坐标，每两个成一对；<code>offset</code>表示跳过数组的前几个数再开始记坐标；<code>count</code> 表示一共要绘制几个点。</li>
</ul>
<h2 id="画椭圆"><a href="#画椭圆" class="headerlink" title="画椭圆"></a>画椭圆</h2><blockquote>
<p>drawOval(float left, float top, float right, float bottom, Paint paint)</p>
</blockquote>
<ul>
<li>只能绘制横着的或者竖着的椭圆，不能绘制斜的（斜的倒是也可以，但不是直接使用 <code>drawOval()</code>，而是配合几何变换）。<code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> 是这个椭圆的左、上、右、下四个边界点的坐标。</li>
<li>重载方法 <code>drawOval(RectF rect, Paint paint)</code>，让你可以直接填写 <code>RectF</code> 来绘制椭圆。</li>
</ul>
<h2 id="画线"><a href="#画线" class="headerlink" title="画线"></a>画线</h2><blockquote>
<p><strong>drawLine(float startX, float startY, float stopX, float stopY, Paint paint)</strong></p>
</blockquote>
<ul>
<li>由于直线不是封闭图形，所以 <code>setStyle(style)</code> 对直线没有影响。</li>
<li>drawLines(float[] pts, int offset, int count, Paint paint) / drawLines(float[] pts, Paint paint) 批量画线。</li>
</ul>
<h2 id="画圆角矩形"><a href="#画圆角矩形" class="headerlink" title="画圆角矩形"></a>画圆角矩形</h2><blockquote>
<p>drawRoundRect(float left, float top, float right, float bottom, float rx, float ry, Paint paint)</p>
</blockquote>
<ul>
<li><code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> 是四条边的坐标，<code>rx</code> 和 <code>ry</code> 是圆角的横向半径和纵向半径。</li>
<li>重载方法 <code>drawRoundRect(RectF rect, float rx, float ry, Paint paint)</code>，让你可以直接填写 <code>RectF</code> 来绘制圆角矩形。</li>
</ul>
<h2 id="画-Bitmap"><a href="#画-Bitmap" class="headerlink" title="画 Bitmap"></a>画 Bitmap</h2><blockquote>
<p><strong>drawBitmap(Bitmap bitmap, float left, float top, Paint paint)</strong></p>
</blockquote>
<ul>
<li>重载方法：<ul>
<li><code>drawBitmap(Bitmap bitmap, Rect src, RectF dst, Paint paint)</code> </li>
<li><code>drawBitmap(Bitmap bitmap, Rect src, Rect dst, Paint paint)</code> </li>
<li><code>drawBitmap(Bitmap bitmap, Matrix matrix, Paint paint)</code></li>
</ul>
</li>
<li><code>drawBitmapMesh()</code>，可以绘制具有网格拉伸效果的 Bitmap。 </li>
</ul>
<h2 id="绘制弧形或扇形"><a href="#绘制弧形或扇形" class="headerlink" title="绘制弧形或扇形"></a>绘制弧形或扇形</h2><blockquote>
<p><strong>drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint)</strong></p>
</blockquote>
<ul>
<li><code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> 描述的是这个弧形所在的椭圆；<code>startAngle</code> 是弧形的起始角度（x 轴的正向，即正右的方向，是 0 度的位置；顺时针为正角度，逆时针为负角度），<code>sweepAngle</code> 是弧形划过的角度；<code>useCenter</code> 表示是否连接到圆心，如果不连接到圆心，就是弧形，如果连接到圆心，就是扇形。</li>
</ul>
<h2 id="画自定义图形"><a href="#画自定义图形" class="headerlink" title="画自定义图形"></a>画自定义图形</h2><blockquote>
<p><strong>drawPath(Path path, Paint paint)</strong></p>
</blockquote>
<ul>
<li><p>Path 方法第一类：直接描述路径</p>
<ul>
<li><p>addXxx()：添加字图形。</p>
<ul>
<li><strong>添加圆</strong>：<ul>
<li>addCircle(float x, float y, float radius, Direction dir) </li>
</ul>
</li>
<li><strong>添加椭圆</strong>：<ul>
<li>addOval(float left, float top, float right, float bottom, Direction dir) / addOval(RectF oval, Direction dir) </li>
</ul>
</li>
<li><strong>添加矩形</strong>：<ul>
<li>addRect(float left, float top, float right, float bottom, Direction dir) / addRect(RectF rect, Direction dir) </li>
</ul>
</li>
<li><strong>添加圆角矩形</strong>：<ul>
<li>addRoundRect(RectF rect, float rx, float ry, Direction dir) / addRoundRect(float left, float top, float right, float bottom, float rx, float ry, Direction dir) / addRoundRect(RectF rect, float[] radii, Direction dir) / addRoundRect(float left, float top, float right, float bottom, float[] radii, Direction dir) </li>
</ul>
</li>
<li><strong>添加一个 Path</strong>：<ul>
<li>addPath(Path path) </li>
</ul>
</li>
<li><strong>dir</strong>：画圆的路径的方向，路径方向是顺时针 (<code>CW</code> clockwise) 和逆时针 (<code>CCW</code> counter-clockwise) 。对于普通情况，这个参数填 <code>CW</code> 还是填 <code>CCW</code> 没有影响。它只是在<strong>需要填充图形</strong> (<code>Paint.Style</code> 为 <code>FILL</code> 或 <code>FILL_AND_STROKE</code>) ，并且<strong>图形出现自相交</strong>时，用于判断填充范围。</li>
</ul>
</li>
<li><p><code>xxxTo()</code>：画线（直线或曲线）</p>
<blockquote>
<p>第一组是添加的完整封闭图形（除了 <code>addPath()</code> ），而这一组添加的只是一条线。</p>
</blockquote>
<ul>
<li><strong>画直线</strong>：<ul>
<li>lineTo(float x, float y) / rLineTo(float x, float y) ，从<strong>当前位置</strong>向目标位置画一条直线， <code>x</code> 和 <code>y</code> 是目标位置的坐标。这两个方法的区别是，<code>lineTo(x, y)</code> 的参数是<strong>绝对坐标</strong>，而 <code>rLineTo(x, y)</code> 的参数是相对当前位置的<strong>相对坐标</strong> （前缀 <code>r</code> 指的就是 <code>relatively</code> 「相对地」)。<strong>当前位置</strong>：所谓当前位置，即最后一次调用画 <code>Path</code> 的方法的终点位置。初始值为原点 (0, 0)。</li>
</ul>
</li>
<li><strong>画二次贝塞尔曲线</strong>：<ul>
<li>quadTo(float x1, float y1, float x2, float y2) / rQuadTo(float dx1, float dy1, float dx2, float dy2)。<code>x1</code>, <code>y1</code> 和 <code>x2</code>, <code>y2</code> 则分别是控制点和终点的坐标。</li>
</ul>
</li>
<li><strong>画三次贝塞尔曲线</strong>：<ul>
<li>cubicTo(float x1, float y1, float x2, float y2, float x3, float y3) / rCubicTo(float x1, float y1, float x2, float y2, float x3, float y3) 。</li>
</ul>
</li>
<li><strong>移动到目标位置</strong>：<ul>
<li>moveTo(float x, float y) / rMoveTo(float x, float y)，设置图形的起点。</li>
</ul>
</li>
<li><strong>封闭当前子图形</strong>：<ul>
<li>close() </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Path 方法第二类：辅助的设置或计算</p>
<ul>
<li><p><strong>Path.setFillType(Path.FillType ft)</strong> 设置填充方式,<code>FillType</code> 值:</p>
<ul>
<li><code>EVEN_ODD</code> ：全填充</li>
<li><code>WINDING</code> （默认值）：交叉填充</li>
<li><code>INVERSE_EVEN_ODD</code></li>
<li><code>INVERSE_WINDING</code></li>
</ul>
<p><img src="http://ouv36g1sw.bkt.clouddn.com/EVEN_ODD%E5%92%8CWINDING%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA" alt="EVEN_ODD和WINDING效果展示"></p>
<p>​</p>
</li>
<li><h5 id="EVEN-ODD："><a href="#EVEN-ODD：" class="headerlink" title="EVEN_ODD："></a>EVEN_ODD：</h5><ul>
<li><p><strong>even-odd rule （奇偶原则）</strong>：对于平面中的任意一点，向任意方向射出一条射线，这条射线和图形相交的次数（相交才算，相切不算哦）如果是奇数，则这个点被认为在图形内部，是要被涂色的区域；如果是偶数，则这个点被认为在图形外部，是不被涂色的区域。</p>
<p><img src="http://ouv36g1sw.bkt.clouddn.com/EVEN_ODD%E5%A5%87%E5%81%B6%E5%8E%9F%E5%88%99.jpg" alt="EVEN_ODD奇偶原则"></p>
</li>
</ul>
</li>
<li><h5 id="WINDING"><a href="#WINDING" class="headerlink" title="WINDING"></a>WINDING</h5><ul>
<li><p><strong>non-zero winding rule （非零环绕数原则）</strong>：从平面中的点向任意方向射出一条射线，以 0 为初始值，对于射线和图形的所有交点，遇到每个顺时针的交点（图形从射线的左边向右穿过）把结果加 1，遇到每个逆时针的交点（图形从射线的右边向左穿过）把结果减 1，最终把所有的交点都算上，得到的结果如果不是 0，则认为这个点在图形内部，是要被涂色的区域；如果是 0，则认为这个点在图形外部，是不被涂色的区域。</p>
<p><img src="http://ouv36g1sw.bkt.clouddn.com/WINDING%E9%9D%9E%E9%9B%B6%E7%8E%AF%E7%BB%95%E6%95%B0%E5%8E%9F%E5%88%99" alt="WINDING非零环绕数原则"></p>
</li>
<li><p><strong>图形的方向</strong>：对于添加子图形类方法（如 <code>Path.addCircle()</code> <code>Path.addRect()</code>）的方向，由方法的 <code>dir</code> 参数来控制，这个在前面已经讲过了；而对于画线类的方法（如 <code>Path.lineTo()</code> <code>Path.arcTo()</code>）就更简单了，线的方向就是图形的方向。</p>
</li>
</ul>
</li>
<li><p><strong>INVERSE_EVEN_ODD</strong> 和 <strong>INVERSE_WINDING</strong>，只是把<strong>EVEN_ODD</strong>和<strong>INVERSE_WINDING</strong>效果进行反转而已。</p>
</li>
<li><p><strong>EVEN_ODD</strong>和<strong>INVERSE_WINDING</strong>完整效果图</p>
<p><img src="http://ouv36g1sw.bkt.clouddn.com/WINDING%E5%92%8CEVend_ODD%E5%AE%8C%E6%95%B4%E6%95%88%E6%9E%9C" alt="WINDING和EVend_ODD完整效果"></p>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/04/有关MVP的设计/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="作茧自缚">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/04/有关MVP的设计/" itemprop="url">有关MVP的设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-04T22:51:44+08:00">
                2018-02-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android架构/" itemprop="url" rel="index">
                    <span itemprop="name">Android架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/04/有关MVP的设计/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/02/04/有关MVP的设计/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>BasePresenter中BaseView的绑定和解绑：由于Presenter要获取View对象调用View中方法，所以需要对View进行绑定，当View销毁时因为View的对象为null，需要Presenter对View进行解绑，不然Presenter会持有View的引用导致内存泄漏。</li>
<li>代理模式<ul>
<li><strong>抽象角色</strong>：声明真实对象和代理对象的共同接口；</li>
<li><strong>代理角色</strong>：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。</li>
<li><strong>真实角色</strong>：代理角色所代表的真实对象，是我们最终要引用的对象。</li>
</ul>
</li>
<li>代理模式在MVP设计中的体现<ol>
<li>第一重代理: 绑定与解绑的代理（代理角色ProxyMvpCallback为真实角色BaseActivity实现绑定与解绑功能）<ul>
<li>抽象角色：MvpCallBack，创建与设置BasePresenter和BaseView的接口。</li>
<li>代理角色：ProxyMvpCallback</li>
<li>真实角色：BaseActivity</li>
</ul>
</li>
<li>第二重代理：Activity生命周期的代理（代理对象BaseActivity为真实对象抽象角色MvpActivityDelegate实现Activity的生命周期方法）<ul>
<li>抽象角色：MvpActivityDelegate 即代理Activity的生命周期</li>
<li>代理角色：BaseActivity为代理角色内部在Activity生命周期中调用了真实角色的MvpActivityDelegateImpl的生命周期方法。</li>
<li>真实角色：MvpActivityDelegateImpl，实现了Activity的生命周期。</li>
</ul>
</li>
<li>第一重代理与第二重代理相结合即是双重代理：代理对象ProxyMvpCallback为真实对象MvpActivityDelegate在生命周期方法中实现绑定与解绑功能</li>
</ol>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/04/LRUCache原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="作茧自缚">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/04/LRUCache原理/" itemprop="url">LRUCache原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-04T22:51:44+08:00">
                2018-02-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android基础/" itemprop="url" rel="index">
                    <span itemprop="name">Android基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/04/LRUCache原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/02/04/LRUCache原理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>LRUCache算法中LRU是指Last Recently Used，也就是最近最少使用算法。当缓存控件满了的时候，将最近最少使用的数据从缓存控件中删除以增加缓存空间来缓存新内容。这个算法内部有一个缓存列表，每当一个数据被访问的时候，改数据就会被提到列表头部，蓑衣列表尾部的数据就是最近最不常是使用的了，当缓存空间不足，就会删除列表尾部的缓存数据。</p>
</blockquote>
<h2 id="LRUCache源码解析"><a href="#LRUCache源码解析" class="headerlink" title="LRUCache源码解析"></a>LRUCache源码解析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * LruCache通过强引用来缓存一定数量的值，每当一个值被访问时，这个值就会移动到缓存列表的头部。</span><br><span class="line"> * 如果插入数据时发现缓存不够，就会将队列中访问次数最少的数据删掉。</span><br><span class="line"> */</span><br><span class="line">public class LruCache&lt;K, V&gt; &#123;</span><br><span class="line">	// 存放缓存内容的map</span><br><span class="line">    private final LinkedHashMap&lt;K, V&gt; map;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Size of this cache in units. Not necessarily the number of elements. </span><br><span class="line">     * 当前缓存已使用大小，不一定是元素的个数</span><br><span class="line">     */</span><br><span class="line">    private int size;</span><br><span class="line">    // 内存最大值</span><br><span class="line">    private int maxSize;</span><br><span class="line">    // 各个方法被调用的次数</span><br><span class="line">    private int putCount;</span><br><span class="line">    private int createCount;</span><br><span class="line">    private int evictionCount;</span><br><span class="line">    private int hitCount;</span><br><span class="line">    private int missCount;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param maxSize for caches that do not override &#123;@link #sizeOf&#125;, this is</span><br><span class="line">     *     the maximum number of entries in the cache. For all other caches,</span><br><span class="line">     *     this is the maximum sum of the sizes of the entries in this cache.</span><br><span class="line">     * 构造方法 传入maxSize是缓存的最大值</span><br><span class="line">     */</span><br><span class="line">    public LruCache(int maxSize) &#123;</span><br><span class="line">        if (maxSize &lt;= 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.maxSize = maxSize;</span><br><span class="line">        // 初始化LinkedHashMap</span><br><span class="line">        // 第一个参数是初始容量</span><br><span class="line">        // 第二个参数为填装因子或加载因子</span><br><span class="line">        // 第三个参数为排序模式，true表示在访问的时候进行排序，否则只在插入的时候排序。</span><br><span class="line">        this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Sets the size of the cache.</span><br><span class="line">     * 重置最大缓存</span><br><span class="line">     * @param maxSize The new maximum size.</span><br><span class="line">     */</span><br><span class="line">    public void resize(int maxSize) &#123;</span><br><span class="line">        if (maxSize &lt;= 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            this.maxSize = maxSize;</span><br><span class="line">        &#125;</span><br><span class="line">        trimToSize(maxSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the value for &#123;@code key&#125; if it exists in the cache or can be</span><br><span class="line">     * created by &#123;@code #create&#125;. If a value was returned, it is moved to the</span><br><span class="line">     * head of the queue. This returns null if a value is not cached and cannot</span><br><span class="line">     * be created.</span><br><span class="line">     * 通过Key获取缓存的数据，如果通过这个方法得到的需要的元素,那么该元素会被放在缓存队列的头部</span><br><span class="line">     */</span><br><span class="line">    public final V get(K key) &#123;</span><br><span class="line">        if (key == null) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;key == null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        V mapValue;</span><br><span class="line">        // 同步代码块</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">        	// 从LinkedHashMap中获取数据</span><br><span class="line">            mapValue = map.get(key);</span><br><span class="line">            if (mapValue != null) &#123;</span><br><span class="line">                hitCount++;</span><br><span class="line">                return mapValue;</span><br><span class="line">            &#125;</span><br><span class="line">            missCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Attempt to create a value. This may take a long time, and the map</span><br><span class="line">         * may be different when create() returns. If a conflicting value was</span><br><span class="line">         * added to the map while create() was working, we leave that value in</span><br><span class="line">         * the map and release the created value.</span><br><span class="line">         * 如果通过Key从缓存集合中获取缓存不到的数据，就尝试使用creat(key)方法创造一个新数据。</span><br><span class="line">         * create(key)默认返回的也是null,需要重写该方法</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        V createdValue = create(key);</span><br><span class="line">        if (createdValue == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">		// 若是重写了create(key)方法，便将新的数据放入缓存中。</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            createCount++;</span><br><span class="line">            mapValue = map.put(key, createdValue);</span><br><span class="line">            if (mapValue != null) &#123;</span><br><span class="line">                // There was a conflict so undo that last put 有冲突撤销之前设置的值</span><br><span class="line">                map.put(key, mapValue);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                size += safeSizeOf(key, createdValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mapValue != null) &#123;</span><br><span class="line">            entryRemoved(false, key, createdValue, mapValue);</span><br><span class="line">            return mapValue;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            trimToSize(maxSize);</span><br><span class="line">            return createdValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Caches &#123;@code value&#125; for &#123;@code key&#125;. The value is moved to the head of</span><br><span class="line">     * the queue.</span><br><span class="line">     * 向缓存队列中添加数据，并将数据移动到队列头部</span><br><span class="line">     * @return the previous value mapped by &#123;@code key&#125;.</span><br><span class="line">     */</span><br><span class="line">    public final V put(K key, V value) &#123;</span><br><span class="line">        if (key == null || value == null) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;key == null || value == null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        V previous;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            putCount++;</span><br><span class="line">            // safeSizeOf(Key,value);该方法返回的是1，也就是将缓存的个数加1.</span><br><span class="line">            // 当缓存的是图片的时候，这个size应该表示图片占用的内存的大小，</span><br><span class="line">            // 所以应该重写里面调用sizeOf(key,value)的方法</span><br><span class="line">            size += safeSizeOf(key, value);</span><br><span class="line">            // 将新创建的元素加入缓存队列，并在添加成功后返回这个元素</span><br><span class="line">            previous = map.put(key, value);</span><br><span class="line">            if (previous != null) &#123;</span><br><span class="line">            	// 如果换回为null,则说明缓存失败，在已用的缓存大小中减去改元素大小</span><br><span class="line">                size -= safeSizeOf(key, previous);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (previous != null) &#123;</span><br><span class="line">            entryRemoved(false, key, previous, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        trimToSize(maxSize);</span><br><span class="line">        return previous;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Remove the eldest entries until the total of remaining entries is at or</span><br><span class="line">     * below the requested size.</span><br><span class="line">     * 修改缓存大小，是已用的缓存不大于设置的缓存最大值</span><br><span class="line">     * @param maxSize the maximum size of the cache before returning. May be -1</span><br><span class="line">     *            to evict even 0-sized elements.</span><br><span class="line">     */</span><br><span class="line">    public void trimToSize(int maxSize) &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            K key;</span><br><span class="line">            V value;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123;</span><br><span class="line">                    throw new IllegalStateException(getClass().getName()</span><br><span class="line">                            + &quot;.sizeOf() is reporting inconsistent results!&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">				// 已用缓存小于最大缓存，则完成任务退出循环</span><br><span class="line">                if (size &lt;= maxSize || map.isEmpty()) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">				// 否则在缓存队列中先找到最近最少使用的元素，</span><br><span class="line">				// 调用LinkedHashMap的eldest()方法返回最不经常使用的元素。</span><br><span class="line">                Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();</span><br><span class="line">                // 删掉改元素减少已使用的缓存空间</span><br><span class="line">                key = toEvict.getKey();</span><br><span class="line">                value = toEvict.getValue();</span><br><span class="line">                map.remove(key);</span><br><span class="line">                size -= safeSizeOf(key, value);</span><br><span class="line">                evictionCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            entryRemoved(true, key, value, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Removes the entry for &#123;@code key&#125; if it exists.</span><br><span class="line">     * 删除</span><br><span class="line">     * @return the previous value mapped by &#123;@code key&#125;.</span><br><span class="line">     */</span><br><span class="line">    public final V remove(K key) &#123;</span><br><span class="line">        if (key == null) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;key == null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        V previous;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            previous = map.remove(key);</span><br><span class="line">            if (previous != null) &#123;</span><br><span class="line">                size -= safeSizeOf(key, previous);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (previous != null) &#123;</span><br><span class="line">            entryRemoved(false, key, previous, null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return previous;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Called for entries that have been evicted or removed. This method is</span><br><span class="line">     * invoked when a value is evicted to make space, removed by a call to</span><br><span class="line">     * &#123;@link #remove&#125;, or replaced by a call to &#123;@link #put&#125;. The default</span><br><span class="line">     * implementation does nothing.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;The method is called without synchronization: other threads may</span><br><span class="line">     * access the cache while this method is executing.</span><br><span class="line">     *</span><br><span class="line">     * @param evicted true if the entry is being removed to make space, false</span><br><span class="line">     *     if the removal was caused by a &#123;@link #put&#125; or &#123;@link #remove&#125;.</span><br><span class="line">     * @param newValue the new value for &#123;@code key&#125;, if it exists. If non-null,</span><br><span class="line">     *     this removal was caused by a &#123;@link #put&#125;. Otherwise it was caused by</span><br><span class="line">     *     an eviction or a &#123;@link #remove&#125;.</span><br><span class="line">     * 默认为空方法，有需要才会自己实现，evicted如果是true,则表示这个元素因为空间不够而被自动清理了，所以</span><br><span class="line">     * 可以在这个地方队被清理的元素进行再次缓存</span><br><span class="line">     */</span><br><span class="line">    protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Called after a cache miss to compute a value for the corresponding key.</span><br><span class="line">     * Returns the computed value or null if no value can be computed. The</span><br><span class="line">     * default implementation returns null.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;The method is called without synchronization: other threads may</span><br><span class="line">     * access the cache while this method is executing.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;If a value for &#123;@code key&#125; exists in the cache when this method</span><br><span class="line">     * returns, the created value will be released with &#123;@link #entryRemoved&#125;</span><br><span class="line">     * and discarded. This can occur when multiple threads request the same key</span><br><span class="line">     * at the same time (causing multiple values to be created), or when one</span><br><span class="line">     * thread calls &#123;@link #put&#125; while another is creating a value for the same</span><br><span class="line">     * key.</span><br><span class="line">     */</span><br><span class="line">    protected V create(K key) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int safeSizeOf(K key, V value) &#123;</span><br><span class="line">        int result = sizeOf(key, value);</span><br><span class="line">        if (result &lt; 0) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Negative size: &quot; + key + &quot;=&quot; + value);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the size of the entry for &#123;@code key&#125; and &#123;@code value&#125; in</span><br><span class="line">     * user-defined units.  The default implementation returns 1 so that size</span><br><span class="line">     * is the number of entries and max size is the maximum number of entries.</span><br><span class="line">     * 用来定义已用缓存的数量算法，默认是返回数量</span><br><span class="line">     * &lt;p&gt;An entry&apos;s size must not change while it is in the cache.</span><br><span class="line">     */</span><br><span class="line">    protected int sizeOf(K key, V value) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Clear the cache, calling &#123;@link #entryRemoved&#125; on each removed entry.</span><br><span class="line">     * 清空所有缓存</span><br><span class="line">     */</span><br><span class="line">    public final void evictAll() &#123;</span><br><span class="line">        trimToSize(-1); // -1 will evict 0-sized elements</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * For caches that do not override &#123;@link #sizeOf&#125;, this returns the number</span><br><span class="line">     * of entries in the cache. For all other caches, this returns the sum of</span><br><span class="line">     * the sizes of the entries in this cache.</span><br><span class="line">     * 不可重写，返回的值是缓存的条目数</span><br><span class="line">     */</span><br><span class="line">    public synchronized final int size() &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * For caches that do not override &#123;@link #sizeOf&#125;, this returns the maximum</span><br><span class="line">     * number of entries in the cache. For all other caches, this returns the</span><br><span class="line">     * maximum sum of the sizes of the entries in this cache.</span><br><span class="line">     */</span><br><span class="line">    public synchronized final int maxSize() &#123;</span><br><span class="line">        return maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the number of times &#123;@link #get&#125; returned a value that was</span><br><span class="line">     * already present in the cache.</span><br><span class="line">     * 已缓存的value的数目</span><br><span class="line">     */</span><br><span class="line">    public synchronized final int hitCount() &#123;</span><br><span class="line">        return hitCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the number of times &#123;@link #get&#125; returned null or required a new</span><br><span class="line">     * value to be created.</span><br><span class="line">     */</span><br><span class="line">    public synchronized final int missCount() &#123;</span><br><span class="line">        return missCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the number of times &#123;@link #create(Object)&#125; returned a value.</span><br><span class="line">     */</span><br><span class="line">    public synchronized final int createCount() &#123;</span><br><span class="line">        return createCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the number of times &#123;@link #put&#125; was called.</span><br><span class="line">     */</span><br><span class="line">    public synchronized final int putCount() &#123;</span><br><span class="line">        return putCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the number of values that have been evicted.</span><br><span class="line">     */</span><br><span class="line">    public synchronized final int evictionCount() &#123;</span><br><span class="line">        return evictionCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns a copy of the current contents of the cache, ordered from least</span><br><span class="line">     * recently accessed to most recently accessed.</span><br><span class="line">     */</span><br><span class="line">    public synchronized final Map&lt;K, V&gt; snapshot() &#123;</span><br><span class="line">        return new LinkedHashMap&lt;K, V&gt;(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public synchronized final String toString() &#123;</span><br><span class="line">        int accesses = hitCount + missCount;</span><br><span class="line">        int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0;</span><br><span class="line">        return String.format(Locale.US, &quot;LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]&quot;,</span><br><span class="line">                maxSize, hitCount, missCount, hitPercent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><blockquote>
<p>LRUCache使用LinkedHashMap来存储缓存，LinkedHashMap内部有排序功能，当其构造方法第三个参数为true时，数据在被访问的时候就会排序，该排序的结果就是把最近访问的数据放在放在集合的最后面。所以要缓存不够是就会从前面开始删除。</p>
</blockquote>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Constructs an empty &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with the</span><br><span class="line">     * specified initial capacity, load factor and ordering mode.</span><br><span class="line">     *</span><br><span class="line">     * @param  initialCapacity the initial capacity</span><br><span class="line">     * @param  loadFactor      the load factor</span><br><span class="line">     * @param  accessOrder     the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for</span><br><span class="line">     *         access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order</span><br><span class="line">     * @throws IllegalArgumentException if the initial capacity is negative</span><br><span class="line">     *         or the load factor is nonpositive</span><br><span class="line">     */</span><br><span class="line">    public LinkedHashMap(int initialCapacity,</span><br><span class="line">                         float loadFactor,</span><br><span class="line">                         boolean accessOrder) &#123;</span><br><span class="line">        super(initialCapacity, loadFactor);</span><br><span class="line">        this.accessOrder = accessOrder;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Entity的定义"><a href="#Entity的定义" class="headerlink" title="Entity的定义"></a>Entity的定义</h3><p>LinkedHashMap内部是使用双向循环链表来存储数据，也就是每一个元素都持有他上一个元素的地址和下一个元素的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * LinkedHashMap entry.</span><br><span class="line">    */</span><br><span class="line">   private static class LinkedHashMapEntry&lt;K,V&gt; extends HashMapEntry&lt;K,V&gt; &#123;</span><br><span class="line">       // These fields comprise the doubly linked list used for iteration.</span><br><span class="line">       LinkedHashMapEntry&lt;K,V&gt; before, after;</span><br><span class="line"></span><br><span class="line">       LinkedHashMapEntry(int hash, K key, V value, HashMapEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">           super(hash, key, value, next);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * 从链表中删除这个元素</span><br><span class="line">        */</span><br><span class="line">       private void remove() &#123;</span><br><span class="line">           before.after = after;</span><br><span class="line">           after.before = before;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Inserts this entry before the specified existing entry in the list.</span><br><span class="line">        */</span><br><span class="line">       private void addBefore(LinkedHashMapEntry&lt;K,V&gt; existingEntry) &#123;</span><br><span class="line">           after  = existingEntry;</span><br><span class="line">           before = existingEntry.before;</span><br><span class="line">           before.after = this;</span><br><span class="line">           after.before = this;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * 当集合的get方法被调用时，会调用这个方法。</span><br><span class="line">        * 如果accessOrder为true，就把这个元素放在集合的最末端。</span><br><span class="line">        */</span><br><span class="line">       void recordAccess(HashMap&lt;K,V&gt; m) &#123;</span><br><span class="line">           LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</span><br><span class="line">           if (lm.accessOrder) &#123;</span><br><span class="line">               lm.modCount++;</span><br><span class="line">               remove();</span><br><span class="line">               addBefore(lm.header);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       void recordRemoval(HashMap&lt;K,V&gt; m) &#123;</span><br><span class="line">           remove();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="get方法排序过程"><a href="#get方法排序过程" class="headerlink" title="get方法排序过程"></a>get方法排序过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">        LinkedHashMapEntry&lt;K,V&gt; e = (LinkedHashMapEntry&lt;K,V&gt;)getEntry(key);</span><br><span class="line">        if (e == null)</span><br><span class="line">            return null;</span><br><span class="line">        e.recordAccess(this);</span><br><span class="line">        return e.value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ouv36g1sw.bkt.clouddn.com/LinkedHashMap%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8" alt="LinkedHashMap双向循环链表"></p>
<ul>
<li>每一个元素都持有他上一个元素的地址和下一个元素的地址，对于最后一个元素它会和header相互持有也就是header会持有最后一个元素地址作为before，而最后一个元素会持有header地址作为after。</li>
</ul>
<h3 id="recordAccess（this）方法，this就是这个LinkedHashMap"><a href="#recordAccess（this）方法，this就是这个LinkedHashMap" class="headerlink" title="recordAccess（this）方法，this就是这个LinkedHashMap"></a>recordAccess（this）方法，this就是这个LinkedHashMap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void recordAccess(HashMap&lt;K,V&gt; m) &#123;</span><br><span class="line">            LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</span><br><span class="line">            if (lm.accessOrder) &#123;</span><br><span class="line">                lm.modCount++;</span><br><span class="line">                remove();</span><br><span class="line">                addBefore(lm.header);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 调用remove方法，把自己从链表中移除：</span><br><span class="line">        private void remove() &#123;</span><br><span class="line">            before.after = after;</span><br><span class="line">            after.before = before;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       // addBefore(lm.header)方法，把自己添加到链表的结尾</span><br><span class="line">        private void addBefore(LinkedHashMapEntry&lt;K,V&gt; existingEntry) &#123;</span><br><span class="line">            after  = existingEntry;</span><br><span class="line">            before = existingEntry.before;</span><br><span class="line">            before.after = this;</span><br><span class="line">            after.before = this;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ouv36g1sw.bkt.clouddn.com/LinkedHashMap%E7%9A%84remove%E8%BF%87%E7%A8%8B" alt="LinkedHashMap的remove过程"></p>
<h3 id="获取最该清楚的常用元素"><a href="#获取最该清楚的常用元素" class="headerlink" title="获取最该清楚的常用元素"></a>获取最该清楚的常用元素</h3><ul>
<li><p>eldest()方法，提供的就是最近最少使用的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Map.Entry&lt;K, V&gt; eldest() &#123;</span><br><span class="line">        Entry&lt;K, V&gt; eldest = header.after;</span><br><span class="line">        return eldest != header ? eldest : null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="LruCache和LinkedHashMap结合实现缓存"><a href="#LruCache和LinkedHashMap结合实现缓存" class="headerlink" title="LruCache和LinkedHashMap结合实现缓存"></a>LruCache和LinkedHashMap结合实现缓存</h2><ul>
<li><p>LinkedHashMap第三个参数为true时，每次访问LinkedHashMap的数据，LinkedHashMap都回去进行排序，将最近访问的放在链表的末尾。</p>
<ul>
<li>LruCache的put方法调用了LinkedHashMap的put来存储数据，自己进行了对缓存空间的计算。LinkedHashMap的put方法也会进行排序。</li>
<li>LruCache的get方法调用了LinkedHashMap的get来获取数据，由于LinkedHashMap构造方法的第三个参数为true,因此get也会触发LinkedHashMap的排序。</li>
</ul>
</li>
<li><p>trimToSize(int maxSize)</p>
<p>trimToSize(int maxSize)是LruCache的核心方法了，get和put都可能会执行这个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public void trimToSize(int maxSize) &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            K key;</span><br><span class="line">            V value;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123;</span><br><span class="line">                    throw new IllegalStateException(getClass().getName()</span><br><span class="line">                            + &quot;.sizeOf() is reporting inconsistent results!&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (size &lt;= maxSize) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Map.Entry&lt;K, V&gt; toEvict = map.eldest();</span><br><span class="line">                if (toEvict == null) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                key = toEvict.getKey();</span><br><span class="line">                value = toEvict.getValue();</span><br><span class="line">                map.remove(key);</span><br><span class="line">                size -= safeSizeOf(key, value);</span><br><span class="line">                evictionCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            entryRemoved(true, key, value, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="使用LruCache来缓存Bitmap"><a href="#使用LruCache来缓存Bitmap" class="headerlink" title="使用LruCache来缓存Bitmap"></a>使用LruCache来缓存Bitmap</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LruCache&lt;String, Bitmap&gt; mLruCache;</span><br><span class="line">        //获取手机最大内存 单位 kb</span><br><span class="line">        int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);</span><br><span class="line">        //一般都将1/8设为LruCache的最大缓存</span><br><span class="line">        int cacheSize = maxMemory / 8;</span><br><span class="line">        mLruCache = new LruCache&lt;String, Bitmap&gt;(maxMemory / 8) &#123;</span><br><span class="line"></span><br><span class="line">            /**</span><br><span class="line">             * 这个方法从源码中看出来是设置已用缓存的计算方式的。</span><br><span class="line">             * 默认返回的值是1，也就是没缓存一张图片就将已用缓存大小加1.</span><br><span class="line">             * 缓存图片看的是占用的内存的大小，每张图片的占用内存也是不一样的，一次不能这样算。</span><br><span class="line">             * 因此要重写这个方法，手动将这里改为本次缓存的图片的大小。</span><br><span class="line">             */</span><br><span class="line">            @Override</span><br><span class="line">            protected int sizeOf(String key, Bitmap value) &#123;</span><br><span class="line">                return value.getByteCount() / 1024;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //加入缓存</span><br><span class="line">        mLruCache.put(&quot;key&quot;, BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher));</span><br><span class="line">        //从缓存中读取</span><br><span class="line">        Bitmap bitmap = mLruCache.get(&quot;key&quot;);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">作茧自缚</p>
              <p class="site-description motion-element" itemprop="description">格物致知</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">作茧自缚</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>
  <a href="https://github.com/xuqinzz"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://zhizhi.disqus.com/count.js" async></script>
    

    

  




	





  














  





  

  

  

  
  

  

  

  

  
<script type="text/javascript">
    //微信二维码点击背景关闭
    $('body').delegate('.-mob-share-weixin-qrcode-bg','click', function(){
         $(".-mob-share-weixin-qrcode-close").trigger("click");
    }); 
</script>

</body>
</html>
