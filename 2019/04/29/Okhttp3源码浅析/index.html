<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="c5yB2B-3tswoQK7D0ZfZDqbSGvVzLxh-kwnbxyeTdaU" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="源码分析," />










<meta name="description" content="Okhttp简介 Okhttp是一个http客户端，默认提供一下支持：  HTTP / 2支持允许同一主机的所有请求共享socket。 在HTTP / 2不可用的情况下，Okhttp的连接池将会减少请求延迟。  通过GZIP压缩减少数据大小。 通过响应缓存完全避免重复的网络请求。   Okhttp的使用12345678910111213141516171819202122232425262728/">
<meta name="keywords" content="源码分析">
<meta property="og:type" content="article">
<meta property="og:title" content="Okhttp3源码浅析">
<meta property="og:url" content="http://yoursite.com/2019/04/29/Okhttp3源码浅析/index.html">
<meta property="og:site_name" content="跬步">
<meta property="og:description" content="Okhttp简介 Okhttp是一个http客户端，默认提供一下支持：  HTTP / 2支持允许同一主机的所有请求共享socket。 在HTTP / 2不可用的情况下，Okhttp的连接池将会减少请求延迟。  通过GZIP压缩减少数据大小。 通过响应缓存完全避免重复的网络请求。   Okhttp的使用12345678910111213141516171819202122232425262728/">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-05-29T15:38:09.550Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Okhttp3源码浅析">
<meta name="twitter:description" content="Okhttp简介 Okhttp是一个http客户端，默认提供一下支持：  HTTP / 2支持允许同一主机的所有请求共享socket。 在HTTP / 2不可用的情况下，Okhttp的连接池将会减少请求延迟。  通过GZIP压缩减少数据大小。 通过响应缓存完全避免重复的网络请求。   Okhttp的使用12345678910111213141516171819202122232425262728/">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/04/29/Okhttp3源码浅析/"/>




<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #ffffff; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #ffffff, 0 0 5px #ffffff; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #ffffff;    /*上边框颜色*/
        border-left-color: #ffffff;    /*左边框颜色*/
    }
</style>
  <title>Okhttp3源码浅析 | 跬步</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-113549877-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">跬步</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程表
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/29/Okhttp3源码浅析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="作茧自缚">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Okhttp3源码浅析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-29T21:41:59+08:00">
                2019-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/04/29/Okhttp3源码浅析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/04/29/Okhttp3源码浅析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  45
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Okhttp简介"><a href="#Okhttp简介" class="headerlink" title="Okhttp简介"></a>Okhttp简介</h1><blockquote>
<p>Okhttp是一个http客户端，默认提供一下支持：</p>
<ol>
<li>HTTP / 2支持允许同一主机的所有请求共享socket。</li>
<li>在HTTP / 2不可用的情况下，Okhttp的连接池将会减少请求延迟。 </li>
<li>通过GZIP压缩减少数据大小。</li>
<li>通过响应缓存完全避免重复的网络请求。</li>
</ol>
</blockquote>
<h1 id="Okhttp的使用"><a href="#Okhttp的使用" class="headerlink" title="Okhttp的使用"></a>Okhttp的使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 创建请求客户端 OkhttpClient</span><br><span class="line">OkHttpClient okHttpClient = new OkHttpClient.Builder().build();</span><br><span class="line">// 构建请求体</span><br><span class="line">Request request = new Request</span><br><span class="line">		.Builder()</span><br><span class="line">		.url(&quot;www.github.com&quot;)</span><br><span class="line">		.addHeader(&quot;token&quot;, &quot;70DA53F9B9D8A3D6345F1A7C4BC1A4A8&quot;)</span><br><span class="line">		.build();</span><br><span class="line">// 生成一个call对象 由RealCall实现Call接口的方法</span><br><span class="line">Call call = okHttpClient.newCall(request);</span><br><span class="line">try &#123;</span><br><span class="line">	// 同步请求</span><br><span class="line">	Response response = call.execute();</span><br><span class="line">	// 异步请求</span><br><span class="line">	call.enqueue(new Callback() &#123;</span><br><span class="line">		@Override</span><br><span class="line">		public void onFailure(Call call, IOException e) &#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void onResponse(Call call, Response response) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="OkhttpClient的创建"><a href="#OkhttpClient的创建" class="headerlink" title="OkhttpClient的创建"></a>OkhttpClient的创建</h1><p><code>OkHttpClient okHttpClient = new OkHttpClient.Builder().build();</code></p>
<ul>
<li><p>OkhttpClient中使用建造者设计模式进行初始化，Builder()初始化代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public Builder() &#123;</span><br><span class="line">	dispatcher = new Dispatcher();</span><br><span class="line">	protocols = DEFAULT_PROTOCOLS;</span><br><span class="line">	connectionSpecs = DEFAULT_CONNECTION_SPECS;</span><br><span class="line">	eventListenerFactory = EventListener.factory(EventListener.NONE);</span><br><span class="line">	proxySelector = ProxySelector.getDefault();</span><br><span class="line">	if (proxySelector == null) &#123;</span><br><span class="line">		// 如果不存在系统代理，新建一个类型为直接连接的代理</span><br><span class="line">		proxySelector = new NullProxySelector();</span><br><span class="line">	&#125;</span><br><span class="line">	cookieJar = CookieJar.NO_COOKIES;</span><br><span class="line">	socketFactory = SocketFactory.getDefault();</span><br><span class="line">	hostnameVerifier = OkHostnameVerifier.INSTANCE;</span><br><span class="line">	certificatePinner = CertificatePinner.DEFAULT;</span><br><span class="line">	proxyAuthenticator = Authenticator.NONE;</span><br><span class="line">	authenticator = Authenticator.NONE;</span><br><span class="line">	connectionPool = new ConnectionPool();</span><br><span class="line">	dns = Dns.SYSTEM;</span><br><span class="line">	followSslRedirects = true;</span><br><span class="line">	followRedirects = true;</span><br><span class="line">	retryOnConnectionFailure = true;</span><br><span class="line">	callTimeout = 0;</span><br><span class="line">	connectTimeout = 10_000;</span><br><span class="line">	readTimeout = 10_000;</span><br><span class="line">	writeTimeout = 10_000;</span><br><span class="line">	pingInterval = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>OkhttpClient初始化的值：</p>
<ol>
<li><p><code>Dispatcher dispatcher</code>：调度器，⽤于调度线程从后台发起的⽹络请求，有后台总请求数和单主机总请求数的限制。</p>
</li>
<li><p><code>List&lt;Protocol&gt; protocols</code>：⽀持的应⽤层协议，即 HTTP/1.1、HTTP/2 等。</p>
</li>
<li><p><code>List connectionSpecs</code>：：应⽤层⽀持的 Socket 设置，即使⽤明⽂传输（⽤于 HTTP）还是某个版本的 TLS（⽤于 HTTPS）。</p>
</li>
<li><p><code>EventListener.Factory eventListenerFactory</code>：事件监听工厂，所有的开始、连接、取得结果事件都会有一个相匹配的结束或释放事件。</p>
</li>
<li><p><code>ProxySelector proxySelector</code>：代理服务器，获取系统的代理，如果不存在系统代理，新建一个类型为直接连接的代理。</p>
</li>
<li><p><code>CookieJar cookieJar</code>：管理 Cookie 的控制器。OkHttp 提供了 Cookie 存取的判断⽀持（即何时存何时取，但没有给出如何存取。所以需自己实现存取Cookie，如⽤ Map 存在内存⾥，或者存在本地存储或者数据库中。</p>
</li>
<li><p><code>SocketFactory socketFactory</code>：socket工厂。</p>
</li>
<li><p><code>HostnameVerifier hostnameVerifier</code>：于验证 HTTPS 握⼿过程中下载到的证书所属者是否和⾃⼰要访问的主机域名是否⼀致。</p>
</li>
<li><p><code>CertificatePinner certificatePinner</code>：⽤于设置 HTTPS 握⼿过程中针对某个Host 的 Certificate Public Key Pinner，即把⽹站证书链中的每⼀个证书公钥直接拿来提前配置进 OkHttpClient ⾥去，以跳过本地根证书，直接从代码⾥进⾏认证。这种⽤法⽐较少⻅，⼀般⽤于防⽌⽹站证书被⼈仿制（ As 中对<code>CertificatePinner</code> 使用 ctrl + Q 可以直接查看文档），具体使用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String hostname = &quot;publicobject.com&quot;;</span><br><span class="line">CertificatePinner certificatePinner = new CertificatePinner.Builder()</span><br><span class="line">	.add(hostname, &quot;sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;)</span><br><span class="line">	.build();</span><br><span class="line">OkHttpClient client = OkHttpClient.Builder()</span><br><span class="line">	.certificatePinner(certificatePinner)</span><br><span class="line">	.build();</span><br><span class="line"></span><br><span class="line">Request request = new Request.Builder()</span><br><span class="line">	.url(&quot;https://&quot; + hostname)</span><br><span class="line">	.build();</span><br><span class="line">client.newCall(request).execute();</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<ol start="10">
<li><p><code>Authenticator proxyAuthenticator</code>：连接代理服务器之前需要进行身份验证或者从原始Web服务器或代理服务器接收质询后执行响应式身份验证，默认为不进行身份验证。</p>
</li>
<li><p><code>Authenticator authenticator</code>：连接代理服务器之前需要进行身份验证或者从原始Web服务器或代理服务器接收质询后执行响应式身份验证，默认为不进行身份验证。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient okHttpClient = new OkHttpClient.Builder()</span><br><span class="line">	.authenticator(new Authenticator() &#123;</span><br><span class="line">		@Override</span><br><span class="line">		public Request authenticate(Route route, Response response) throws IOException &#123;</span><br><span class="line">			// 调用获取Token接口获取token</span><br><span class="line">			return response.request().newBuilder()</span><br><span class="line">    				.addHeader(&quot;Authorization&quot;,&quot;Bearer token&quot;)</span><br><span class="line">                     .build();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;).build();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="12">
<li><p><code>ConnectionPool connectionPool</code>：连接池，重复使用HTTP和HTTP / 2连接以减少网络延迟，访问同一个地址的HTTP请求可以共享同一个连接。</p>
</li>
<li><p><code>Dns dns</code>：解析主机名IP地址的域名，默认使用系统的DNS服务，应用程序也可提供自己的实现来使用不同的DNS服务器，选择IPv6地址、IPv4地址或强制使用特定的已知IP地址。</p>
</li>
<li><p><code>boolean followSslRedirects</code>：在重定向时，如果原先请求的是 http ⽽重定向的⽬标是 https，或者原先请求的是 https ⽽重定向的⽬标是 http，是否依然⾃动 follow。（不是「是否⾃动 follow HTTPS URL 重定向的意思，⽽是是否⾃动 follow 在 HTTP 和HTTPS 之间切换的重定向）默认为 true ；</p>
</li>
<li><p><code>boolean followRedirects</code> ：遇到重定向的要求是，是否⾃动 follow，默认为 true 。</p>
</li>
<li><p><code>boolean retryOnConnectionFailure</code>：在请求失败的时候是否⾃动重试。注意，⼤多数的请求失败并不属于 OkHttp 所定义的「需要重试」，这种重试只适⽤于「同⼀个域名的多个 IP 切换重试」「Socket 失效重试」等情况，默认为 true 。</p>
</li>
<li><p><code>int callTimeout</code>：发起请求的超时时间，默认为10_000。</p>
</li>
<li><p><code>int connectTimeout</code>：建⽴连接（TCP 或 TLS）的超时时间，默认为10_000。</p>
</li>
<li><p><code>int readTimeout</code>：发起请求到读到响应数据的超时时间，默认为10_000。</p>
</li>
<li><p><code>int writeTimeout</code>：发起请求并被⽬标服务器接受的超时时间（因为有时候目标服务器可能由于某种原因⽽不读取你的 Request），默认为10_000；</p>
</li>
<li><p><code>int pingInterval</code>：维持心跳ping间隔时间。</p>
</li>
<li><p><code>List&lt;Interceptor&gt; interceptors</code>：拦截器配置。</p>
</li>
<li><p><code>List networkInterceptors</code>：直接和⽹络请求交互的 Interceptor 配置到这⾥，如果查看返回的 301 报⽂或者未解压的 Response Body，需要在这⾥配置。</p>
</li>
<li><p><code>Cache cache</code>：Cache 存储的配置。默认是没有，如果需要⽤，得⾃⼰配置出 Cache 存储的⽂件位置以及存储空间上限。</p>
</li>
</ol>
<h1 id="请求体Request的创建"><a href="#请求体Request的创建" class="headerlink" title="请求体Request的创建"></a>请求体Request的创建</h1><ul>
<li>request中包含了请求的相关信息url、method、headers、body、tags等。</li>
<li>request的默认 method 是 GET</li>
</ul>
<h1 id="创建Call对象"><a href="#创建Call对象" class="headerlink" title="创建Call对象"></a>创建Call对象</h1><ul>
<li><p>RealCall是Call接口的实现类所以，<strong>实际上创建的对象是 Call 的实现类 RealCall 对象</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123;</span><br><span class="line">	// Safely publish the Call instance to the EventListener.</span><br><span class="line">    RealCall call = new RealCall(client, originalRequest, forWebSocket);</span><br><span class="line">    call.transmitter = new Transmitter(client, call);</span><br><span class="line">	return call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Transmitter</code>：OkHttp 的应用程序和网络层之间的桥梁，将应用层的函数发射到网络层，提供了应用层的原函数连接、请求、响应和流。</p>
<ol>
<li>设置连接池，最终调用的还是OkHttpClient中通过Builder设置的连接池对象，如果没有自定义连接池泽会使用默认的连接池。</li>
</ol>
</li>
</ul>
<ol start="2">
<li><p>设置Call对象。</p>
<ol start="3">
<li>设置相关指标的监听器，可以通过扩展这个类来监听程序的HTTP的调用数量、大小和持续时间。设置的监听器最终还是调用的OkHttpClient中通过Builder设置的监听对象。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Transmitter(OkHttpClient client, Call call) &#123;</span><br><span class="line">      this.client = client;</span><br><span class="line">      this.connectionPool = Internal.instance.realConnectionPool(client.connectionPool());</span><br><span class="line">      this.call = call;</span><br><span class="line">      this.eventListener = client.eventListenerFactory().create(call);</span><br><span class="line">      this.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Transmitter"><a href="#Transmitter" class="headerlink" title="Transmitter"></a>Transmitter</h1><blockquote>
<p>Transmitter：连接OKHTTP的应用程序和网络层。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br></pre></td><td class="code"><pre><span class="line">public final class Transmitter &#123;</span><br><span class="line">    private final OkHttpClient client;</span><br><span class="line">    private final RealConnectionPool connectionPool;</span><br><span class="line">    private final Call call;</span><br><span class="line">    private final EventListener eventListener;</span><br><span class="line">    private final AsyncTimeout timeout = new AsyncTimeout() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected void timedOut() &#123;</span><br><span class="line">            cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    private @Nullable</span><br><span class="line">    Object callStackTrace;</span><br><span class="line"></span><br><span class="line">    private Request request;</span><br><span class="line">    private ExchangeFinder exchangeFinder;</span><br><span class="line"></span><br><span class="line">    // Guarded by connectionPool.</span><br><span class="line">    public RealConnection connection;</span><br><span class="line">    private @Nullable</span><br><span class="line">    Exchange exchange;</span><br><span class="line">    private boolean exchangeRequestDone;</span><br><span class="line">    private boolean exchangeResponseDone;</span><br><span class="line">    private boolean canceled;</span><br><span class="line">    private boolean timeoutEarlyExit;</span><br><span class="line">    private boolean noMoreExchanges;</span><br><span class="line"></span><br><span class="line">    public Transmitter(OkHttpClient client, Call call) &#123;</span><br><span class="line">        this.client = client;</span><br><span class="line">        this.connectionPool = Internal.instance.realConnectionPool(client.connectionPool());</span><br><span class="line">        this.call = call;</span><br><span class="line">        this.eventListener = client.eventListenerFactory().create(call);</span><br><span class="line">        this.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Timeout timeout() &#123;</span><br><span class="line">        return timeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void timeoutEnter() &#123;</span><br><span class="line">        timeout.enter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Stops applying the timeout before the call is entirely complete. This is used for WebSockets</span><br><span class="line">     * and duplex calls where the timeout only applies to the initial setup.</span><br><span class="line">     */</span><br><span class="line">    public void timeoutEarlyExit() &#123;</span><br><span class="line">        if (timeoutEarlyExit) throw new IllegalStateException();</span><br><span class="line">        timeoutEarlyExit = true;</span><br><span class="line">        timeout.exit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private @Nullable</span><br><span class="line">    IOException timeoutExit(@Nullable IOException cause) &#123;</span><br><span class="line">        if (timeoutEarlyExit) return cause;</span><br><span class="line">        if (!timeout.exit()) return cause;</span><br><span class="line"></span><br><span class="line">        InterruptedIOException e = new InterruptedIOException(&quot;timeout&quot;);</span><br><span class="line">        if (cause != null) e.initCause(cause);</span><br><span class="line"></span><br><span class="line">        return e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void callStart() &#123;</span><br><span class="line">        this.callStackTrace = Platform.get().getStackTraceForCloseable(&quot;response.body().close()&quot;);</span><br><span class="line">        eventListener.callStart(call);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Prepare to create a stream to carry &#123;@code request&#125;. This prefers to use the existing</span><br><span class="line">     * connection if it exists.</span><br><span class="line">     */</span><br><span class="line">    public void prepareToConnect(Request request) &#123;</span><br><span class="line">        if (this.request != null) &#123;</span><br><span class="line">            if (sameConnection(this.request.url(), request.url()) &amp;&amp; exchangeFinder.hasRouteToTry()) &#123;</span><br><span class="line">                return; // Already ready.</span><br><span class="line">            &#125;</span><br><span class="line">            if (exchange != null) throw new IllegalStateException();</span><br><span class="line"></span><br><span class="line">            if (exchangeFinder != null) &#123;</span><br><span class="line">                maybeReleaseConnection(null, true);</span><br><span class="line">                exchangeFinder = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.request = request;</span><br><span class="line">        this.exchangeFinder = new ExchangeFinder(this, connectionPool, createAddress(request.url()),</span><br><span class="line">                call, eventListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Address createAddress(HttpUrl url) &#123;</span><br><span class="line">        SSLSocketFactory sslSocketFactory = null;</span><br><span class="line">        HostnameVerifier hostnameVerifier = null;</span><br><span class="line">        CertificatePinner certificatePinner = null;</span><br><span class="line">        if (url.isHttps()) &#123;</span><br><span class="line">            sslSocketFactory = client.sslSocketFactory();</span><br><span class="line">            hostnameVerifier = client.hostnameVerifier();</span><br><span class="line">            certificatePinner = client.certificatePinner();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new Address(url.host(), url.port(), client.dns(), client.socketFactory(),</span><br><span class="line">                sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(),</span><br><span class="line">                client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns a new exchange to carry a new request and response.</span><br><span class="line">     */</span><br><span class="line">    Exchange newExchange(Interceptor.Chain chain, boolean doExtensiveHealthChecks) &#123;</span><br><span class="line">        synchronized (connectionPool) &#123;</span><br><span class="line">            if (noMoreExchanges) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;released&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (exchange != null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;cannot make a new request because the previous response &quot;</span><br><span class="line">                        + &quot;is still open: please call response.close()&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ExchangeCodec codec = exchangeFinder.find(client, chain, doExtensiveHealthChecks);</span><br><span class="line">        Exchange result = new Exchange(this, call, eventListener, exchangeFinder, codec);</span><br><span class="line"></span><br><span class="line">        synchronized (connectionPool) &#123;</span><br><span class="line">            this.exchange = result;</span><br><span class="line">            this.exchangeRequestDone = false;</span><br><span class="line">            this.exchangeResponseDone = false;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void acquireConnectionNoEvents(RealConnection connection) &#123;</span><br><span class="line">        assert (Thread.holdsLock(connectionPool));</span><br><span class="line"></span><br><span class="line">        if (this.connection != null) throw new IllegalStateException();</span><br><span class="line">        this.connection = connection;</span><br><span class="line">        connection.transmitters.add(new okhttp3.internal.connection.Transmitter.TransmitterReference(this, callStackTrace));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Remove the transmitter from the connection&apos;s list of allocations. Returns a socket that the</span><br><span class="line">     * caller should close.</span><br><span class="line">     */</span><br><span class="line">    @Nullable</span><br><span class="line">    Socket releaseConnectionNoEvents() &#123;</span><br><span class="line">        assert (Thread.holdsLock(connectionPool));</span><br><span class="line"></span><br><span class="line">        int index = -1;</span><br><span class="line">        for (int i = 0, size = this.connection.transmitters.size(); i &lt; size; i++) &#123;</span><br><span class="line">            Reference&lt;okhttp3.internal.connection.Transmitter&gt; reference = this.connection.transmitters.get(i);</span><br><span class="line">            if (reference.get() == this) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (index == -1) throw new IllegalStateException();</span><br><span class="line"></span><br><span class="line">        RealConnection released = this.connection;</span><br><span class="line">        released.transmitters.remove(index);</span><br><span class="line">        this.connection = null;</span><br><span class="line"></span><br><span class="line">        if (released.transmitters.isEmpty()) &#123;</span><br><span class="line">            released.idleAtNanos = System.nanoTime();</span><br><span class="line">            if (connectionPool.connectionBecameIdle(released)) &#123;</span><br><span class="line">                return released.socket();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void exchangeDoneDueToException() &#123;</span><br><span class="line">        synchronized (connectionPool) &#123;</span><br><span class="line">            if (noMoreExchanges) throw new IllegalStateException();</span><br><span class="line">            exchange = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Releases resources held with the request or response of &#123;@code exchange&#125;. This should be called</span><br><span class="line">     * when the request completes normally or when it fails due to an exception, in which case &#123;@code</span><br><span class="line">     * e&#125; should be non-null.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;If the exchange was canceled or timed out, this will wrap &#123;@code e&#125; in an exception that</span><br><span class="line">     * provides that additional context. Otherwise &#123;@code e&#125; is returned as-is.</span><br><span class="line">     */</span><br><span class="line">    @Nullable</span><br><span class="line">    IOException exchangeMessageDone(</span><br><span class="line">            Exchange exchange, boolean requestDone, boolean responseDone, @Nullable IOException e) &#123;</span><br><span class="line">        boolean exchangeDone = false;</span><br><span class="line">        synchronized (connectionPool) &#123;</span><br><span class="line">            if (exchange != this.exchange) &#123;</span><br><span class="line">                return e; // This exchange was detached violently!</span><br><span class="line">            &#125;</span><br><span class="line">            boolean changed = false;</span><br><span class="line">            if (requestDone) &#123;</span><br><span class="line">                if (!exchangeRequestDone) changed = true;</span><br><span class="line">                this.exchangeRequestDone = true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (responseDone) &#123;</span><br><span class="line">                if (!exchangeResponseDone) changed = true;</span><br><span class="line">                this.exchangeResponseDone = true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (exchangeRequestDone &amp;&amp; exchangeResponseDone &amp;&amp; changed) &#123;</span><br><span class="line">                exchangeDone = true;</span><br><span class="line">                this.exchange.connection().successCount++;</span><br><span class="line">                this.exchange = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (exchangeDone) &#123;</span><br><span class="line">            e = maybeReleaseConnection(e, false);</span><br><span class="line">        &#125;</span><br><span class="line">        return e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public @Nullable</span><br><span class="line">    IOException noMoreExchanges(@Nullable IOException e) &#123;</span><br><span class="line">        synchronized (connectionPool) &#123;</span><br><span class="line">            noMoreExchanges = true;</span><br><span class="line">        &#125;</span><br><span class="line">        return maybeReleaseConnection(e, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Release the connection if it is no longer needed. This is called after each exchange completes</span><br><span class="line">     * and after the call signals that no more exchanges are expected.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;If the transmitter was canceled or timed out, this will wrap &#123;@code e&#125; in an exception that</span><br><span class="line">     * provides that additional context. Otherwise &#123;@code e&#125; is returned as-is.</span><br><span class="line">     *</span><br><span class="line">     * @param force true to release the connection even if more exchanges are expected for the call.</span><br><span class="line">     */</span><br><span class="line">    private @Nullable</span><br><span class="line">    IOException maybeReleaseConnection(@Nullable IOException e, boolean force) &#123;</span><br><span class="line">        Socket socket;</span><br><span class="line">        Connection releasedConnection;</span><br><span class="line">        boolean callEnd;</span><br><span class="line">        synchronized (connectionPool) &#123;</span><br><span class="line">            if (force &amp;&amp; exchange != null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;cannot release connection while it is in use&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            releasedConnection = this.connection;</span><br><span class="line">            socket = this.connection != null &amp;&amp; exchange == null &amp;&amp; (force || noMoreExchanges)</span><br><span class="line">                    ? releaseConnectionNoEvents()</span><br><span class="line">                    : null;</span><br><span class="line">            if (this.connection != null) releasedConnection = null;</span><br><span class="line">            callEnd = noMoreExchanges &amp;&amp; exchange == null;</span><br><span class="line">        &#125;</span><br><span class="line">        closeQuietly(socket);</span><br><span class="line"></span><br><span class="line">        if (releasedConnection != null) &#123;</span><br><span class="line">            eventListener.connectionReleased(call, releasedConnection);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (callEnd) &#123;</span><br><span class="line">            boolean callFailed = (e != null);</span><br><span class="line">            e = timeoutExit(e);</span><br><span class="line">            if (callFailed) &#123;</span><br><span class="line">                eventListener.callFailed(call, e);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                eventListener.callEnd(call);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean canRetry() &#123;</span><br><span class="line">        return exchangeFinder.hasStreamFailure() &amp;&amp; exchangeFinder.hasRouteToTry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean hasExchange() &#123;</span><br><span class="line">        synchronized (connectionPool) &#123;</span><br><span class="line">            return exchange != null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Immediately closes the socket connection if it&apos;s currently held. Use this to interrupt an</span><br><span class="line">     * in-flight request from any thread. It&apos;s the caller&apos;s responsibility to close the request body</span><br><span class="line">     * and response body streams; otherwise resources may be leaked.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This method is safe to be called concurrently, but provides limited guarantees. If a</span><br><span class="line">     * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.</span><br><span class="line">     * Otherwise if a socket connection is being established, that is terminated.</span><br><span class="line">     */</span><br><span class="line">    public void cancel() &#123;</span><br><span class="line">        Exchange exchangeToCancel;</span><br><span class="line">        RealConnection connectionToCancel;</span><br><span class="line">        synchronized (connectionPool) &#123;</span><br><span class="line">            canceled = true;</span><br><span class="line">            exchangeToCancel = exchange;</span><br><span class="line">            connectionToCancel = exchangeFinder != null &amp;&amp; exchangeFinder.connectingConnection() != null</span><br><span class="line">                    ? exchangeFinder.connectingConnection()</span><br><span class="line">                    : connection;</span><br><span class="line">        &#125;</span><br><span class="line">        if (exchangeToCancel != null) &#123;</span><br><span class="line">            exchangeToCancel.cancel();</span><br><span class="line">        &#125; else if (connectionToCancel != null) &#123;</span><br><span class="line">            connectionToCancel.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isCanceled() &#123;</span><br><span class="line">        synchronized (connectionPool) &#123;</span><br><span class="line">            return canceled;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static final class TransmitterReference extends WeakReference&lt;okhttp3.internal.connection.Transmitter&gt; &#123;</span><br><span class="line">        /**</span><br><span class="line">         * Captures the stack trace at the time the Call is executed or enqueued. This is helpful for</span><br><span class="line">         * identifying the origin of connection leaks.</span><br><span class="line">         */</span><br><span class="line">        final Object callStackTrace;</span><br><span class="line"></span><br><span class="line">        TransmitterReference(okhttp3.internal.connection.Transmitter referent, Object callStackTrace) &#123;</span><br><span class="line">            super(referent);</span><br><span class="line">            this.callStackTrace = callStackTrace;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h1><h1 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h1><blockquote>
<p>Dispatcher 调度器中维持了一个线程池，在异步请求时，之所以okHttp高效的原因，这里的线程池起到了一个很重要的原因。    </p>
</blockquote>
<ul>
<li><p><strong>readyAsyncCalls</strong> ：异步请求的就绪队列。</p>
</li>
<li><p><strong>runningAsyncCalls</strong> ：异步请求的执行队列。</p>
</li>
<li><p><strong>runningSyncCalls</strong>  ：同步请求的执行队列。</p>
</li>
<li><p><code>executorService()</code>: 创建线程池，在异步请求的时候，如果异步请求结束，所有线程都空闲超过60秒后，会回收该线程池中的所有空闲线程，构造方法传入的参数分别为：</p>
<ul>
<li>核心线程个数，这里设置的是0，也就是说在真正执行的时候才会去创建线程。</li>
<li>允许的最大线程数量，这里设置的是Integer.MAX_VALUE，但是请求数量是受到了maxRequests限制的。</li>
<li>空闲线程存活的时间，60秒。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public synchronized ExecutorService executorService() &#123;</span><br><span class="line">    if (executorService == null) &#123;</span><br><span class="line">		executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,</span><br><span class="line">			new SynchronousQueue&lt;&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));</span><br><span class="line">    &#125;</span><br><span class="line">	return executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override </span><br><span class="line">public Response execute() throws IOException &#123;</span><br><span class="line">	synchronized (this) &#123;</span><br><span class="line">		if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">		executed = true;</span><br><span class="line">	&#125;</span><br><span class="line">	transmitter.timeoutEnter();</span><br><span class="line">	transmitter.callStart();</span><br><span class="line">	try &#123;</span><br><span class="line">		client.dispatcher().executed(this);</span><br><span class="line">		return getResponseWithInterceptorChain();</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		client.dispatcher().finished(this);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>同步代码块中判断该请求是否已经执行，如果执行了则抛出异常，如果未执行则将excuted置为true。</p>
</li>
<li><p>超时输入定时器，最终调用的是 AsyncTimeout 类中的e nter() 方法。</p>
</li>
<li><p>transmitter.callStart()  开始请求的监听，getStackTraceForCloseable() ，应该是追踪捕捉堆栈信息，调用EventListener的callStart()方法（如果没有自定义 EventListener ，那么callStart()是一个空方法）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void callStart() &#123;</span><br><span class="line">    this.callStackTrace = Platform.get().getStackTraceForCloseable(&quot;response.body().close()&quot;);</span><br><span class="line">    eventListener.callStart(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将请求call添加到调度器中的同步请求的执行队列中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized void executed(RealCall call) &#123;</span><br><span class="line">	runningSyncCalls.add(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>getResponseWithInterceptorChain()</code>：<strong>通过拦截器链获取响应并返回</strong>。</p>
</li>
<li><p>不管请求是否成功都会执行 Dispatcher 的 finished(RealCall call) 方法，首先在同步代码快中判断同步请求的执行队列是否已经移除当前请求，在同步请求已经结束后从同步请求执行队列中移除该请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void finished(RealCall call) &#123;</span><br><span class="line">	finished(runningSyncCalls, call);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call) &#123;</span><br><span class="line">	Runnable idleCallback;</span><br><span class="line">	synchronized (this) &#123;</span><br><span class="line">		if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&apos;t in-flight!&quot;);</span><br><span class="line">		idleCallback = this.idleCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	boolean isRunning = promoteAndExecute();</span><br><span class="line"></span><br><span class="line">    if (!isRunning &amp;&amp; idleCallback != null) &#123;</span><br><span class="line">		idleCallback.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p><code>promoteAndExecute()</code>将 readyAsyncCalls ( 异步请求的就绪队列 ) 中符合条件的请求提升为 runningAsyncCalls ( 异步请求的执行队列 ) 并在执行程序服务上运行它们。该方法中迭代了异步请求就绪队列，在同步请求中并未向该队列添加请求所以不会执行。因此 executableCalls 也为空第二个迭代也不会执行 isRunning 在同步请求中默认为 false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private boolean promoteAndExecute() &#123;</span><br><span class="line">	assert (!Thread.holdsLock(this));</span><br><span class="line">    List&lt;AsyncCall&gt; executableCalls = new ArrayList&lt;&gt;();</span><br><span class="line">    boolean isRunning;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">		for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">			AsyncCall asyncCall = i.next();</span><br><span class="line">			 // Max capacity</span><br><span class="line">			if (runningAsyncCalls.size() &gt;= maxRequests) break;</span><br><span class="line">			// Host max capacity.</span><br><span class="line">			if (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) continue; </span><br><span class="line"></span><br><span class="line">			i.remove();</span><br><span class="line">			asyncCall.callsPerHost().incrementAndGet();</span><br><span class="line">			executableCalls.add(asyncCall);</span><br><span class="line">			runningAsyncCalls.add(asyncCall);</span><br><span class="line">		&#125;</span><br><span class="line">		isRunning = runningCallsCount() &gt; 0;</span><br><span class="line">	&#125;</span><br><span class="line">    for (int i = 0, size = executableCalls.size(); i &lt; size; i++) &#123;</span><br><span class="line">		AsyncCall asyncCall = executableCalls.get(i);</span><br><span class="line">		asyncCall.executeOn(executorService());</span><br><span class="line">    &#125;</span><br><span class="line">	return isRunning;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override </span><br><span class="line">public void enqueue(Callback responseCallback) &#123;</span><br><span class="line">	synchronized (this) &#123;</span><br><span class="line">		if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">		executed = true;</span><br><span class="line">	&#125;</span><br><span class="line">	transmitter.callStart();</span><br><span class="line">	client.dispatcher().enqueue(new AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>同步代码块，判断请求是否还在执行，如果正在执行则抛出异常。</p>
</li>
<li><p>transmitter.callStart()  开始请求的监听，getStackTraceForCloseable() ，应该是追踪捕捉堆栈信息，调用EventListener的callStart()方法（如果没有自定义 EventListener ，那么callStart()是一个空方法）；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void callStart() &#123;</span><br><span class="line">    this.callStackTrace = Platform.get().getStackTraceForCloseable(&quot;response.body().close()&quot;);</span><br><span class="line">    eventListener.callStart(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调度器的异步方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void enqueue(AsyncCall call) &#123;</span><br><span class="line">	synchronized (this) &#123;</span><br><span class="line">		readyAsyncCalls.add(call);</span><br><span class="line">		// 使同一域名请求的 AsyncCall 共享原子操作</span><br><span class="line">		if (!call.get().forAsyncCallWebSocket) &#123;</span><br><span class="line">        	AsyncCall existingCall = findExistingCallWithHost(call.host());</span><br><span class="line">        	if (existingCall != null) call.reuseCallsPerHostFrom(existingCall);</span><br><span class="line">      	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	promoteAndExecute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>promoteAndExecute()</code>将 readyAsyncCalls ( 异步请求的就绪队列 ) 中符合条件的请求提升为 runningAsyncCalls ( 异步请求的执行队列 ) 并在执行程序服务上运行它们。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private boolean promoteAndExecute() &#123;</span><br><span class="line">	assert (!Thread.holdsLock(this));</span><br><span class="line">    List&lt;AsyncCall&gt; executableCalls = new ArrayList&lt;&gt;();</span><br><span class="line">    boolean isRunning;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">		for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">			AsyncCall asyncCall = i.next();</span><br><span class="line">			 // Max capacity</span><br><span class="line">			if (runningAsyncCalls.size() &gt;= maxRequests) break;</span><br><span class="line">			// Host max capacity.</span><br><span class="line">			if (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) continue; </span><br><span class="line">			</span><br><span class="line">			i.remove();</span><br><span class="line">			asyncCall.callsPerHost().incrementAndGet();</span><br><span class="line">			executableCalls.add(asyncCall);</span><br><span class="line">			runningAsyncCalls.add(asyncCall);</span><br><span class="line">		&#125;</span><br><span class="line">		isRunning = runningCallsCount() &gt; 0;</span><br><span class="line">	&#125;</span><br><span class="line">    for (int i = 0, size = executableCalls.size(); i &lt; size; i++) &#123;</span><br><span class="line">		AsyncCall asyncCall = executableCalls.get(i);</span><br><span class="line">		asyncCall.executeOn(executorService());</span><br><span class="line">    &#125;</span><br><span class="line">	return isRunning;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建集合 <strong>executableCalls</strong> 添加并存储可执行的 Call 。</li>
<li>遍历准备好的异步请求队列 <strong>readyAsyncCalls</strong> 。<ul>
<li>检验正在运行的异步请求队列 runningAsyncCalls 的大小数量，是否超过了最大请求数 <strong>maxRequests</strong>  默认为64，如果超过了最大的请求个数，直接跳出循环，结束对readyAsyncCalls的遍历。</li>
<li>在遍历的时候会校验异步请求每个主机的请求数是否超过主机最大请求数 <strong>maxRequestsPerHost</strong> 默认为5，若超过，则跳过这次循环，直接进入下一次循环。</li>
</ul>
</li>
<li>将当前 host 的请求数目加1。</li>
<li>将遍历到的 AsyncCall 添加到可执行队列 executableCalls 和异步请求的执行队列 <strong>runningAsyncCalls</strong> 中，并在 异步请求就绪队列 <strong>readyAsyncCalls</strong> 中移除此请求。</li>
<li>依次调用可执行队列 executableCalls 中 AsyncCall 的异步方法，并传入线程池。</li>
</ul>
<h2 id="AsyncCall类"><a href="#AsyncCall类" class="headerlink" title="AsyncCall类"></a>AsyncCall类</h2><ul>
<li><p>AsyncCal l类是 RealCall 的一个内部类。</p>
</li>
<li><p>RealCall 异步请求的会调用到该类的 executeOn(）方法，执行相关异步请求操作，该方法中线程池对象 <code>executorService</code> 调用 execute () 方法并传入了 AsyncCall 对象并调用 AsyncCall 的 execute() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void executeOn(ExecutorService executorService) &#123;</span><br><span class="line">	assert (!Thread.holdsLock(client.dispatcher()));</span><br><span class="line">	boolean success = false;</span><br><span class="line">	try &#123;</span><br><span class="line">		executorService.execute(this);</span><br><span class="line">		success = true;</span><br><span class="line">	&#125; catch (RejectedExecutionException e) &#123;</span><br><span class="line">		InterruptedIOException ioException = new InterruptedIOException(&quot;executor rejected&quot;);</span><br><span class="line">		ioException.initCause(e);</span><br><span class="line">		transmitter.noMoreExchanges(ioException);</span><br><span class="line">		responseCallback.onFailure(RealCall.this, ioException);</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		if (!success) &#123;</span><br><span class="line">			// This call is no longer running!</span><br><span class="line">			client.dispatcher().finished(this); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AsyncCal  父类 NamedRunnable 只做了一件事就是执行execute() 方法，execute() 方法具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override </span><br><span class="line">protected void execute() &#123;</span><br><span class="line">	boolean signalledCallback = false;</span><br><span class="line">	transmitter.timeoutEnter();</span><br><span class="line">	try &#123;</span><br><span class="line">		Response response = getResponseWithInterceptorChain();</span><br><span class="line">		signalledCallback = true;</span><br><span class="line">		responseCallback.onResponse(RealCall.this, response);</span><br><span class="line">	&#125; catch (IOException e) &#123;</span><br><span class="line">		if (signalledCallback) &#123;</span><br><span class="line">		// Do not signal the callback twice!</span><br><span class="line">		Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			responseCallback.onFailure(RealCall.this, e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		client.dispatcher().finished(this);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>getResponseWithInterceptorChain() 放回 Response 对象，然后判断retryAndFollowUpInterceptor是否取消回调CallBack接口的onFailure()或onResponse()方法，最后finally中，和同步请求的处理一样，调用了Dispatcher对象的finished()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void finished(AsyncCall call) &#123;</span><br><span class="line">	call.callsPerHost().decrementAndGet();</span><br><span class="line">	finished(runningAsyncCalls, call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="getResponseWithInterceptorChain-通过拦截器链获取响应并返回"><a href="#getResponseWithInterceptorChain-通过拦截器链获取响应并返回" class="headerlink" title="getResponseWithInterceptorChain() 通过拦截器链获取响应并返回"></a>getResponseWithInterceptorChain() 通过拦截器链获取响应并返回</h1><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line">    // Build a full stack of interceptors.</span><br><span class="line">    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">    // 用户自定义的拦截器，用在与服务器建立链接之前进行拦截</span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    // 重试和失败重定向拦截器</span><br><span class="line">    interceptors.add(new RetryAndFollowUpInterceptor(client));</span><br><span class="line">    // 桥接和适配拦截器。主要补充用户创建请求当中的一些请求头Content-Type、Content-Type等</span><br><span class="line">    interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    // 缓存拦截器</span><br><span class="line">    interceptors.add(new CacheInterceptor(client.internalCache()));</span><br><span class="line">	// 与服务器建立连接</span><br><span class="line">    interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">    if (!forWebSocket) &#123;</span><br><span class="line">  		// 用户自定义的拦截器 用在与服务器建立链接之后进行拦截</span><br><span class="line">		interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    // 向服务器发送请求和接收数据的拦截器，将请求写入IO流，再从IO流中读取响应数据。</span><br><span class="line">    interceptors.add(new CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">    Interceptor.Chain chain = new RealInterceptorChain(interceptors, transmitter, null, 0,</span><br><span class="line">        originalRequest, this, client.connectTimeoutMillis(),</span><br><span class="line">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    boolean calledNoMoreExchanges = false;</span><br><span class="line">    try &#123;</span><br><span class="line">		Response response = chain.proceed(originalRequest);</span><br><span class="line">		if (transmitter.isCanceled()) &#123;</span><br><span class="line">			closeQuietly(response);</span><br><span class="line">        	throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		return response;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">		calledNoMoreExchanges = true;</span><br><span class="line">		throw transmitter.noMoreExchanges(e);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">		if (!calledNoMoreExchanges) &#123;</span><br><span class="line">			transmitter.noMoreExchanges(null);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h2><blockquote>
<p>RetryAndFollowUpInterceptor：重试和重定向拦截器，该拦截器可在失败后进行重试并且根据需要进行重定向，如果请求取消会抛出IOException。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br></pre></td><td class="code"><pre><span class="line">public final class RetryAndFollowUpInterceptor implements Interceptor &#123;</span><br><span class="line">    /**</span><br><span class="line">     * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,</span><br><span class="line">     * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.</span><br><span class="line">     */</span><br><span class="line">    // 重定向最多20次数</span><br><span class="line">    private static final int MAX_FOLLOW_UPS = 20;</span><br><span class="line"></span><br><span class="line">    private final OkHttpClient client;</span><br><span class="line"></span><br><span class="line">    public RetryAndFollowUpInterceptor(OkHttpClient client) &#123;</span><br><span class="line">        this.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">        Transmitter transmitter = realChain.transmitter();</span><br><span class="line">		// 重连次数</span><br><span class="line">        int followUpCount = 0;</span><br><span class="line">        Response priorResponse = null;</span><br><span class="line">        // 循环直到请求成功</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            // 准备创建一个流来承载请求参数。如果存在连接，则优先使用现有连接。</span><br><span class="line">            transmitter.prepareToConnect(request);</span><br><span class="line">            // 如果请求已取消，抛出IOException</span><br><span class="line">            if (transmitter.isCanceled()) &#123;</span><br><span class="line">                throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Response response;</span><br><span class="line">            boolean success = false;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 链式调用下一个拦截器 </span><br><span class="line">                response = realChain.proceed(request, transmitter, null);</span><br><span class="line">                success = true;</span><br><span class="line">            &#125; catch (RouteException e) &#123;</span><br><span class="line">                // The attempt to connect via a route failed. The request will not have been sent.</span><br><span class="line">                // 尝试通过路由连接失败。请求将不会被发送。</span><br><span class="line">                if (!recover(e.getLastConnectException(), transmitter, false, request)) &#123;</span><br><span class="line">                    throw e.getFirstConnectException();</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                // An attempt to communicate with a server failed. The request may have been sent.</span><br><span class="line">                // 尝试与服务器通信失败，可能请求已发送</span><br><span class="line">                boolean requestSendStarted = !(e instanceof ConnectionShutdownException);</span><br><span class="line">                // 并尝试从与服务器通信失败中恢复</span><br><span class="line">                // 在缓冲主体或在发送请求之前发生故障时，才能恢复具有正文的请求，如果不可恢复则抛出异常</span><br><span class="line">                if (!recover(e, transmitter, requestSendStarted, request)) throw e;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // The network call threw an exception. Release any resources.</span><br><span class="line">                // 释放资源</span><br><span class="line">                if (!success) &#123;</span><br><span class="line">                    transmitter.exchangeDoneDueToException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Attach the prior response if it exists. Such responses never have a body.</span><br><span class="line">            // 新建一个不含body的响应，并把先前的响应内容附加进去</span><br><span class="line">            if (priorResponse != null) &#123;</span><br><span class="line">                response = response.newBuilder()</span><br><span class="line">                        .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                                .body(null)</span><br><span class="line">                                .build())</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;</span><br><span class="line">		   // 传输单个HTTP请求和响应对。</span><br><span class="line">            Exchange exchange = Internal.instance.exchange(response);</span><br><span class="line">            Route route = exchange != null ? exchange.connection().route() : null;</span><br><span class="line">            // 重定向的Request，如果请求成功返回空</span><br><span class="line">            Request followUp = followUpRequest(response, route);</span><br><span class="line">            // 请求成功直接返回响应</span><br><span class="line">            if (followUp == null) &#123;</span><br><span class="line">                if (exchange != null &amp;&amp; exchange.isDuplex()) &#123;</span><br><span class="line">                    transmitter.timeoutEarlyExit();</span><br><span class="line">                &#125;</span><br><span class="line">                return response;</span><br><span class="line">            &#125;</span><br><span class="line">		   // 请求体不为空并且请求体最多可以传输一次，结束重连并返回响应</span><br><span class="line">            RequestBody followUpBody = followUp.body();</span><br><span class="line">            if (followUpBody != null &amp;&amp; followUpBody.isOneShot()) &#123;</span><br><span class="line">                return response;</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">            closeQuietly(response.body());</span><br><span class="line">            if (transmitter.hasExchange()) &#123;</span><br><span class="line">                exchange.detachWithViolence();</span><br><span class="line">            &#125;</span><br><span class="line">		   // 更新重连次数，如果重连次数大于最大的限制则抛出异常 </span><br><span class="line">            if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">                throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);</span><br><span class="line">            &#125;</span><br><span class="line">		   // 更新Request </span><br><span class="line">            request = followUp;</span><br><span class="line">            // 更新响应</span><br><span class="line">            priorResponse = response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Report and attempt to recover from a failure to communicate with a server. Returns true if</span><br><span class="line">     * &#123;@code e&#125; is recoverable, or false if the failure is permanent. Requests with a body can only</span><br><span class="line">     * be recovered if the body is buffered or if the failure occurred before the request has been</span><br><span class="line">     * sent.</span><br><span class="line">     */</span><br><span class="line">    private boolean recover(IOException e, Transmitter transmitter,</span><br><span class="line">                            boolean requestSendStarted, Request userRequest) &#123;</span><br><span class="line">        // The application layer has forbidden retries.</span><br><span class="line">        if (!client.retryOnConnectionFailure()) return false;</span><br><span class="line"></span><br><span class="line">        // We can&apos;t send the request body again.</span><br><span class="line">        if (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) return false;</span><br><span class="line"></span><br><span class="line">        // This exception is fatal.</span><br><span class="line">        if (!isRecoverable(e, requestSendStarted)) return false;</span><br><span class="line"></span><br><span class="line">        // No more routes to attempt.</span><br><span class="line">        if (!transmitter.canRetry()) return false;</span><br><span class="line"></span><br><span class="line">        // For failure recovery, use the same route selector with a new connection.</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean requestIsOneShot(IOException e, Request userRequest) &#123;</span><br><span class="line">        RequestBody requestBody = userRequest.body();</span><br><span class="line">        return (requestBody != null &amp;&amp; requestBody.isOneShot())</span><br><span class="line">                || e instanceof FileNotFoundException;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isRecoverable(IOException e, boolean requestSendStarted) &#123;</span><br><span class="line">        // If there was a protocol problem, don&apos;t recover.</span><br><span class="line">        if (e instanceof ProtocolException) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If there was an interruption don&apos;t recover, but if there was a timeout connecting to a route</span><br><span class="line">        // we should try the next route (if there is one).</span><br><span class="line">        if (e instanceof InterruptedIOException) &#123;</span><br><span class="line">            return e instanceof SocketTimeoutException &amp;&amp; !requestSendStarted;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Look for known client-side or negotiation errors that are unlikely to be fixed by trying</span><br><span class="line">        // again with a different route.</span><br><span class="line">        if (e instanceof SSLHandshakeException) &#123;</span><br><span class="line">            // If the problem was a CertificateException from the X509TrustManager,</span><br><span class="line">            // do not retry.</span><br><span class="line">            if (e.getCause() instanceof CertificateException) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e instanceof SSLPeerUnverifiedException) &#123;</span><br><span class="line">            // e.g. a certificate pinning error.</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // An example of one we might want to retry with a different route is a problem connecting to a</span><br><span class="line">        // proxy and would manifest as a standard IOException. Unless it is one we know we should not</span><br><span class="line">        // retry, we return true and try a new route.</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Figures out the HTTP request to make in response to receiving &#123;@code userResponse&#125;. This will</span><br><span class="line">     * either add authentication headers, follow redirects or handle a client request timeout. If a</span><br><span class="line">     * follow-up is either unnecessary or not applicable, this returns null.</span><br><span class="line">     */</span><br><span class="line">    private Request followUpRequest(Response userResponse, @Nullable Route route) throws IOException &#123;</span><br><span class="line">        if (userResponse == null) throw new IllegalStateException();</span><br><span class="line">        int responseCode = userResponse.code();</span><br><span class="line"></span><br><span class="line">        final String method = userResponse.request().method();</span><br><span class="line">        switch (responseCode) &#123;</span><br><span class="line">            case HTTP_PROXY_AUTH:</span><br><span class="line">                Proxy selectedProxy = route != null</span><br><span class="line">                        ? route.proxy()</span><br><span class="line">                        : client.proxy();</span><br><span class="line">                if (selectedProxy.type() != Proxy.Type.HTTP) &#123;</span><br><span class="line">                    throw new ProtocolException(&quot;Received HTTP_PROXY_AUTH (407) code while not using proxy&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                return client.proxyAuthenticator().authenticate(route, userResponse);</span><br><span class="line"></span><br><span class="line">            case HTTP_UNAUTHORIZED:</span><br><span class="line">                return client.authenticator().authenticate(route, userResponse);</span><br><span class="line"></span><br><span class="line">            case HTTP_PERM_REDIRECT:</span><br><span class="line">            case HTTP_TEMP_REDIRECT:</span><br><span class="line">                // &quot;If the 307 or 308 status code is received in response to a request other than GET</span><br><span class="line">                // or HEAD, the user agent MUST NOT automatically redirect the request&quot;</span><br><span class="line">                if (!method.equals(&quot;GET&quot;) &amp;&amp; !method.equals(&quot;HEAD&quot;)) &#123;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                // fall-through</span><br><span class="line">            case HTTP_MULT_CHOICE:</span><br><span class="line">            case HTTP_MOVED_PERM:</span><br><span class="line">            case HTTP_MOVED_TEMP:</span><br><span class="line">            case HTTP_SEE_OTHER:</span><br><span class="line">                // Does the client allow redirects?</span><br><span class="line">                if (!client.followRedirects()) return null;</span><br><span class="line"></span><br><span class="line">                String location = userResponse.header(&quot;Location&quot;);</span><br><span class="line">                if (location == null) return null;</span><br><span class="line">                HttpUrl url = userResponse.request().url().resolve(location);</span><br><span class="line"></span><br><span class="line">                // Don&apos;t follow redirects to unsupported protocols.</span><br><span class="line">                if (url == null) return null;</span><br><span class="line"></span><br><span class="line">                // If configured, don&apos;t follow redirects between SSL and non-SSL.</span><br><span class="line">                boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme());</span><br><span class="line">                if (!sameScheme &amp;&amp; !client.followSslRedirects()) return null;</span><br><span class="line"></span><br><span class="line">                // Most redirects don&apos;t include a request body.</span><br><span class="line">                Request.Builder requestBuilder = userResponse.request().newBuilder();</span><br><span class="line">                if (HttpMethod.permitsRequestBody(method)) &#123;</span><br><span class="line">                    final boolean maintainBody = HttpMethod.redirectsWithBody(method);</span><br><span class="line">                    if (HttpMethod.redirectsToGet(method)) &#123;</span><br><span class="line">                        requestBuilder.method(&quot;GET&quot;, null);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        RequestBody requestBody = maintainBody ? userResponse.request().body() : null;</span><br><span class="line">                        requestBuilder.method(method, requestBody);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (!maintainBody) &#123;</span><br><span class="line">                        requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);</span><br><span class="line">                        requestBuilder.removeHeader(&quot;Content-Length&quot;);</span><br><span class="line">                        requestBuilder.removeHeader(&quot;Content-Type&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // When redirecting across hosts, drop all authentication headers. This</span><br><span class="line">                // is potentially annoying to the application layer since they have no</span><br><span class="line">                // way to retain them.</span><br><span class="line">                if (!sameConnection(userResponse.request().url(), url)) &#123;</span><br><span class="line">                    requestBuilder.removeHeader(&quot;Authorization&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return requestBuilder.url(url).build();</span><br><span class="line"></span><br><span class="line">            case HTTP_CLIENT_TIMEOUT:</span><br><span class="line">                // 408&apos;s are rare in practice, but some servers like HAProxy use this response code. The</span><br><span class="line">                // spec says that we may repeat the request without modifications. Modern browsers also</span><br><span class="line">                // repeat the request (even non-idempotent ones.)</span><br><span class="line">                if (!client.retryOnConnectionFailure()) &#123;</span><br><span class="line">                    // The application layer has directed us not to retry the request.</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                RequestBody requestBody = userResponse.request().body();</span><br><span class="line">                if (requestBody != null &amp;&amp; requestBody.isOneShot()) &#123;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (userResponse.priorResponse() != null</span><br><span class="line">                        &amp;&amp; userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) &#123;</span><br><span class="line">                    // We attempted to retry and got another timeout. Give up.</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (retryAfter(userResponse, 0) &gt; 0) &#123;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return userResponse.request();</span><br><span class="line"></span><br><span class="line">            case HTTP_UNAVAILABLE:</span><br><span class="line">                if (userResponse.priorResponse() != null</span><br><span class="line">                        &amp;&amp; userResponse.priorResponse().code() == HTTP_UNAVAILABLE) &#123;</span><br><span class="line">                    // We attempted to retry and got another timeout. Give up.</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (retryAfter(userResponse, Integer.MAX_VALUE) == 0) &#123;</span><br><span class="line">                    // specifically received an instruction to retry without delay</span><br><span class="line">                    return userResponse.request();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return null;</span><br><span class="line"></span><br><span class="line">            default:</span><br><span class="line">                return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int retryAfter(Response userResponse, int defaultDelay) &#123;</span><br><span class="line">        String header = userResponse.header(&quot;Retry-After&quot;);</span><br><span class="line"></span><br><span class="line">        if (header == null) &#123;</span><br><span class="line">            return defaultDelay;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // https://tools.ietf.org/html/rfc7231#section-7.1.3</span><br><span class="line">        // currently ignores a HTTP-date, and assumes any non int 0 is a delay</span><br><span class="line">        if (header.matches(&quot;\\d+&quot;)) &#123;</span><br><span class="line">            return Integer.valueOf(header);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h2><blockquote>
<p> BridgeInterceptor：桥接拦截器，负责构建请求和封装响应结果。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">public final class BridgeInterceptor implements Interceptor &#123;</span><br><span class="line">    private final CookieJar cookieJar;</span><br><span class="line"></span><br><span class="line">    public BridgeInterceptor(CookieJar cookieJar) &#123;</span><br><span class="line">        this.cookieJar = cookieJar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    	// 获取请求</span><br><span class="line">        Request userRequest = chain.request();</span><br><span class="line">        // 生成请求的建造者以便进行自定义</span><br><span class="line">        Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line">		// 获取请求体</span><br><span class="line">        RequestBody body = userRequest.body();</span><br><span class="line">        if (body != null) &#123;</span><br><span class="line">        	// 添加header，body类型、body长度</span><br><span class="line">            MediaType contentType = body.contentType();</span><br><span class="line">            if (contentType != null) &#123;</span><br><span class="line">                requestBuilder.header(&quot;Content-Type&quot;, contentType.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            long contentLength = body.contentLength();</span><br><span class="line">            if (contentLength != -1) &#123;</span><br><span class="line">                requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength));</span><br><span class="line">                requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);</span><br><span class="line">                requestBuilder.removeHeader(&quot;Content-Length&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (userRequest.header(&quot;Host&quot;) == null) &#123;</span><br><span class="line">        	// 如果未指定host，则在此添加host</span><br><span class="line">            requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (userRequest.header(&quot;Connection&quot;) == null) &#123;</span><br><span class="line">            requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If we add an &quot;Accept-Encoding: gzip&quot; header field we&apos;re responsible for also decompressing</span><br><span class="line">        // the transfer stream.</span><br><span class="line">        boolean transparentGzip = false;</span><br><span class="line">        // 对未添加压缩模式的请求添加gzip压缩</span><br><span class="line">        if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) &#123;</span><br><span class="line">            transparentGzip = true;</span><br><span class="line">            requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">		// 添加cookie</span><br><span class="line">        List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">        if (!cookies.isEmpty()) &#123;</span><br><span class="line">            requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (userRequest.header(&quot;User-Agent&quot;) == null) &#123;</span><br><span class="line">            requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent());</span><br><span class="line">        &#125;</span><br><span class="line">		// 交由下一个拦截器处理</span><br><span class="line">        Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line">		// 缓存服务器返回的Cookie</span><br><span class="line">        HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line">		// 构建响应的建造者 </span><br><span class="line">        Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">                .request(userRequest);</span><br><span class="line">		// 如果使用了压缩并且压缩方式gzip并且响应有内容，使用gzip进行解压，并添加到响应的建造者中。</span><br><span class="line">        if (transparentGzip</span><br><span class="line">                &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))</span><br><span class="line">                &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">            GzipSource responseBody = new GzipSource(networkResponse.body().source());</span><br><span class="line">            Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">                    .removeAll(&quot;Content-Encoding&quot;)</span><br><span class="line">                    .removeAll(&quot;Content-Length&quot;)</span><br><span class="line">                    .build();</span><br><span class="line">            responseBuilder.headers(strippedHeaders);</span><br><span class="line">            String contentType = networkResponse.header(&quot;Content-Type&quot;);</span><br><span class="line">            responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));</span><br><span class="line">        &#125;</span><br><span class="line">		// 返回response</span><br><span class="line">        return responseBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns a &apos;Cookie&apos; HTTP request header with all cookies, like &#123;@code a=b; c=d&#125;.</span><br><span class="line">     */</span><br><span class="line">    private String cookieHeader(List&lt;Cookie&gt; cookies) &#123;</span><br><span class="line">        StringBuilder cookieHeader = new StringBuilder();</span><br><span class="line">        for (int i = 0, size = cookies.size(); i &lt; size; i++) &#123;</span><br><span class="line">            if (i &gt; 0) &#123;</span><br><span class="line">                cookieHeader.append(&quot;; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            Cookie cookie = cookies.get(i);</span><br><span class="line">            cookieHeader.append(cookie.name()).append(&apos;=&apos;).append(cookie.value());</span><br><span class="line">        &#125;</span><br><span class="line">        return cookieHeader.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h2><blockquote>
<p>CacheInterceptor：向请求写入缓存，并将响应写入缓存。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line">public final class CacheInterceptor implements Interceptor &#123;</span><br><span class="line">    final @Nullable</span><br><span class="line">    InternalCache cache;</span><br><span class="line"></span><br><span class="line">    public CacheInterceptor(@Nullable InternalCache cache) &#123;</span><br><span class="line">        this.cache = cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    	// 如果缓存不为空，获取缓存的响应</span><br><span class="line">        Response cacheCandidate = cache != null</span><br><span class="line">                ? cache.get(chain.request())</span><br><span class="line">                : null;</span><br><span class="line"></span><br><span class="line">        long now = System.currentTimeMillis();</span><br><span class="line">		// 通过当前的请求request和之前缓存的响应，获取当前请求可以使用网络的情况下的缓存的策略。</span><br><span class="line">        CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">        Request networkRequest = strategy.networkRequest;</span><br><span class="line">        Response cacheResponse = strategy.cacheResponse;</span><br><span class="line"></span><br><span class="line">        if (cache != null) &#123;</span><br><span class="line">        	// 追踪满足缓存策略的响应 </span><br><span class="line">            cache.trackResponse(strategy);</span><br><span class="line">        &#125;</span><br><span class="line">		// 缓存不适用，关闭缓存处理</span><br><span class="line">        if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">       		// The cache candidate wasn&apos;t applicable. Close it.</span><br><span class="line">            closeQuietly(cacheCandidate.body()); </span><br><span class="line">        &#125;</span><br><span class="line">		// 网络不可用，并且缓存不足</span><br><span class="line">        // If we&apos;re forbidden from using the network and the cache is insufficient, fail.</span><br><span class="line">        if (networkRequest == null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">            return new Response.Builder()</span><br><span class="line">                    .request(chain.request())</span><br><span class="line">                    .protocol(Protocol.HTTP_1_1)</span><br><span class="line">                    .code(504)</span><br><span class="line">                    .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</span><br><span class="line">                    .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                    .sentRequestAtMillis(-1L)</span><br><span class="line">                    .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">		// 在不需要网络救完成的情况下直接返回缓存（缓存有效）</span><br><span class="line">        // If we don&apos;t need the network, we&apos;re done.</span><br><span class="line">        if (networkRequest == null) &#123;</span><br><span class="line">            return cacheResponse.newBuilder()</span><br><span class="line">                    .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Response networkResponse = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            networkResponse = chain.proceed(networkRequest);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">        	// 遇到异常并且没有响应关闭缓存处理</span><br><span class="line">            // If we&apos;re crashing on I/O or otherwise, don&apos;t leak the cache body.</span><br><span class="line">            if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123;</span><br><span class="line">                closeQuietly(cacheCandidate.body());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        // If we have a cache response too, then we&apos;re doing a conditional get.</span><br><span class="line">        if (cacheResponse != null) &#123;</span><br><span class="line">        	// 如果我们请求时使用了缓存，并且返回的code告诉我们未对响应做修改。那么我们直接使用缓存作为</span><br><span class="line">			// 响应只需要更新缓存的时间戳信息、header</span><br><span class="line">            if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">                Response response = cacheResponse.newBuilder()</span><br><span class="line">                        .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">                        .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">                        .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">                        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                        .networkResponse(stripBody(networkResponse))</span><br><span class="line">                        .build();</span><br><span class="line">                networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">                // Update the cache after combining headers but before stripping the</span><br><span class="line">                // Content-Encoding header (as performed by initContentStream()).</span><br><span class="line">                cache.trackConditionalCacheHit();</span><br><span class="line">                cache.update(cacheResponse, response);</span><br><span class="line">                return response;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            	// 关闭之前的缓存</span><br><span class="line">                closeQuietly(cacheResponse.body());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Response response = networkResponse.newBuilder()</span><br><span class="line">                .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                .networkResponse(stripBody(networkResponse))</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        if (cache != null) &#123;</span><br><span class="line">        	// 网络请求的响应有相应体，并且该请求和响应都有缓存，那么存储响应到缓存</span><br><span class="line">            if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">                // Offer this request to the cache.</span><br><span class="line">                CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">                return cacheWritingResponse(cacheRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">		   //  如果请求方法是POST、PATCH、PUT、DELETE、MOVE代表不可缓存的请求，删除已有缓存</span><br><span class="line">            if (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    cache.remove(networkRequest);</span><br><span class="line">                &#125; catch (IOException ignored) &#123;</span><br><span class="line">                    // The cache cannot be written.</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Response stripBody(Response response) &#123;</span><br><span class="line">        return response != null &amp;&amp; response.body() != null</span><br><span class="line">                ? response.newBuilder().body(null).build()</span><br><span class="line">                : response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns a new source that writes bytes to &#123;@code cacheRequest&#125; as they are read by the source</span><br><span class="line">     * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we</span><br><span class="line">     * may never exhaust the source stream and therefore not complete the cached response.</span><br><span class="line">     */</span><br><span class="line">    private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)</span><br><span class="line">            throws IOException &#123;</span><br><span class="line">        // Some apps return a null body; for compatibility we treat that like a null cache request.</span><br><span class="line">        if (cacheRequest == null) return response;</span><br><span class="line">        Sink cacheBodyUnbuffered = cacheRequest.body();</span><br><span class="line">        if (cacheBodyUnbuffered == null) return response;</span><br><span class="line"></span><br><span class="line">        final BufferedSource source = response.body().source();</span><br><span class="line">        final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);</span><br><span class="line"></span><br><span class="line">        Source cacheWritingSource = new Source() &#123;</span><br><span class="line">            boolean cacheRequestClosed;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public long read(Buffer sink, long byteCount) throws IOException &#123;</span><br><span class="line">                long bytesRead;</span><br><span class="line">                try &#123;</span><br><span class="line">                    bytesRead = source.read(sink, byteCount);</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    if (!cacheRequestClosed) &#123;</span><br><span class="line">                        cacheRequestClosed = true;</span><br><span class="line">                        cacheRequest.abort(); // Failed to write a complete cache response.</span><br><span class="line">                    &#125;</span><br><span class="line">                    throw e;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (bytesRead == -1) &#123;</span><br><span class="line">                    if (!cacheRequestClosed) &#123;</span><br><span class="line">                        cacheRequestClosed = true;</span><br><span class="line">                        cacheBody.close(); // The cache response is complete!</span><br><span class="line">                    &#125;</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);</span><br><span class="line">                cacheBody.emitCompleteSegments();</span><br><span class="line">                return bytesRead;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public Timeout timeout() &#123;</span><br><span class="line">                return source.timeout();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void close() throws IOException &#123;</span><br><span class="line">                if (!cacheRequestClosed</span><br><span class="line">                        &amp;&amp; !discard(this, ExchangeCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) &#123;</span><br><span class="line">                    cacheRequestClosed = true;</span><br><span class="line">                    cacheRequest.abort();</span><br><span class="line">                &#125;</span><br><span class="line">                source.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        String contentType = response.header(&quot;Content-Type&quot;);</span><br><span class="line">        long contentLength = response.body().contentLength();</span><br><span class="line">        return response.newBuilder()</span><br><span class="line">                .body(new RealResponseBody(contentType, contentLength, Okio.buffer(cacheWritingSource)))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Combines cached headers with a network headers as defined by RFC 7234, 4.3.4.</span><br><span class="line">     */</span><br><span class="line">    private static Headers combine(Headers cachedHeaders, Headers networkHeaders) &#123;</span><br><span class="line">        Headers.Builder result = new Headers.Builder();</span><br><span class="line"></span><br><span class="line">        for (int i = 0, size = cachedHeaders.size(); i &lt; size; i++) &#123;</span><br><span class="line">            String fieldName = cachedHeaders.name(i);</span><br><span class="line">            String value = cachedHeaders.value(i);</span><br><span class="line">            if (&quot;Warning&quot;.equalsIgnoreCase(fieldName) &amp;&amp; value.startsWith(&quot;1&quot;)) &#123;</span><br><span class="line">                continue; // Drop 100-level freshness warnings.</span><br><span class="line">            &#125;</span><br><span class="line">            if (isContentSpecificHeader(fieldName)</span><br><span class="line">                    || !isEndToEnd(fieldName)</span><br><span class="line">                    || networkHeaders.get(fieldName) == null) &#123;</span><br><span class="line">                Internal.instance.addLenient(result, fieldName, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0, size = networkHeaders.size(); i &lt; size; i++) &#123;</span><br><span class="line">            String fieldName = networkHeaders.name(i);</span><br><span class="line">            if (!isContentSpecificHeader(fieldName) &amp;&amp; isEndToEnd(fieldName)) &#123;</span><br><span class="line">                Internal.instance.addLenient(result, fieldName, networkHeaders.value(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns true if &#123;@code fieldName&#125; is an end-to-end HTTP header, as defined by RFC 2616,</span><br><span class="line">     * 13.5.1.</span><br><span class="line">     */</span><br><span class="line">    static boolean isEndToEnd(String fieldName) &#123;</span><br><span class="line">        return !&quot;Connection&quot;.equalsIgnoreCase(fieldName)</span><br><span class="line">                &amp;&amp; !&quot;Keep-Alive&quot;.equalsIgnoreCase(fieldName)</span><br><span class="line">                &amp;&amp; !&quot;Proxy-Authenticate&quot;.equalsIgnoreCase(fieldName)</span><br><span class="line">                &amp;&amp; !&quot;Proxy-Authorization&quot;.equalsIgnoreCase(fieldName)</span><br><span class="line">                &amp;&amp; !&quot;TE&quot;.equalsIgnoreCase(fieldName)</span><br><span class="line">                &amp;&amp; !&quot;Trailers&quot;.equalsIgnoreCase(fieldName)</span><br><span class="line">                &amp;&amp; !&quot;Transfer-Encoding&quot;.equalsIgnoreCase(fieldName)</span><br><span class="line">                &amp;&amp; !&quot;Upgrade&quot;.equalsIgnoreCase(fieldName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns true if &#123;@code fieldName&#125; is content specific and therefore should always be used</span><br><span class="line">     * from cached headers.</span><br><span class="line">     */</span><br><span class="line">    static boolean isContentSpecificHeader(String fieldName) &#123;</span><br><span class="line">        return &quot;Content-Length&quot;.equalsIgnoreCase(fieldName)</span><br><span class="line">                || &quot;Content-Encoding&quot;.equalsIgnoreCase(fieldName)</span><br><span class="line">                || &quot;Content-Type&quot;.equalsIgnoreCase(fieldName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h2><blockquote>
<p>ConnectInterceptor：打开与目标服务器的连接，然后继续执行下一个拦截器</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public final class ConnectInterceptor implements Interceptor &#123;</span><br><span class="line">    public final OkHttpClient client;</span><br><span class="line"></span><br><span class="line">    public ConnectInterceptor(OkHttpClient client) &#123;</span><br><span class="line">        this.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">        Request request = realChain.request();</span><br><span class="line">        Transmitter transmitter = realChain.transmitter();</span><br><span class="line"></span><br><span class="line">        // We need the network to satisfy this request. Possibly for validating a conditional GET.</span><br><span class="line">        boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);</span><br><span class="line">        Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks);</span><br><span class="line"></span><br><span class="line">        return realChain.proceed(request, transmitter, exchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="networkInterceptors"><a href="#networkInterceptors" class="headerlink" title="networkInterceptors"></a>networkInterceptors</h2><blockquote>
<p>networkInterceptors：用户自定义的拦截器 用在与服务器建立链接之后进行拦截。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class DemoInterceptor implements Interceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        // 前置工作</span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        Response response = chain.proceed(request);</span><br><span class="line">        // 后置工作</span><br><span class="line">        return response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h2><blockquote>
<p>CallServerInterceptor：向服务器发送请求和接收数据的拦截器，将请求写入IO流，再从IO流中读取响应数据。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">public final class CallServerInterceptor implements Interceptor &#123;</span><br><span class="line">    private final boolean forWebSocket;</span><br><span class="line"></span><br><span class="line">    public CallServerInterceptor(boolean forWebSocket) &#123;</span><br><span class="line">        this.forWebSocket = forWebSocket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">        // 获取实际请求编码响应解码（Http1ExchangeCodec）的连接管理和时间分层</span><br><span class="line">        Exchange exchange = realChain.exchange();</span><br><span class="line">        // 获取请求</span><br><span class="line">        Request request = realChain.request();</span><br><span class="line"></span><br><span class="line">        long sentRequestMillis = System.currentTimeMillis();</span><br><span class="line">		// 将请求头编码</span><br><span class="line">        exchange.writeRequestHeaders(request);</span><br><span class="line"></span><br><span class="line">        boolean responseHeadersStarted = false;</span><br><span class="line">        Response.Builder responseBuilder = null;</span><br><span class="line">        // 不是GET或HEAD方法并且包含请求体时</span><br><span class="line">        if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) &#123;</span><br><span class="line">            // If there&apos;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100</span><br><span class="line">            // Continue&quot; response before transmitting the request body. If we don&apos;t get that, return</span><br><span class="line">            // what we did get (such as a 4xx response) without ever transmitting the request body.</span><br><span class="line">           	// 如果请求头中有“Expect：100-continue”标头，在那么发送请求主体之前等待“HTTP / 1.1 </span><br><span class="line">           	// 100.Continue”响应</span><br><span class="line">           if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) &#123;</span><br><span class="line">                exchange.flushRequest();</span><br><span class="line">                responseHeadersStarted = true;</span><br><span class="line">                exchange.responseHeadersStart();</span><br><span class="line">                responseBuilder = exchange.readResponseHeaders(true);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (responseBuilder == null) &#123;</span><br><span class="line">            	//是否双工请求 isDuplex()方法除非被重写，默认返回false</span><br><span class="line">                if (request.body().isDuplex()) &#123;</span><br><span class="line">                    // Prepare a duplex body so that the application can send a request body later.</span><br><span class="line">                    // 准备双工体，以便应用程序可以稍后发送请求正文。</span><br><span class="line">                    exchange.flushRequest();</span><br><span class="line">                    BufferedSink bufferedRequestBody = Okio.buffer(</span><br><span class="line">                            exchange.createRequestBody(request, true));</span><br><span class="line">                     // 写入双工请求体</span><br><span class="line">                    request.body().writeTo(bufferedRequestBody);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.</span><br><span class="line">                    // 如果是&quot;Expect: 100-continue&quot;那么写下请求体</span><br><span class="line">                    BufferedSink bufferedRequestBody = Okio.buffer(</span><br><span class="line">                            exchange.createRequestBody(request, false));</span><br><span class="line">                    request.body().writeTo(bufferedRequestBody);</span><br><span class="line">                    bufferedRequestBody.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                exchange.noRequestBody();</span><br><span class="line">                // 是否不属于Http/2（此类连接可以同时用于多个HTTP请求。）连接</span><br><span class="line">                if (!exchange.connection().isMultiplexed()) &#123;</span><br><span class="line">                    // If the &quot;Expect: 100-continue&quot; expectation wasn&apos;t met, </span><br><span class="line">                    // prevent the HTTP/1 connection from being reused. Otherwise we&apos;re still</span><br><span class="line">                    // obligated to transmit the request body to leave the connection </span><br><span class="line">                    // in a consistent state.</span><br><span class="line">                    exchange.noNewExchangesOnConnection();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            exchange.noRequestBody();</span><br><span class="line">        &#125;</span><br><span class="line">		// 不存在请求体也不是双工请求</span><br><span class="line">        if (request.body() == null || !request.body().isDuplex()) &#123;</span><br><span class="line">            exchange.finishRequest();</span><br><span class="line">        &#125;</span><br><span class="line">		// 响应头未启动</span><br><span class="line">        if (!responseHeadersStarted) &#123;</span><br><span class="line">            exchange.responseHeadersStart();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (responseBuilder == null) &#123;</span><br><span class="line">            responseBuilder = exchange.readResponseHeaders(false);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Response response = responseBuilder</span><br><span class="line">                .request(request)</span><br><span class="line">                .handshake(exchange.connection().handshake())</span><br><span class="line">                .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">                .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        int code = response.code();</span><br><span class="line">        if (code == 100) &#123;</span><br><span class="line">        // 服务器发送了100-continue，即使我们没有请求，还是应该再请求一次读取实际请求</span><br><span class="line">            // server sent a 100-continue even though we did not request one.</span><br><span class="line">            // try again to read the actual response</span><br><span class="line">            response = exchange.readResponseHeaders(false)</span><br><span class="line">                    .request(request)</span><br><span class="line">                    .handshake(exchange.connection().handshake())</span><br><span class="line">                    .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">                    .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            code = response.code();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        exchange.responseHeadersEnd(response);</span><br><span class="line"></span><br><span class="line">        if (forWebSocket &amp;&amp; code == 101) &#123;</span><br><span class="line">            // Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .body(exchange.openResponseBody(response))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (&quot;close&quot;.equalsIgnoreCase(response.request().header(&quot;Connection&quot;))</span><br><span class="line">                || &quot;close&quot;.equalsIgnoreCase(response.header(&quot;Connection&quot;))) &#123;</span><br><span class="line">            exchange.noNewExchangesOnConnection();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) &#123;</span><br><span class="line">            throw new ProtocolException(</span><br><span class="line">                    &quot;HTTP &quot; + code + &quot; had non-zero Content-Length: &quot; + response.body().contentLength());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    
    
       <div>
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">------------The End-------------</div>
    
</div>
      </div>
    
    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/源码分析/" <i class="fa fa-tag"></i>源码分析</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/17/Java动态代理/" rel="next" title="java动态代理">
                <i class="fa fa-chevron-left"></i> java动态代理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!--MOB SHARE BEGIN-->
<div class="-hoofoo-share-title">分享到：</div>
<div class="-hoofoo-share-buttons">
    <div class="-mob-share-weibo -hoofoo-share-weibo -hoofoo-share-ui-button"><i class="fa fa-weibo" aria-hidden="true"></i></div>
    <div class="-mob-share-weixin -hoofoo-share-weixin -hoofoo-share-ui-button"><i class="fa fa-weixin" aria-hidden="true"></i></div>
    <div class="-mob-share-qq -hoofoo-share-qq -hoofoo-share-ui-button"><i class="fa fa-qq" aria-hidden="true"></i></div>
    <div class="-mob-share-twitter -hoofoo-share-twitter -hoofoo-share-ui-button"><i class="fa fa-twitter" aria-hidden="true"></i></div>
    <div class="-hoofoo-share-more -hoofoo-share-ui-button -mob-share-open"><i class="fa fa-ellipsis-h" aria-hidden="true"></i></div>
</div>
<div class="-mob-share-ui" style="display: none">
    <ul class="-mob-share-list">
        <li class="-mob-share-weibo"><p>新浪微博</p></li>
        <li class="-mob-share-weixin"><p>微信</p></li>
        <li class="-mob-share-qzone"><p>QQ空间</p></li>
        <li class="-mob-share-qq"><p>QQ好友</p></li>
        <li class="-mob-share-tencentweibo"><p>腾讯微博</p></li>
        <li class="-mob-share-renren"><p>人人网</p></li>
        <li class="-mob-share-kaixin"><p>开心网</p></li>
        <li class="-mob-share-douban"><p>豆瓣</p></li>
        <li class="-mob-share-youdao"><p>有道云笔记</p></li>
        <li class="-mob-share-mingdao"><p>明道</p></li>
        <li class="-mob-share-pengyou"><p>朋友网</p></li>
        <li class="-mob-share-facebook"><p>Facebook</p></li>
        <li class="-mob-share-twitter"><p>Twitter</p></li>
        <li class="-mob-share-pocket"><p>Pocket</p></li>
        <li class="-mob-share-google"><p>Google+</p></li>
        <li class="-mob-share-tumblr"><p>Tumblr</p></li>
        <li class="-mob-share-instapaper"><p>Instapaper</p></li>
        <li class="-mob-share-linkedin"><p>Linkedin</p></li>
    </ul>
    <div class="-mob-share-close">取消</div>
</div>
<div class="-mob-share-ui-bg"></div>
<script id="-mob-share" src="http://f1.webshare.mob.com/code/mob-share.js?appkey=253a344399ff0"></script>
<!--MOB SHARE END-->
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">作茧自缚</p>
              <p class="site-description motion-element" itemprop="description">格物致知</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Okhttp简介"><span class="nav-number">1.</span> <span class="nav-text">Okhttp简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Okhttp的使用"><span class="nav-number">2.</span> <span class="nav-text">Okhttp的使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#OkhttpClient的创建"><span class="nav-number">3.</span> <span class="nav-text">OkhttpClient的创建</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#请求体Request的创建"><span class="nav-number">4.</span> <span class="nav-text">请求体Request的创建</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#创建Call对象"><span class="nav-number">5.</span> <span class="nav-text">创建Call对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Transmitter"><span class="nav-number">6.</span> <span class="nav-text">Transmitter</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Exchange"><span class="nav-number">7.</span> <span class="nav-text">Exchange</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Dispatcher"><span class="nav-number">8.</span> <span class="nav-text">Dispatcher</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#同步请求"><span class="nav-number">9.</span> <span class="nav-text">同步请求</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#异步请求"><span class="nav-number">10.</span> <span class="nav-text">异步请求</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AsyncCall类"><span class="nav-number">10.1.</span> <span class="nav-text">AsyncCall类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#getResponseWithInterceptorChain-通过拦截器链获取响应并返回"><span class="nav-number">11.</span> <span class="nav-text">getResponseWithInterceptorChain() 通过拦截器链获取响应并返回</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RetryAndFollowUpInterceptor"><span class="nav-number">11.1.</span> <span class="nav-text">RetryAndFollowUpInterceptor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BridgeInterceptor"><span class="nav-number">11.2.</span> <span class="nav-text">BridgeInterceptor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CacheInterceptor"><span class="nav-number">11.3.</span> <span class="nav-text">CacheInterceptor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConnectInterceptor"><span class="nav-number">11.4.</span> <span class="nav-text">ConnectInterceptor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#networkInterceptors"><span class="nav-number">11.5.</span> <span class="nav-text">networkInterceptors</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CallServerInterceptor"><span class="nav-number">11.6.</span> <span class="nav-text">CallServerInterceptor</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">作茧自缚</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">80.3k</span>
  
</div>


  <div class="powered-by">  个人专属</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">博客 </div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>
  <a href="https://github.com/xuqinzz"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://zhizhi.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2019/04/29/Okhttp3源码浅析/';
          this.page.identifier = '2019/04/29/Okhttp3源码浅析/';
          this.page.title = 'Okhttp3源码浅析';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://zhizhi.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  

  

  

  
<script type="text/javascript">
    //微信二维码点击背景关闭
    $('body').delegate('.-mob-share-weixin-qrcode-bg','click', function(){
         $(".-mob-share-weixin-qrcode-close").trigger("click");
    }); 
</script>

<script type="text/javascript" color="255,132,0" opacity='0.6' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script>

</body>
</html>
