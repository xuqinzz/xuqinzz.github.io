<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[API-Guide之设备兼容性]]></title>
    <url>%2F2018%2F05%2F02%2FAPI-Guide%E4%B9%8BDevice%20compatibility%2F</url>
    <content type="text"><![CDATA[概述 Android系统运行在多种类型的设备上，包括手机、平板电脑以及电视机。作为开发者的我们应该尽量适配不同类型的设备，以挖掘潜在的用户。为了适配不同类型的设备，应用功能对于不同不用的设备或许有些不同存在一定的变化，并且对于不同的设备屏幕配置相应的界面。 为了帮助开发者适配不同的设备，Android提供了一个动态的应用程序框架。开发者可以在静态文件中提供特定于配置的应用资源，然后Android系统会根据当前的设备类型加载相应的资源。通过这种动态的框架开发者就可以仅发布单个应用程序包（APK）,便适配多种设备。 同时，开发者也可指定使用应用功能的要求，并限定那些类型的设备可以从Google Play上安装应用。 兼容性设备兼容性 只有设备能够正确运行为Android执行环境编写的应用程序，设备才能 “与Android兼容”。 Android执行环境的确切细节由Android兼容性程序定义，并且每个设备必须通过兼容性测试套件（CTS）才能被视为兼容。 应用程序兼容性 应用是否与每种潜在的设备配置兼容。由于Android在各种设备配置上运行，某些功能在所有设备上都不可用。例如，某些设备可能不包含指南针传感器。如果您的应用程序的核心功能需要使用指南针传感器，那么您的应用程序仅与包含指南针传感器的设备兼容。 应用对设备的可用性 Android系统支持调用API来获取使用系统的功能，一些功能是基于硬件的（如指南针传感器），一些是基于软件的（如应用程序小部件），另一些则依赖于系统版本。并非所有的设备都支持全部功能，因此应用需要根据所需要的功能来控制应用对设备的可用性。 为了使应用获取尽可能多的用户，开发者应该尽可能使单个APK支持所有设备配置。在大多数情况下，开发者可以通过运行时禁用可选功能并为应用程序资源提供不同配置的替代选项来实现此目的。但是在并要情况下也可根据设备特征，通过Google Play应用商店限制应用程序在设备上的可用性： 设备功能 平台版本 屏幕配置 设备功能 Android为任何可能无法在所有设备上使用的硬件或软件功能定义了功能ID，以便开发者根据功能管理应用的可用性。例如，指南针传感器的功能ID是FEATURE_SENSOR_COMPASS，应用程序小窗口功能ID是FEATURE_APP_WIDGETS如果游标，可以阻止用户在其设备未提供给定功能的情况下通过将其声明为的清单文件中的元素来安装应用。例如，如果应用在没有指南针传感器的设备上没有意义，则可根据以下清单标签声明指南针传感器：&lt;manifest ... &gt; &lt;uses-feature android：name = “android.hardware.sensor.compass” android：required = “true” /&gt; ... &lt;/ manifest&gt; Google Play商店会将您应用所需的功能与每个用户设备上提供的功能进行比较，以确定您的应用是否与每个设备兼容。如果设备未提供您的应用所需的全部功能，则用户无法安装您的应用。 但是，如果您的应用程序的主要功能不需要 设备功能，则应该将该required属性设置为&quot;false&quot;并在运行时检查设备功能。如果应用程序功能在当前设备上不可用，请适度降低相应的应用程序功能。例如，您可以通过如下方式调用来查询某个功能是否可用 hasSystemFeature()： 注意：某些系统权限隐式需要设备功能的可用性。例如，如果您的应用请求访问权限BLUETOOTH，则这隐含地要求FEATURE_BLUETOOTH设备功能。您可以禁用基于此功能的过滤功能，并通过将该required属性设置&quot;false&quot;为标签，使应用可供没有蓝牙的设备使用. 平台版本 不同的设备可能会运行不同版本的Android平台，例如Android 4.0或Android 4.4。每个连续的平台版本通常会添加新版本中不可用的新API。为了指示哪些API可用，每个平台版本指定一个API级别。例如，Android 1.0是API级别1，Android 4.4是API级别19。 API级别允许使用清单标记及其minSdkVersion属性来声明应用程序兼容的最低版本。例如，日历提供程序API已添加到Android 4.0（API级别14）中。如果应用无法在没有这些API的情况下运行，您应该将API级别14声明为应用的最低支持版本。 该minSdkVersion属性声明了您的应用程序兼容的最低版本，并且该targetSdkVersion属性声明了对应用程序进行了优化的最高版本。但是，请注意元素中的属性被build.gradle文件中的相应属性覆盖。因此，如果使用Android Studio，则必须在其中指定值minSdkVersion和 targetSdkVersion值： 123456789ndroid &#123; defaultConfig &#123; applicationId&apos;com.example.myapp &apos; //定义运行应用程序所需的最低API级别。 minSdkVersion 15 //指定用于测试应用程序的API级别。 targetSdkVersion 26 ... &#125;&#125; Android的每个后续版本都提供了使用以前平台版本的API构建的应用程序的兼容性，因此，在使用记录的Android API时，应用程序应始终与未来版本的Android兼容。 注意： 该targetSdkVersion属性不会阻止您的应用程序安装在高于指定值的平台版本上，但它很重要，因为它向系统指示您的应用程序是否应继承新版本中的行为更改。如果没有更新 targetSdkVersion到最新版本，则系统会假定您的应用在最新版本上运行时需要一些向后兼容的行为。例如，在Android 4.4的行为更改中，使用AlarmManagerAPI 创建的警报现在默认为不精确，因此系统可以批量应用警报并保留系统电源，但如果您的目标API级别保持系统以前的API行为低于“19”。 屏幕配置 Android可在各种尺寸的设备上运行，从手机到平板电脑和电视。为了按照屏幕类型对设备进行分类，Android为每个设备定义了两个特征：屏幕大小（屏幕的物理大小）和屏幕密度（屏幕上像素的物理密度，称为DPI）。为了简化不同的配置，Android将这些变体概括为多个组，使他们更容易定位： 四种广义尺寸：小，正常，大和xlarge。 还有几种广义密度：mdpi（中等），hdpi（高），xhdpi（超高），xxhdpi（超高）以及其他。 默认情况下，应用程序与所有屏幕尺寸和密度兼容，因为系统会根据每个屏幕的需要对UI布局和图像资源进行适当调整。但是，应该通过针对不同的屏幕尺寸添加专门的布局并优化通用屏幕密度的位图图像，优化每种屏幕配置的用户体验。 屏幕兼容性概述 Android应用可能会运行在不同屏幕尺寸和密度的设备上。Android系统对不同痛的设备提供了同意开发环境，可以处理大多数的适配，从而将应用的界面调整为适应其显示的屏幕。并且，系统提供的API可用于控制应用适用于特定的屏幕尺寸和密度，以针对不同屏幕配置优化UI设计。虽然系统会对应用根据屏幕进行缩放和大小的调整，但是开发者也需针对屏幕尺寸和密度进行优化。 屏幕支持概览术语和概念 屏幕尺寸：按照屏幕对角测量的实际物理尺寸，通常Android将所有屏幕尺寸分为四种通用尺寸：小、正常、大和超大。 屏幕密度：屏幕物理区域中的像素密度；通常称为dpi(每英寸点数)。通常Android 将所有屏幕密度分组为六种通用密度： 低、中、高、超高、超超高和超超超高。 方向：从用户视角看屏幕方向，即横屏还是竖屏，分把表示屏幕的丛横比是宽还是高。注意，不同的设备默认以不同的方向操作，而且方向在运行时还可能回随着用户旋转设备而改变。 分辨率：屏幕上物理像素的总和。添加对多种屏幕的支持时， 应用不会直接使用分辨率；而只应关注通用尺寸和密度组指定的屏幕 尺寸及密度。 密度无关像素（dp）：在定义UI布局时应使用的虚拟像素单位，用于以密度无关方式表示布局维度或位置。密度无关像素等于160dpi屏幕上的一个物理像素，这是系统为“中”密度屏幕假设的基线密度。在运行时，系统更加使用中屏幕的密度按需以透明方式处理dp单位的任何缩放。dp单位转为屏幕像素的公式为：px = dp * (dpi/160)。在定义应用的 UI 时应始终使用 dp 单位 ，以确保在不同密度的屏幕上正常显示 UI。 支持的屏幕范围 Android 将实际屏幕尺寸和密度的范围 分为： 尺寸：小、正常、大和超大。 密度： ldpi（低）~120dpi mdpi（中）~160dpi hdpi（高）~240dpi xhdpi（超高）~320dpi xxhddpi（超超高）~480dpi xxxhdpi（超超超高）~640dpi 每种通用的屏幕尺寸都关联了系统定义的最低 分辨率。这些最小尺寸以“dp”单位表示 — 在定义布局时应使用相同的单位 — 这样系统无需担心屏幕密度的变化。 超大屏幕至少为 960dp x 720dp 大屏幕至少为 640dp x 480dp 正常屏幕至少为 470dp x 320dp 小屏幕至少为 426dp x 320dp 要针对不同的屏幕尺寸和密度优化应用的 UI，可为任何通用的尺寸和密度提供 备用资源。 通常，应为某些不同的屏幕尺寸提供替代布局，为不同的屏幕密度提供替代位图图像。 在运行时，系统会根据当前设备屏幕的通用 尺寸或密度对应用使用适当的资源。 但是无需为所有屏幕尺寸和 密度的组合提供备用资源。 系统提供强大的兼容性功能，可处理在任何设备屏幕上 渲染应用的大多数工作，前提是您已经使用 可以适当调整大小的技术实现 UI。 密度独立性 应用显示在密度不同的屏幕上时，如果它保持用户界面元素的物理尺寸（从 用户的视角），便可实现“密度独立性” 。保持密度独立性很重要，因为如果没有此功能，UI 元素（例如 按钮）在低密度屏幕上看起来较大，在高密度屏幕上看起来较小。这些 密度相关的大小变化可能给应用布局和易用性带来问题。图 2 和 3 分别显示了应用不提供密度独立性和 提供密度独立性时的差异。 Android 系统可帮助您的应用以两种方式实现密度独立性： 系统根据当前屏幕密度扩展 dp 单位数 系统在必要时可根据当前屏幕 密度将可绘制对象资源扩展到适当的大小。 文本视图和位图可绘制对象具有以像素（px 单位）指定的尺寸，因此视图的物理尺寸在低密度屏幕上更大，在高密度 屏幕上更小。这是因为，虽然实际屏幕尺寸可能相同，但高密度屏幕 的每英寸像素更多（同样多的像素在一个更小的区域内）。布局 尺寸以密度独立的像素（dp 单位）指定。由于 密度独立像素的基线是中密度屏幕，因此具有中密度屏幕的设备看起来 与图低密度屏幕上一样。但对于低密度和高密度屏幕，系统 将分别增加和减少密度独立像素值，以适应 屏幕。 大多数情况下，确保应用中的屏幕独立性很简单，只需以适当的密度独立像素（dp 单位）或 &quot;wrap_content&quot; 指定所有 布局尺寸值。系统然后根据适用于当前屏幕密度的缩放比例适当地缩放位图可绘制对象，以 适当的大小显示。 但位图缩放可能导致模糊或像素化位图。为避免这些伪影，应为 不同的密度提供替代的位图资源。例如，应为高密度 屏幕提供分辨率较高的位图，然后系统对中密度 屏幕将使用这些位图，而无需调整位图大小。 支持多种密度概述 Android 支持多种屏幕的基础是它能够管理针对当前屏幕配置 以适当方式渲染应用的布局和位图 可绘制对象。系统可处理大多数工作，通过适当地 缩放布局以适应屏幕尺寸/密度和根据屏幕密度缩放位图可绘制对象 ，在每种屏幕配置中渲染您的应用。 但是为了更适当的处理不同屏幕配置，还应该： 在清单文件中显示声明你的应用支持哪些屏幕尺寸，要声明应用支持的屏幕尺寸，应在清单文件中包含元素。 为不同屏幕尺寸提供不同的布局，可用于提供尺寸特定资源的配置限定符包括 small、normal、large 和 xlarge。例如，超大屏幕的布局应使用 layout-xlarge/。 从 Android 3.2（API 级别 13）开始，以上尺寸组已弃用，您 应改为使用 sw&lt;N&gt;dp 配置限定符来定义布局资源 可用的最小宽度。例如，如果多窗格平板电脑布局 需要至少 600dp 的屏幕宽度，应将其放在 layout-sw600dp/ 中 。 为不同屏幕密度提供不同的位图可绘制对象 ，Android 会缩放位图可绘制对象（.png、.jpg 和 .gif 文件）和九宫格可绘制对象（.9.png 文件），使它们以适当的 物理尺寸显示在每部设备上。 例如，如果您的应用只为 基线中密度屏幕 (mdpi) 提供位图可绘制对象，则在高密度 屏幕上会增大位图，在低密度屏幕上会缩小位图。这种缩放可能在 位图中造成伪影。为确保位图的最佳显示效果，应针对 不同屏幕密度加入不同分辨率的替代版本。 注意：将您的所有启动器图标放在 res/mipmap-[density]/ 文件夹中，而非 res/drawable-[density]/ 文件夹中。无论安装应用的设备屏幕分辨率如何，Android 系统都会将资源保留在这些密度特定的文件夹中，例如 mipmap-xxxhdpi。此 行为可让启动器应用为您的应用选择要显示在主 屏幕上的最佳分辨率图标。 系统对应用适配的方法 系统使用适当的备用资源：根据当前屏幕的尺寸和密度，系统将使用您的应用中提供的任何尺寸和 密度特定资源。例如，如果设备有 高密度屏幕，并且应用请求可绘制对象资源，系统将查找 与设备配置最匹配的可绘制对象资源目录。根据可用的其他 备用资源，包含 hdpi 限定符（例如 drawable-hdpi/）的资源目录可能是最佳匹配项，因此系统将使用此 目录中的可绘制对象资源。 没有匹配的资源，系统将使用默认资源：并按需要向上 或向下扩展，以匹配当前的屏幕尺寸和密度。 “默认”资源是指未标记配置限定符的资源。例如，drawable/ 中的资源是默认可绘制资源。 系统假设默认资源设计用于基线屏幕尺寸和密度，即 正常屏幕尺寸和中密度。 因此，系统对于高密度屏幕向上扩展默认密度 资源，对于低密度屏幕向下扩展。当系统查找密度特定的资源但在 密度特定目录中未找到时，不一定会使用默认资源。系统在缩放时可能 改用其他密度特定资源提供更好的 效果。例如，查找低密度资源但该资源不可用时， 系统会缩小资源的高密度版本，因为 系统可轻松以 0.5 为系数将高密度资源缩小至低密度资源，与以 0.75 为系数 缩小中密度资源相比，伪影更少。 ####使用配置限定符 配置限定符使用方式 在项目的 res/目录中新建一个目录，并使用以下 格式命名： &lt;resources_name&gt;-&lt;qualifier&gt; &lt;resources_name&gt; 是标准资源名称（例如 drawable 或 layout）。 &lt;qualifier&gt; 是下表 1 中的配置限定符，用于指定 要使用这些资源的屏幕配置（例如 hdpi 或 xlarge）。可以一次使用多个 &lt;qualifier&gt; — 只需使用短划线分隔每个 限定符。 将适当的配置特定资源保存在此新目录下。这些资源 文件的名称必须与默认资源文件完全一样。 配置限定符表 | 限定符 | 说明 | || —————– | ———————————————————— | —- || small | 适用于小尺寸屏幕的资源。 | || normal | 适用于正常尺寸屏幕的资源。（这是基线尺寸。） | || large | 适用于大尺寸屏幕的资源。 | || xlarge | 适用于超大尺寸屏幕的资源。 | || ldpi | 适用于低密度 (ldpi) 屏幕 (~120dpi) 的资源。 | || mdpi | 适用于中密度 (mdpi) 屏幕 (~160dpi) 的资源。（这是基线 密度。） | || hdpi | 适用于高密度 (hdpi) 屏幕 (~240dpi) 的资源。 | || xhdpi | 适用于超高密度 (xhdpi) 屏幕 (~320dpi) 的资源。 | || xxhdpi | 适用于超超高密度 (xxhdpi) 屏幕 (~480dpi) 的资源。 | || xxxhdpi | 适用于超超超高密度 (xxxhdpi) 屏幕 (~640dpi) 的资源。此限定符仅适用于 启动器图标，请参阅上面的注。 | || nodpi | 适用于所有密度的资源。这些是密度独立的资源。不管当前屏幕的密度如何，系统都不会 缩放以此限定符标记的资源。 | || tvdpi | 适用于密度介于 mdpi 和 hdpi 之间屏幕（约为 213dpi）的资源。它并不是 “主要”密度组，主要用于电视，而大多数应用都不 需要它 — 对于大多数应用而言，提供 mdpi 和 hdpi 资源便已足够，系统将根据需要对其进行 缩放。如果发现必须提供 tvdpi 资源，应以 1.33*mdpi 的系数 调整其大小。例如，mdpi 屏幕的 100px x 100px 图像应该相当于 tvdpi 的 133px x 133px。 | || land | 适用于横屏（长宽比）的资源。 | || port | 适用于竖屏（高宽比）的资源。 | || long 纵横比 | 适用于纵横比明显高于或宽于（分别在竖屏 或横屏时）基线屏幕配置的屏幕的资源。 | || notlong | 适用于使用纵横比类似于基线屏幕 配置的屏幕的资源。 | | 设计替代布局和可绘制对象 替代布局 在小屏幕上测试时，可能会发现您的布局不太适合 屏幕。例如，小屏幕设备的屏幕宽度可能无法容纳一排 按钮。在此情况下，您应该为小屏幕提供调整 按钮大小或位置的替代布局。 在超大屏幕上测试时，可能会发现您的布局无法 有效地利用大屏幕，并且明显拉伸填满屏幕。 在此情况下，应该为超大屏幕提供替代布局，以提供 针对大屏幕（例如平板电脑）优化、重新设计的 UI。 虽然应用不使用替代布局也能在大屏幕上正常运行，但 必须让用户感觉您的应用看起来像是专为其设备而设计。如果 UI 明显拉伸，用户很可能对 应用体验不满意。 对比横屏测试和竖屏测试时 可能会发现，竖屏时置于底部的 UI 在横屏时应位于屏幕右侧。 应确保布局 适应小屏幕（让用户能实际使用您的应用） 已针对大屏幕优化，可以利用其他屏幕空间 已同时针对横屏和竖屏方向优化 替代可绘制对象 基本上每个应用都应该具有不同密度的替代可绘制对象 资源，因为基本上每个应用都有启动器图标，而且该图标应该在 所有屏幕密度中看起来都很好。同样，如果您的应用中包含其他位图可绘制对象（例如 应用中的菜单图标或其他图形），则应该为不同密度提供替代版本或 每种密度一个版本。 要为不同的密度创建替代位图可绘制对象，应遵循六种通用密度之间的 3:4:6:8:12:16 缩放]]></content>
      <categories>
        <category>guide</category>
      </categories>
      <tags>
        <tag>guide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[API Guide之App Resources]]></title>
    <url>%2F2018%2F03%2F20%2FAPI-Guide%E4%B9%8BApp-Resources%2F</url>
    <content type="text"><![CDATA[Providing Resources提供资源 App应该始终外部化应用资源，如图像和代码中的字符串资源，这样有利于单独维护这些资源。并且应该将资源分组到专门命名的资源目录中，以便为特定的设备提供备用资源。在运行时，Android 会根据当前配置使用适当的资源。例如，您可能需要根据屏幕尺寸提供不同的 UI 布局，或者根据语言设置提供不同的字符串。 资源类型目录 项目 res/ 目录内支持的资源目录（表1）。 目录 资源类型 animator/ 用于定义属性动画的 XML 文件。 anim/ 定义渐变动画的 XML 文件。（属性动画也可以保存在此目录中，但是为了区分这两种类型，属性动画首选 animator/ 目录。） color/ 用于定义颜色状态列表的 XML 文件。请参阅颜色状态列表资源 drawable/ 位图文件（.png、.9.png、.jpg、.gif）或编译为以下可绘制对象资源子类型的 XML 文件：位图文件九宫格（可调整大小的位图）状态列表形状动画可绘制对象其他可绘制对象请参阅 可绘制对象资源。 mipmap/ 适用于不同启动器图标密度的可绘制对象文件。如需了解有关使用 mipmap/ 文件夹管理启动器图标的详细信息，请参阅管理项目概览。 layout/ 用于定义用户界面布局的 XML 文件。 请参阅布局资源。 menu/ 用于定义应用菜单（如选项菜单、上下文菜单或子菜单）的 XML 文件。请参阅菜单资源。 raw/ 要以原始形式保存的任意文件。要使用原始 InputStream 打开这些资源，请使用资源 ID（即 R.raw.*filename*）调用 Resources.openRawResource()。但是，如需访问原始文件名和文件层次结构，则可以考虑将某些资源保存在 assets/ 目录下（而不是 res/raw/）。assets/ 中的文件没有资源 ID，因此您只能使用 AssetManager 读取这些文件。 values/ 包含字符串、整型数和颜色等简单值的 XML 文件。其他 res/ 子目录中的 XML 资源文件是根据 XML 文件名定义单个资源，而 values/ 目录中的文件可描述多个资源。对于此目录中的文件，&lt;resources&gt; 元素的每个子元素均定义一个资源。例如，&lt;string&gt; 元素创建 R.string 资源，&lt;color&gt; 元素创建 R.color 资源。由于每个资源均用其自己的 XML 元素定义，因此您可以根据自己的需要命名文件，并将不同的资源类型放在一个文件中。但是，为了清晰起见，您可能需要将独特的资源类型放在不同的文件中。 例如，对于可在此目录中创建的资源，下面给出了相应的文件名约定：arrays.xml，用于资源数组（类型化数组）。colors.xml：颜色值。dimens.xml：尺寸值。strings.xml：字符串值。styles.xml：样式。请参阅字符串资源、样式资源和更多资源类型。 xml/ 可以在运行时通过调用 Resources.getXML() 读取的任意 XML 文件。各种 XML 配置文件（如可搜索配置）都必须保存在此处。 提供备用资源 几乎每个应用都应提供备用资源以支持特定的设备配置。 为一组资源指定特定于配置的备用资源： 在res/中创建一个以&lt;resources_name&gt;-&lt;config_qualifier&gt;形式命名的新目录。 &lt;resources_name&gt; 是相应默认资源的目录名称（如表 1 中所定义）。 是指定要使用这些资源的各个配置的名称（如表 2 中所定义）。 您可以追加多个 。以短划线将其分隔。 注意：追加多个限定符时，必须按照表 2 中列出的相同顺序放置它们。如果限定符的顺序错误，则该资源将被忽略。 将相应的备用资源保存在此新目录下。这些资源文件的名称必须与默认资源文件完全一样。 例如，以下是一些默认资源和备用资源： 1234567res/ drawable/ icon.png background.png drawable-hdpi/ icon.png background.png hdpi 限定符表示该目录中的资源适用于屏幕密度较高的设备。其中每个可绘制对象目录中的图像已针对特定的屏幕密度调整大小，但是文件名完全相同。 这样一来，用于引用 icon.png 或 background.png 图像的资源 ID 始终相同，但是 Android 会通过将设备配置信息与资源目录名称中的限定符进行比较，选择最符合当前设备的各个资源版本。 Android 支持若干配置限定符，您可以通过使用短划线分隔每个限定符，向一个目录名称添加多个限定符。表 2 按优先顺序列出了有效的配置限定符；如果对资源目录使用多个限定符，则必须按照表中列出的顺序将它们添加到目录名称。 配置限定符名称(表2) 配置 限定符值 说明 MCC 和 MNC 示例：mcc310`mcc310-mnc004mcc208-mnc00`等等 移动国家代码 (MCC)，（可选）后跟设备 SIM 卡中的移动网络代码 (MNC)。例如，mcc310 是指美国的任一运营商，mcc310-mnc004 是指美国的 Verizon 公司，mcc208-mnc00 是指法国的 Orange 公司。如果设备使用无线电连接（GSM 手机），则 MCC 和 MNC 值来自 SIM 卡。也可以单独使用 MCC（例如，将国家/地区特定的合法资源包括在应用中）。如果只需根据语言指定，则改用“语言和区域”限定符（稍后进行介绍）。 如果决定使用 MCC 和 MNC 限定符，请谨慎执行此操作并测试限定符是否按预期工作。另请参阅配置字段 mcc 和 mnc，这两个字段分别表示当前的移动国家代码和移动网络代码。 语言和区域 示例：en`fren-rUS`等 语言通过由两个字母组成的 ISO 639-1 语言代码定义，可以选择后跟两个字母组成的 ISO 3166-1-alpha-2 区域码（前带小写字母“r”）。这些代码不区分大小写；r 前缀用于区分区域码。 不能单独指定区域。如果用户更改系统设置中的语言，它有可能在应用生命周期中发生改变。 如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。有关针对其他语言本地化应用的完整指南，请参阅本地化。另请参阅 locale 配置字段，该字段表示当前的语言区域。 布局方向 ldrtl`ldltr` 应用的布局方向。ldrtl 是指“布局方向从右到左”。ldltr 是指“布局方向从左到右”，这是默认的隐式值。它适用于布局、图片或值等任何资源。例如，若要针对阿拉伯语提供某种特定布局，并针对任何其他“从右到左”语言（如波斯语或希伯来语）提供某种通用布局，则可编码如下：res/ layout/ main.xml (Default layout) layout-ar/ main.xml (Specific layout for Arabic) layout-ldrtl/ main.xml (Any &quot;right-to-left&quot; language, except for Arabic, because the &quot;ar&quot; language qualifier has a higher precedence.)注：要为应用启用从右到左的布局功能，必须将 supportsRtl 设置为 &quot;true&quot;，并将 targetSdkVersion 设置为 17 或更高版本。此项为 API 级别 17 中新增配置。 smallestWidth sw&lt;N&gt;dp示例：sw320dp`sw600dpsw720dp`等等 屏幕的基本尺寸，由可用屏幕区域的最小尺寸指定。 具体来说，设备的 smallestWidth 是屏幕可用高度和宽度的最小尺寸（您也可以将其视为屏幕的“最小可能宽度”）。无论屏幕的当前方向如何，您均可使用此限定符确保应用 UI 的可用宽度至少为 &lt;N&gt;dp。例如，如果布局要求屏幕区域的最小尺寸始终至少为 600dp，则可使用此限定符创建布局资源 res/layout-sw600dp/。仅当可用屏幕的最小尺寸至少为 600dp 时，系统才会使用这些资源，而不考虑 600dp 所代表的边是用户所认为的高度还是宽度。smallestWidth 是设备的固定屏幕尺寸特性；设备的 smallestWidth 不会随屏幕方向的变化而改变。设备的 smallestWidth 将屏幕装饰元素和系统 UI 考虑在内。例如，如果设备的屏幕上有一些永久性 UI 元素占据沿 smallestWidth 轴的空间，则系统会声明 smallestWidth 小于实际屏幕尺寸，因为这些屏幕像素不适用于您的 UI。 因此，使用的值应该是布局所需要的实际最小尺寸（通常，无论屏幕的当前方向如何，此值都是布局支持的“最小宽度”）。以下是一些可用于普通屏幕尺寸的值：320，适用于屏幕配置如下的设备：240x320 ldpi（QVGA 手机）320x480 mdpi（手机）480x800 hdpi（高密度手机）480，适用于 480x800 mdpi 之类的屏幕（平板电脑/手机）。600，适用于 600x1024 mdpi 之类的屏幕（7 英寸平板电脑）。720，适用于 720x1280 mdpi 之类的屏幕（10 英寸平板电脑）。应用为多个资源目录提供不同的 smallestWidth 限定符值时，系统会使用最接近（但未超出）设备 smallestWidth 的值。此项为 API 级别 13 中新增配置。另请参阅 android:requiresSmallestWidthDp 属性和 smallestScreenWidthDp 配置字段，前者声明与应用兼容的最小 smallestWidth；后者存放设备的 smallestWidth 值。如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅支持多种屏幕开发者指南。 可用宽度 w&lt;N&gt;dp示例：w720dp等 指定资源应该使用的最小可用屏幕宽度，以 dp 为单位，由 &lt;N&gt; 值定义。在横向和纵向之间切换时，为了匹配当前实际宽度，此配置值也会随之发生变化。应用为多个资源目录提供不同的此配置值时，系统会使用最接近（但未超出）设备当前屏幕宽度的值。 此处的值考虑到了屏幕装饰元素，因此如果设备显示屏的左边缘或右边缘上有一些永久性 UI 元素，考虑到这些 UI 元素，它会使用小于实际屏幕尺寸的宽度值，这样会减少应用的可用空间。此项为 API 级别 13 中新增配置。另请参阅 screenWidthDp 配置字段，该字段存放当前屏幕宽度。如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅支持多种屏幕开发者指南。 可用高度 h&lt;N&gt;dp示例：h720dp等 指定资源应该使用的最小可用屏幕高度，以“dp”为单位，由 &lt;N&gt; 值定义。 在横向和纵向之间切换时，为了匹配当前实际高度，此配置值也会随之发生变化。应用为多个资源目录提供不同的此配置值时，系统会使用最接近（但未超出）设备当前屏幕高度的值。 此处的值考虑到了屏幕装饰元素，因此如果设备显示屏的上边缘或下边缘有一些永久性 UI 元素，考虑到这些 UI 元素，同时为减少应用的可用空间，它会使用小于实际屏幕尺寸的高度值。 非固定的屏幕装饰元素（例如，全屏时可隐藏的手机状态栏）并不在考虑范围内，标题栏或操作栏等窗口装饰也不在考虑范围内，因此应用必须准备好处理稍小于其所指定值的空间。此项为 API 级别 13 中新增配置。另请参阅 screenHeightDp 配置字段，该字段存放当前屏幕宽度。如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅支持多种屏幕开发者指南。 屏幕尺寸 small`normallargexlarge` small：尺寸类似于低密度 QVGA 屏幕的屏幕。小屏幕的最小布局尺寸约为 320x426 dp 单位。例如，QVGA 低密度屏幕和 VGA 高密度屏幕。normal：尺寸类似于中等密度 HVGA 屏幕的屏幕。标准屏幕的最小布局尺寸约为 320x470 dp 单位。例如，WQVGA 低密度屏幕、HVGA 中等密度屏幕、WVGA 高密度屏幕。large：尺寸类似于中等密度 VGA 屏幕的屏幕。 大屏幕的最小布局尺寸约为 480x640 dp 单位。 例如，VGA 和 WVGA 中等密度屏幕。xlarge：明显大于传统中等密度 HVGA 屏幕的屏幕。超大屏幕的最小布局尺寸约为 720x960 dp 单位。在大多数情况下，屏幕超大的设备体积过大，不能放进口袋，最常见的是平板式设备。 API 级别 9 中的新增配置。**注：使用尺寸限定符并不表示资源仅适用于该尺寸的屏幕。 如果没有为备用资源提供最符合当前设备配置的限定符，则系统可能使用其中最匹配的资源。注意：如果所有资源均使用大于当前屏幕的尺寸限定符，则系统不*会使用这些资源，并且应用在运行时将会崩溃（例如，如果所有布局资源均用 xlarge 限定符标记，但设备是标准尺寸的屏幕）。此项为 API 级别 4 中新增配置。*如需了解详细信息，请参阅支持多种屏幕。另请参阅 screenLayout 配置字段，该字段表示屏幕是小尺寸、标准尺寸还是大尺寸。 屏幕纵横比 long`notlong` long：宽屏，如 WQVGA、WVGA、FWVGAnotlong：非宽屏，如 QVGA、HVGA 和 VGA此项为 API 级别 4 中新增配置。它完全基于屏幕的纵横比（宽屏较宽），而与屏幕方向无关。另请参阅 screenLayout 配置字段，该字段指示屏幕是否为宽屏。 圆形屏幕 round`notround` round：圆形屏幕，例如圆形可穿戴式设备notround：方形屏幕，例如手机或平板电脑此项为 API 级别 23 中新增配置。另请参阅 isScreenRound() 配置方法，其指示屏幕是否为宽屏。 屏幕方向 port`land` port：设备处于纵向（垂直）land：设备处于横向（水平）如果用户旋转屏幕，它有可能在应用生命周期中发生改变。 如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。另请参阅 orientation 配置字段，该字段指示当前的设备方向。 UI 模式 car`desktelevisionappliancewatch ` car：设备正在车载手机座上显示desk：设备正在桌面手机座上显示television：设备正在电视上显示，为用户提供“十英尺”体验，其 UI 位于远离用户的大屏幕上，主要面向方向键或其他非指针式交互appliance：设备用作不带显示屏的装置watch：设备配有显示屏，戴在手腕上此项为 API 级别 8 中新增配置，API 13 中新增电视配置，API 20 中新增手表配置。如需了解应用在设备插入手机座或从中移除时的响应方式，请阅读确定并监控插接状态和类型。如果用户将设备放入手机座中，它有可能在应用生命周期中发生改变。 可以使用 UiModeManager 启用或禁用其中某些模式。如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。 夜间模式 night`notnight` night：夜间notnight：白天此项为 API 级别 8 中新增配置。如果夜间模式停留在自动模式（默认），它有可能在应用生命周期中发生改变。在这种情况下，该模式会根据当天的时间进行调整。 可以使用 UiModeManager 启用或禁用此模式。如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。 屏幕像素密度 (dpi) ldpi…nodpi`tvdpianydpi` ldpi：低密度屏幕；约为 120dpi。mdpi：中等密度（传统 HVGA）屏幕；约为 160dpi。hdpi：高密度屏幕；约为 240dpi。xhdpi：超高密度屏幕；约为 320dpi。此项为 API 级别 8 中新增配置xxhdpi：超超高密度屏幕；约为 480dpi。此项为 API 级别 16 中新增配置xxxhdpi：超超超高密度屏幕使用（仅限启动器图标，请参阅“支持多种屏幕”中的注释）；约为 640dpi。 此项为 API 级别 18 中新增配置nodpi：它可用于您不希望缩放以匹配设备密度的位图资源。tvdpi：密度介于 mdpi 和 hdpi 之间的屏幕；约为 213dpi。它并不是“主要”密度组， 主要用于电视，而大多数应用都不需要它。对于大多数应用而言，提供 mdpi 和 hdpi 资源便已足够，系统将根据需要对其进行缩放。此项为 API 级别 13 中新增配置anydpi：此限定符适合所有屏幕密度，其优先级高于其他限定符。 这对于矢量可绘制对象很有用。 此项为 API 级别 21 中新增配置六个主要密度之间的缩放比为 3:4:6:8:12:16（忽略 tvdpi 密度）。因此，9x9 (ldpi) 位图相当于 12x12 (mdpi)、18x18 (hdpi)、24x24 (xhdpi) 位图，依此类推。如果您认为图像资源在电视或其他某些设备上呈现的效果不够好，而想尝试使用 tvdpi 资源，则缩放比例为 1.33*mdpi。例如，mdpi 屏幕的 100px x 100px 图像应该相当于 tvdpi 的133px x 133px。注：使用密度限定符并不表示资源仅适用于该密度的屏幕。 如果没有为备用资源提供最符合当前设备配置的限定符，则系统可能使用其中最匹配的资源。如需了解有关如何处理不同屏幕密度以及 Android 如何缩放位图以适应当前密度的详细信息，请参阅支持多种屏幕。 notouch`finger` notouch：设备没有触摸屏。finger：设备有一个专供用户通过手指直接与其交互的触摸屏。另请参阅 touchscreen 配置字段，该字段指示设备上的触摸屏类型。 键盘可用性 keysexposed`keyshiddenkeyssoft` keysexposed：设备具有可用的键盘。如果设备启用了软键盘（不无可能），那么即使硬键盘没有展示给用户，哪怕设备没有硬键盘，也可以使用此限定符。 如果没有提供或已经禁用软键盘，则只有在显示硬键盘时才会使用此限定符。keyshidden：设备具有可用的硬键盘，但它处于隐藏状态，且设备没有启用软键盘。keyssoft：设备已经启用软键盘（无论是否可见）。如果提供了 keysexposed 资源，但未提供 keyssoft 资源，那么只要系统已经启用软键盘，就会使用keysexposed 资源，而不考虑键盘是否可见。如果用户打开硬键盘，它有可能在应用生命周期中发生改变。 如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。另请参阅配置字段 hardKeyboardHidden 和 keyboardHidden，这两个字段分别指示硬键盘的可见性和任何一种键盘（包括软键盘）的可见性。 主要文本输入法 nokeys`qwerty12key` nokeys：设备没有用于文本输入的硬按键。qwerty：设备具有标准硬键盘（无论是否对用户可见）。12key：设备具有 12 键硬键盘（无论是否对用户可见）。另请参阅 keyboard 配置字段，该字段指示可用的主要文本输入法。 导航键可用性 navexposed`navhidden` navexposed：导航键可供用户使用。navhidden：导航键不可用（例如，位于密封盖子后面）。如果用户显示导航键，它有可能在应用生命周期中发生改变。 如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。另请参阅 navigationHidden 配置字段，该字段指示导航键是否处于隐藏状态。 主要非触摸导航方法 nonav`dpadtrackballwheel` nonav：除了使用触摸屏以外，设备没有其他导航设施。dpad：设备具有用于导航的方向键。trackball：设备具有用于导航的轨迹球。wheel：设备具有用于导航的方向盘（不常见）。另请参阅 navigation 配置字段，该字段指示可用的导航方法类型。 平台版本（API 级别） 示例：v3`v4v7`等等 设备支持的 API 级别。例如，v1 对应于 API 级别 1（带有 Android 1.0 或更高版本系统的设备），v4 对应于 API 级别 4（带有 Android 1.6 或更高版本系统的设备）。如需了解有关这些值的详细信息，请参阅 Android API 级别文档。 限定符命名规则 用配置限定符名称的规则： 可以为单组资源指定多个限定符，并使用短划线分隔。例如，drawable-en-rUS-land 适用于横排美国英语设备。 这些限定符必须遵循表 2中列出的顺序。例如： 错误：drawable-hdpi-port/ 正确：drawable-port-hdpi/ 不能嵌套备用资源目录。例如，您不能拥有 res/drawable/drawable-en/。 值不区分大小写。在处理之前，资源编译器会将目录名称转换为小写，以避免不区分大小写的文件系统出现问题。 名称中使用的任何大写字母只是为了便于认读。 对于每种限定符类型，仅支持一个值。例如，若要对西班牙语和法语使用相同的可绘制对象文件，则您肯定不能拥有名为 drawable-rES-rFR/ 的目录，而是需要两个包含相应文件的资源目录，如 drawable-rES/ 和 drawable-rFR/。然而，实际上您无需将相同的文件都复制到这两个位置。相反，您可以创建指向资源的别名。 请参阅下面的创建别名资源。 创建别名资源 如果想将某一资源用于多种设备配置（但是不想作为默认资源提供），则无需将同一资源放入多个备用资源目录中。 而是可以（在某些情况下）创建备用资源，充当保存在默认资源目录下的资源的别名。（注：并非所有资源都会提供相应机制让您创建指向其他资源的别名。 特别是，xml/ 目录中的动画资源、菜单资源、原始资源以及其他未指定资源均不提供此功能。） 例如，假设您有一个应用图标 icon.png，并且需要不同语言区域的独特版本。 但是，加拿大英语和加拿大法语这两种语言区域需要使用同一版本。 您可能会认为需要将相同的图像复制到加拿大英语和加拿大法语对应的资源目录中，但事实并非如此。 相反，可以将用于二者的图像另存为 icon_ca.png（除 icon.png 以外的任何名称），并将其放入默认 res/drawable/ 目录中。然后，在 res/drawable-en-rCA/ 和 res/drawable-fr-rCA/ 中创建 icon.xml 文件，使用 &lt;bitmap&gt; 元素引用 icon_ca.png 资源。这样，您只需存储 PNG 文件的一个版本和两个指向该版本的小型 XML 文件。（XML 文件示例如下。） 可绘制对象 要创建指向现有可绘制对象的别名，请使用 元素。例如： 123&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;bitmap xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:src=&quot;@drawable/icon_ca&quot; /&gt; 如果将此文件另存为 icon.xml（例如，在备用资源目录中，另存为 res/drawable-en-rCA/），则会编译到可作为 R.drawable.icon 引用的资源中，但实际上它是 R.drawable.icon_ca 资源（保存在 res/drawable/ 中）的别名。 布局 要创建指向现有布局的别名，请使用包装在 &lt;merge&gt; 中的 &lt;include&gt; 元素。例如： 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;merge&gt; &lt;include layout=&quot;@layout/main_ltr&quot;/&gt;&lt;/merge&gt; 如果将此文件另存为 main.xml，则会编译到可作为 R.layout.main 引用的资源中，但实际上它是 R.layout.main_ltr 资源的别名。 字符串和其他简单值 要创建指向现有字符串的别名，只需将所需字符串的资源 ID 用作新字符串的值即可。例如： 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;string name=&quot;hello&quot;&gt;Hello&lt;/string&gt; &lt;string name=&quot;hi&quot;&gt;@string/hello&lt;/string&gt;&lt;/resources&gt; 其他简单值的原理相同。 例如，颜色： 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;color name=&quot;red&quot;&gt;#f00&lt;/color&gt; &lt;color name=&quot;highlight&quot;&gt;@color/red&lt;/color&gt;&lt;/resources&gt; 利用资源提供最佳设备兼容性 要使应用支持多种设备配置，则务必为应用使用的每种资源类型提供默认资源，这一点非常重要。\ 例如，如果应用支持多种语言，请始终包含不带语言和区域限定符的 values/ 目录（用于保存字符串）。相反，如果您将所有字符串放入带有语言和区域限定符的目录中，则在语言设置不支持您的字符串的设备上运行应用时，应用将会崩溃。 但是，只要提供默认 values/ 资源，应用就会正常运行（即使用户不理解该语言，这也总比崩溃要好）。 如果根据屏幕方向提供不同的布局资源，则应选择一个方向作为默认方向。 例如，不要在 layout-land/ 和 layout-port/ 中分别提供横向和纵向的布局资源，而是保留其中之一作为默认设置，例如：layout/ 用于横向，layout-port/ 用于纵向。 提供默认资源至关重要，这不仅仅因为应用可能在超出预期的配置上运行，也因为新版 Android 有时会添加旧版本不支持的配置限定符。若要使用新的资源限定符，又希望维持对旧版 Android 的代码兼容性，则当旧版 Android 运行应用时，如果不提供默认资源，应用将会崩溃，这是因为它无法使用以新限定符命名的资源。例如，如果将 minSdkVersion 设置为 4，并使用夜间模式（night 或 notnight，API 级别 8 中新增配置）限定所有可绘制对象资源，则 API 级别 4 设备无法访问可绘制对象资源，而且会崩溃。在这种情况下，您可能希望 notnight 成为默认资源，为此，您应排除该限定符，使可绘制对象资源位于 drawable/ 或 drawable-night/ 中。 因此，为了提供最佳设备兼容性，请始终为应用正确运行所必需的资源提供默认资源。 然后，使用配置限定符为特定的设备配置创建备用资源。 这条规则有一个例外：如果应用的 minSdkVersion 为 4 或更高版本，则在提供带屏幕密度限定符的备用可绘制对象资源时，不需要默认可绘制对象资源。 即使没有默认可绘制对象资源，Android 也可以从备用屏幕密度中找到最佳匹配项并根据需要缩放位图。 但是，为了在所有类型的设备上提供最佳体验，您应该为所有三种类型的密度提供备用可绘制对象。 Android 如何查找最佳匹配资源 当请求要为其提供备用资源的资源时，Android 会根据当前的设备配置选择要在运行时使用的备用资源。为演示 Android 如何选择备用资源，假设以下可绘制对象目录分别包含相同图像的不同版本： 1234567drawable/drawable-en/drawable-fr-rCA/drawable-en-port/drawable-en-notouch-12key/drawable-port-ldpi/drawable-port-notouch-12key/ 同时，通过将设备配置与可用的备用资源进行比较，Android 从 drawable-en-port 中选择可绘制对象。假设设备配置如下： 语言区域 = en-GB 屏幕方向 = port 屏幕像素密度 = hdpi 触摸屏类型 = notouch 主要文本输入法 = 12key 系统使用以下逻辑决定要使用的资源： 淘汰与设备配置冲突的资源文件。 选择列表中（下一个）优先级最高的限定符。（先从 MCC 开始，然后下移。） 是否有资源目录包括此限定符? 若无，请返回到第 2 步，看看下一个限定符。（在该示例中，除非达到语言限定符，否则答案始终为“否”。） 若有，请继续执行第 4 步。 淘汰不含此限定符的资源目录。在该示例中，系统会淘汰所有不含语言限定符的目录。(例外：如果涉及的限定符是屏幕像素密度，则 Android 会选择最接近设备屏幕密度的选项。通常，Android 倾向于缩小大型原始图像，而不是放大小型原始图像。请参阅支持多种屏幕)。 返回并重复第 2 步、第 3 步和第 4 步，直到只剩下一个目录为止。在此示例中，屏幕方向是下一个判断是否匹配的限定符。因此，未指定屏幕方向的资源被淘汰： 尽管对所请求的每个资源均执行此程序，但是系统仍会对某些方面做进一步优化。 例如，系统一旦知道设备配置，即会淘汰可能永远无法匹配的备用资源。 比如说，如果配置语言是英语（“en”），则系统绝不会将语言限定符设置为非英语的任何资源目录包含在选中的资源池中（不过，仍会将不带语言限定符的资源目录包含在该池中）。 根据屏幕尺寸限定符选择资源时，如果没有更好的匹配资源，则系统将使用专为小于当前屏幕的屏幕而设计的资源（例如，如有必要，大尺寸屏幕将使用标准尺寸的屏幕资源）。 但是，如果唯一可用的资源大于当前屏幕，则系统不会使用这些资源，并且如果没有其他资源与设备配置匹配，应用将会崩溃（例如，如果所有布局资源均用 xlarge 限定符标记，但设备是标准尺寸的屏幕）。 注：限定符的优先顺序（表 2 中）比与设备完全匹配的限定符数量更加重要。例如，在上面的第 4 步中，列表剩下的最后选项包括三个与设备完全匹配的限定符（方向、触摸屏类型和输入法），而 drawable-en 只有一个匹配参数（语言）。但是，语言的优先顺序高于其他两个限定符，因此drawable-port-notouch-12key 被淘汰。 Accessing Resources访问资源 在应用中提供资源后（提供资源中对此做了阐述），可通过引用其资源 ID 来应用该资源。 所有资源 ID 都在您项目的 R 类中定义，后者由 aapt 工具自动生成。 编译应用时，aapt 会生成 R 类，其中包含您的 res/ 目录中所有资源的资源 ID。 每个资源类型都有对应的 R子类（例如，R.drawable 对应于所有可绘制对象资源），而该类型的每个资源都有对应的静态整型数（例如，R.drawable.icon）。这个整型数就是可用来检索资源的资源 ID。 尽管资源 ID 是在 R 类中指定的，但应该永远都不需要在其中查找资源 ID。 资源 ID 始终由以下部分组成： 资源类型：每个资源都被分到一个“类型”组中，例如 string、drawable 和 layout。 资源名称，它是不包括扩展名的文件名；或是 XML android:name 属性中的值，如果资源是简单值的话（例如字符串）。 访问资源的方法有两种： 在代码中：使用来自 R 类的某个子类的静态整型数，如：R.string.hello 在 XML 中：使用同样与您 R 类中定义的资源 ID 对应的特殊 XML 语法，如@string/hello。 ##在代码中访问资源 语法：[&lt;package_name&gt;.]R.&lt;resource_type&gt;.&lt;resource_name&gt; &lt;package_name&gt; 是资源所在包的名称（如果引用的资源来自您自己的资源包，则不需要）。 &lt;resource_type&gt; 是资源类型的 R 子类。 &lt;resource_name&gt; 是不带扩展名的资源文件名，或 XML 元素中的 android:name 属性值（如果资源是简单值） 用例：getWindow().setBackgroundDrawableResource(R.drawable.my_background_image) ; 在 XML 中访问资源 利用对现有资源的引用为某些 XML 属性和元素定义值。 语法：@[&lt;package_name&gt;:]&lt;resource_type&gt;/&lt;resource_name&gt; &lt;package_name&gt; 是资源所在包的名称（如果引用的资源来自相同的包，则不需要） &lt;resource_type&gt; 是资源类型的 R 子类 &lt;resource_name&gt; 是不带扩展名的资源文件名，或 XML 元素中的 android:name 属性值（如果资源是简单值）。 用例：在某些情况下，您必须使用资源作为 XML 中的值（例如，对小部件应用可绘制图像），但您也可以在 XML 中任何接受简单值的地方使用资源。 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;color name=&quot;opaque_red&quot;&gt;#f00&lt;/color&gt; &lt;string name=&quot;hello&quot;&gt;Hello!&lt;/string&gt;&lt;/resources&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;EditText xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:textColor=&quot;@color/opaque_red&quot; android:text=&quot;@string/hello&quot; /&gt; 引用样式属性：通过样式属性资源在当前应用的风格主题中引用某个属性的值。 通过引用样式属性，可以不采用为 UI 元素提供硬编码值这种方式，而是通过为 UI 元素设置样式，使其匹配当前风格主题提供的标准变型来定制这些元素的外观。引用样式属性的实质作用是，“在当前风格主题中使用此属性定义的样式”。要引用样式属性，名称语法几乎与普通资源格式完全相同，只不过将 at 符号 (@) 改为问号 (?)，资源类型部分为可选项。 例如： ?&lt;package_name&gt;:/&lt;resource_name&gt; 访问平台资源 Android 包含许多标准资源，例如样式、风格主题和布局。要访问这些资源，可以通过 android 包名称限定您的资源引用。例如，将 Android 提供的布局资源用于 ListAdapter 中的列表项：setListAdapter(new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, myarray)); Handing Runtime Change处理运行时变更 有些设备配置可能会在运行时发生变化（例如屏幕方向、键盘可用性及语言）。发生这种变化时，Android 会重启正在运行的 Activity（先后调用 onDestroy() 和 onCreate()）。重启行为旨在通过利用与新设备配置匹配的备用资源自动重新加载您的应用，来帮助它适应新配置。 Activity必须通过常规的Activity生命周期恢复以前的状态，在Activity生命周期中，Android 会在销毁 Activity 之前调用 onSaveInstanceState()以保存有关应用的相关状态的数据。然后可以在 onCreate() 或 onRestoreInstanceState() 期间恢复 Activity 状态。 重启应用并恢复大量数据不仅成本高昂，而且用户体验并不好，所以可以选用以下方式进行配置变更： 在配置变更期间保留对象：允许 Activity 在配置变更时重启，但是要将有状态对象传递给 Activity 的新实例。 自行处理配置变更：阻止系统在某些配置变更期间重启 Activity，但要在配置确实发生变化时接收回调，这样，就能够根据需要手动更新 Activity。 在配置变更期保留对象 如果重启 Activity 需要恢复大量数据、重新建立网络连接或执行其他密集操作，那么因配置变更而引起的完全重启可能会给用户留下应用运行缓慢的体验。并且通过onSaveInstanceState() 回调为您保存的 Bundle，可能无法完全恢复 Activity 状态，因为它并非设计用于携带大型对象(例如位图等)，而且其中数据必须先序列化，在进行反序列化，这可能会消耗大量的内存使得配置变更时运行缓慢。 在这种情况下，如果 Activity 因配置变更而重启，则可通过保留 Fragment 来减轻重新初始化 Activity 的负担。此片段可能包含要保留的有状态对象的引用。 当 Android 系统因配置变更而关闭 Activity 时，不会销毁您已标记为要保留的 Activity 的片段。 可以将此类片段添加到 Activity 以保留有状态的对象。要在运行时配置变更期间将有状态的对象保留在片段中，请执行以下操作： 扩展 Fragment 类并声明对有状态对象的引用。 在创建片段后调用 setRetainInstance(boolean)。 将片段添加到 Activity。 重启 Activity 后，使用 FragmentManager 检索片段。 代码示例 123456789101112131415161718192021public class RetainedFragment extends Fragment &#123; // data object we want to retain private MyDataObject data; // this method is only called once for this fragment @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // retain this fragment setRetainInstance(true); &#125; public void setData(MyDataObject data) &#123; this.data = data; &#125; public MyDataObject getData() &#123; return data; &#125;&#125; 然后，使用 FragmentManager 将片段添加到 Activity。在运行时配置变更期间再次启动 Activity 时，可以获得片段中的数据对象。 例如，按如下方式定义 Activity： 1234567891011121314151617181920212223242526272829303132333435public class MyActivity extends Activity &#123; private RetainedFragment dataFragment; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); // find the retained fragment on activity restarts FragmentManager fm = getFragmentManager(); dataFragment = (DataFragment) fm.findFragmentByTag(“data”); // create the fragment and data the first time if (dataFragment == null) &#123; // add the fragment dataFragment = new DataFragment(); fm.beginTransaction().add(dataFragment, “data”).commit(); // load the data from the web dataFragment.setData(loadMyData()); &#125; // the data is available in dataFragment.getData() ... &#125;// onCreate() 添加了一个片段或恢复了对它的引用。onCreate() 还将有状态的对象存储在片段实例内部。// onDestroy() 对所保留的片段实例内的有状态对象进行更新 @Override public void onDestroy() &#123; super.onDestroy(); // store the data in the fragment dataFragment.setData(collectMyLoadedData()); &#125;&#125; ​ 注意：**尽管您可以存储任何对象，但是切勿传递与 Activity 绑定的对象，例如，Drawable、Adapter、View 或其他任何与 Context 关联的对象。否则，它将泄漏原始 Activity 实例的所有视图和资源。 （泄漏资源意味着应用将继续持有这些资源，但是无法对其进行垃圾回收，因此可能会丢失大量内存。） 自行变更配置 自行处理配置变更可能导致备用资源的使用更为困难，因为系统不会为您自动应用这些资源。 只能在必须避免 Activity 因配置变更而重启这一万般无奈的情况下，才考虑采用自行处理配置变更这种方法，而且对于大多数应用并不建议使用此方法。 要声明由 Activity 处理配置变更，请在清单文件中编辑相应的元素，以包含 android:configChanges 属性以及代表要处理的配置的值。android:configChanges 属性的文档中列出了该属性的可能值（最常用的值包括 &quot;orientation&quot; 和 &quot;keyboardHidden&quot;，分别用于避免因屏幕方向和可用键盘改变而导致重启）。可以在该属性中声明多个配置值，方法是用管道 | 字符分隔这些配置值。例如： 123&lt;activity android:name=&quot;.MyActivity&quot; android:configChanges=&quot;orientation|keyboardHidden&quot; android:label=&quot;@string/app_name&quot;&gt; 当其中一个配置发生变化时，MyActivity 不会重启。相反，MyActivity 会收到对 onConfigurationChanged() 的调用。向此方法传递Configuration 对象指定新设备配置。可以通过读取 Configuration 中的字段，确定新配置，然后通过更新界面中使用的资源进行适当的更改。调用此方法时，Activity 的 Resources 对象会相应地进行更新，以根据新配置返回资源，就能够在系统不重启 Activity 的情况下轻松重置 UI 的元素。 注意：从 Android 3.2（API 级别 13）开始，当设备在纵向和横向之间切换时，“屏幕尺寸”也会发生变化。因此，在开发针对 API 级别 13 或更高版本（正如 minSdkVersion 和 targetSdkVersion 属性中所声明）的应用时，若要避免由于设备方向改变而导致运行时重启，则除了 &quot;orientation&quot; 值以外，还必须添加 &quot;screenSize&quot; 值。 即必须声明 android:configChanges=&quot;orientation|screenSize&quot;。 Configuration 对象代表所有当前配置，而不仅仅是已经变更的配置。不用关注配置具体发生了哪些变更，就可以轻松地重新分配所有资源，为正在处理的配置提供备用资源。 例如，由于 Resources 对象现已更新，因此您可以通过 setImageResource() 重置任何 ImageView，并且使用适合于新配置的资源。 注意：在声明由 Activity 处理配置变更时，应重置要为其提供备用资源的所有元素。 如果声明由 Activity 处理方向变更，而且有些图像应该在横向和纵向之间切换，则必须在 onConfigurationChanged() 期间将每个资源重新分配给每个元素。 #App Manifest File应用清单 每个应用的根目录中都必须包含一个 AndroidManifest.xml 文件（且文件名精确无误）。 清单文件向 Android 系统提供应用的必要信息，系统必须具有这些信息方可运行应用的任何代码。 清单文件作用： 为应用的 Java 软件包命名。软件包名称充当应用的唯一标识符。 描述应用的各个组件，包括构成应用的 Activity、服务、广播接收器和内容提供程序。它还为实现每个组件的类命名并发布其功能，例如它们可以处理的 Intent 消息。这些声明向 Android 系统告知有关组件以及可以启动这些组件的条件的信息。 确定托管应用组件的进程。 声明应用必须具备哪些权限才能访问 API 中受保护的部分并与其他应用交互。还声明其他应用与该应用组件交互所需具备的权限 列出 Instrumentation 类，这些类可在应用运行时提供分析和其他信息。这些声明只会在应用处于开发阶段时出现在清单中，在应用发布之前将移除。 声明应用所需的最低 Android API 级别 列出应用必须链接到的库 清单文件结构 &lt;action&gt; &lt;activity&gt; &lt;activity-alias&gt; &lt;application&gt; &lt;category&gt; &lt;data&gt; &lt;grant-uri-permission&gt; &lt;instrumentation&gt; &lt;intent-filter&gt; &lt;manifest&gt; &lt;meta-data&gt; &lt;permission&gt; &lt;permission-group&gt; &lt;permission-tree&gt; &lt;provider&gt; &lt;receiver&gt; &lt;service&gt; &lt;supports-screens&gt; &lt;uses-configuration&gt; &lt;uses-feature&gt; &lt;uses-library&gt; &lt;uses-permission&gt; &lt;uses-sdk&gt; ##文件约定 元素： 只有 &lt;manifest&gt; 和 &lt;application&gt; 元素是必需的，它们都必须存在并且只能出现一次。其他大部分元素可以出现多次或者根本不出现。但清单文件中必须至少存在其中某些元素才有用。 如果一个元素包含某些内容，也就包含其他元素。所有值均通过属性进行设置，而不是通过元素内的字符数据设置。 同一级别的元素通常不分先后顺序。例如，&lt;activity&gt;、&lt;provider&gt; 和 &lt;service&gt; 元素可以按任何顺序混合在一起。这条规则有两个主要例外： &lt;activity-alias&gt; 元素必须跟在别名所指的 &lt;activity&gt; 之后。 &lt;application&gt; 元素必须是 &lt;manifest&gt; 元素内最后一个元素。换言之，&lt;/manifest&gt; 结束标记必须紧接在 &lt;/application&gt; 结束标记后。 属性： 从某种意义上说，所有属性都是可选的。但是，必须指定某些属性，元素才可实现其目的。请使用本文档作为参考。对于真正可选的属性，它将指定默认值或声明缺乏规范时将执行何种操作。 除了根 &lt;manifest&gt; 元素的一些属性外，所有属性名称均以 android: 前缀开头。例如，android:alwaysRetainTaskState。由于该前缀是通用的，因此在按名称引用属性时，本文档通常会将其忽略。 声明类名： 许多元素对应于 Java 对象，包括应用本身的元素（&lt;application&gt; 元素）及其主要组件：Activity (&lt;activity&gt;)、服务 (&lt;service&gt;)、广播接收器 (&lt;receiver&gt;) 以及内容提供程序 (&lt;provider&gt;)。 若针对组件类（Activity、Service 和 BroadcastReceiver`ContentProvider）几乎一直采用的方式来定义子类，则该子类需通过name属性来声明。该名称必须包含完整的软件包名称。例如，Service` 子类可能会声明如下： 12345678&lt;manifest . . . &gt; &lt;application . . . &gt; &lt;service android:name=&quot;com.example.project.SecretService&quot; . . . &gt; . . . &lt;/service&gt; . . . &lt;/application&gt;&lt;/manifest&gt; 如果字符串的第一个字符是句点，则应用的软件包名称（如 &lt;manifest&gt; 元素的 package 属性所指定）将附加到该字符串。以下赋值与上述方法相同： 12345678&lt;manifest package=&quot;com.example.project&quot; . . . &gt; &lt;application . . . &gt; &lt;service android:name=&quot;.SecretService&quot; . . . &gt; . . . &lt;/service&gt; . . . &lt;/application&gt;&lt;/manifest&gt; 当启动组件时，Android 系统会创建已命名子类的实例。如果未指定子类，则会创建基类的实例。 多个值：如果可以指定多个值，则几乎总是在重复此元素，而不是列出单个元素内的多个值。 资源值：某些属性的值可以显示给用户，例如，Activity 的标签和图标。这些属性的值应该本地化，并通过资源或主题进行设置。资源值用以下格式表示：@[&lt;i&gt;package&lt;/i&gt;:]&lt;i&gt;type&lt;/i&gt;/&lt;i&gt;name&lt;/i&gt;。如果资源与应用在同一个软件包中，可以省略软件包名称。 字符串值：如果属性值为字符串，则必须使用双反斜杠 (\) 转义字符，例如，使用 \n 表示换行符或使用 \uxxxx 表示 Unicode 字符。 文件功能 Intent过滤器 应用核心组件（例如其 Activity、服务和广播接收器）由 intent 激活。Intent 是一系列用于描述所需操作的信息（Intent 对象），其中包括要执行操作的数据、应执行操作的组件类别以及其他相关说明。Android 系统会查找合适的组件来响应 intent，根据需要启动组件的新实例，并将其传递到 Intent 对象。 组件将通过 intent 过滤器公布它们可响应的 intent 类型。由于Android 系统在启动某组件之前必须了解该组件可以处理的 intent，因此 intent 过滤器在清单中被指定为 &lt;intent-filter&gt; 元素。一个组件可有任意数量的过滤器，其中每个过滤器描述一种不同的功能。 显式命名目标组件的 intent 将激活该组件，因此过滤器不起作用。不按名称指定目标的 intent 只有在能够通过组件的一个过滤器时才可激活该组件。 图标和标签 对于可以显示给用户的小图标和文本标签，大量元素具有 icon 和 label 属性。此外，对于同样可以显示在屏幕上的较长说明文本，某些元素还具有 description 属性。例如，&lt;permission&gt; 元素具有所有这三个属性。因此，当系统询问用户是否授权给请求获得权限的应用时，权限图标、权限名称以及所需信息的说明均会呈现给用户。 无论何种情况下，在包含元素中设置的图标和标签都将成为所有容器子元素的默认 icon 和 label 设置。因此，在 &lt;application&gt; 元素中设置的图标和标签是每个应用组件的默认图标和标签。同样，为组件（例如 &lt;activity&gt; 元素）设置的图标和标签是组件每个 &lt;intent-filter&gt; 元素的默认设置。如果 &lt;application&gt; 元素设置标签，但是 Activity 及其 intent 过滤器不执行此操作，则应用标签将被视为 Activity 和 intent 过滤器的标签。 在实现过滤器公布的功能时，只要向用户呈现组件，系统便会使用为 intent 过滤器设置的图标和标签表示该组件。例如，具有 android.intent.action.MAIN 和 android.intent.category.LAUNCHER 设置的过滤器将 Activity 公布为可启动应用的功能，即，公布为应显示在应用启动器中的功能。在过滤器中设置的图标和标签显示在启动器中。 权限 权限是一种限制，用于限制对部分代码或设备上数据的访问。施加限制是为了保护可能被误用以致破坏或损害用户体验的关键数据和代码。每种权限均由一个唯一的标签标识。标签通常指示受限制的操作。以下是 Android 定义的一些权限： android.permission.CALL_EMERGENCY_NUMBERS android.permission.READ_OWNER_DATA android.permission.SET_WALLPAPER android.permission.DEVICE_POWER 如果应用需要访问受权限保护的功能，则必须在清单中使用 &lt;uses-permission&gt; 元素声明应用需要该权限。将应用安装到设备上之后，安装程序会通过检查签署应用证书的颁发机构并（在某些情况下）询问用户，确定是否授予请求的权限。如果授予权限，则应用能够使用受保护的功能。否则，其访问这些功能的尝试将会失败，并且不会向用户发送任何通知。 应用也可以使用权限保护自己的组件。它可以采用由 Android 定义（如 android.Manifest.permission 中所列）或由其他应用声明的任何权限。它也可以定义自己的权限。 ​ 库 每个应用均链接到默认的 Android 库，该库中包括用于开发应用（以及通用类，如 Activity、服务、intent、视图、按钮、应用、ContentProvider）的基本软件包。 某些软件包驻留在自己的库中。如果应用使用来自其中任一软件包的代码，则必须明确要求其链接到这些软件包。清单必须包含单独的 &lt;uses-library&gt; 元素来命名其中每个库。库名称可在软件包的文档中找到。 App Permissions应用权限 为了维护系统和用户的安全，Android需要应用程序在使用特定系统数据和功能之前声明所需的权限。根据区域的敏感程度，系统可能会自动授予权限，或者可能会要求用户批准该请求。 权限概述 权限需要许可的目的是保护Android用户的隐私。 Android应用程序必须请求访问敏感用户数据（如联系人和短信）以及某些系统功能（如相机和互联网）的权限。根据功能的不同，系统可能会自动授予权限，或者可能会提示用户批准请求。这里介绍的内容包括：如何向用户显示权限，安装时间和运行时权限请求之间的区别，权限的执行方式以及权限和权限组的权限类型。 权限许可 应用必须在清单文件中使用&lt;uses-prmission&gt;标签声明所需要的权限，若应用在其清单中列出了正常权限（即，对用户的隐私或设备操作不构成风险的权限），系统会自动将这些权限授予给应用。但是若应用在其清单中列出了危险权限（即可能影响用户隐私或设备正常运行的权限），如SEND_SMS权限，则用户必须明确同意授予这些权限。 危险权限获取 运行时请求授予危险权限（Android6.0及以上）： 如果设备运行的是Android 6.0（API级别23）或更高版本，并且该应用的targetSdkVersion为23或更高，则安装时用户不会收到任何应用权限的通知。应用程序必须要求用户在运行时授予危险权限。当应用程序请求权限时，用户会看到一个系统对话框，告诉用户您的应用尝试访问哪个权限组。该对话框包含拒绝和允许按钮。 如果用户拒绝权限请求，则在应用下次请求权限时，该对话框将包含一个复选框，该复选框在选中后表示用户不会再次被要求提供权限。如果用户选中永不再问框并点击拒绝，如果稍后尝试请求相同的权限，则系统将不再提示用户。 即使用户向应用程序授予您所请求的权限，但是用户还可以选择在系统设置中逐个启用和禁用权限，因此还是应该始终在运行时检查并请求权限以防止运行时错误（SecurityException）。 安装时获取权限（Android5.1.1及以下） 如果设备运行Android 5.1.1（API级别22）或更低，或者应用程序的targetSdkVersion为22或更低，则系统会自动要求用户在安装时为应用授予所有危险权限。 在安装时用户如果拒绝授予这些危险权限那么将无法安装应用，如果应用程序更新包含对额外权限的需求，则会在更新应用程序之前提示用户接受这些新权限。 硬件权限 访问某些硬件功能（例如蓝牙或相机）需要应用程序许可。但并非所有的Android设备都具备这些硬件功能。因此，如果应用请求CAMERA权限，则还必须在清单中包含标记以声明该功能是否实际需要。 1&lt;uses-feature android:name=&quot;android.hardware.camera&quot; android:required=&quot;false&quot; /&gt; 如果您为该功能声明了android：required =“false”，则Google Play允许应用安装在没有此功能的设备上。然后，必须通过调用PackageManager.hasSystemFeature（）来检查当前设备是否在运行时具有该功能，并在不可用时正常禁用该功能。 如果您提供标记，那么当Google Play发现应用请求相应的权限时，它会假定应用需要此功能。因此，它会在没有此功能的设备上过滤您的应用，就像您在标记中声明了android：required =“true”一样。 声明权限 权限不仅用于请求系统功能。应用程序提供的服务可以执行自定义权限，以限定可使用它们的对象。 Activity权限声明：在应用清单文件标签中使用android：permission权限属性，限定可以启动该Activity的Activity。在Context.startActivity()和Activity.startActivityForResult()中检查权限。如果调用者没有所需的权限，则会在调用时调抛出SecurityException； Service权限声明：在应用清单文件标签中使用android：permission权限属性，限定可以启动或绑定到关联的Service的对象。在Context.startService()，Context.stopService()和Context.bindService()中检查权限。如果调用者没有所需的权限，则会在调用时调抛出SecurityException； Braodcast权限声明： 在应用清单文件标签中使用android：permission权限属性，限定可以将广播发送到关联的BroadcastReceiver的对象。在Context.sendBroadcast()返回后检查权限，因为系统试图将提交的广播传送给指定的接收者。因此，权限不足导致的调用失败不会导致异常并抛回给调用者。 以同样的方式，可以向Context.registerReceiver()提供权限，以限制向以代码注册的接收者进行广播的广播。换句话说，当调用Context.sendBroadcast（）可以使用权限来限制哪些广播接收器可以接收广播。在接收者和广播者都需要获得权限时，必须通过权限检查才能将意图传递到关联的目标。 Content Provider权限声明： 在应用清单文件标签中使用android：permission权限属性，限定可以访问ContentProvider中的数据的对象（内容提供者有一个重要的额外的安全机制也就是URI权限）。与其他组件不同，应用可以设置两个单独的权限属性：android:readPermission限制谁可以从提供者读取，而android: writePermission限制谁可以写入它。如果提供者受到读写权限的保护，只保留写权限并不意味着可以从提供者读取。 当首次检索提供程序时（如果没有任何权限，会引发SecurityException）并在对提供程序执行时检查权限。使用ContentResolver.query()需要保持读取权限;使用ContentResolver.insert()，ContentResolver.update()，ContentResolver.delete()需要写入权限。在所有这些情况下，不保留所需的权限会导致SecurityException从。 URI权限 ： 目前权限机制并不能完全满足Content Provider的需求。内容提供者希望通过读写权限来保护自己，而客户端也需要将特定的URI传递给其他应用程序供他们操作。例如电子邮件程序中的附件，因为设计到敏感的用户数据，访问电子邮件受到权限保护。但是，如果将图像附件的URI提供给图像查看器，则该图像查看器不再具有打开附件的权限，因为它没有理由持有访问所有电子邮件的权限。 此问题的解决方案是每个URI权限：在启动活动或将结果返回给活动时，调用者可以设置Intent.FLAG_GRANT_READ_URI_PERMISSION和/或Intent.FLAG_GRANT_WRITE_URI_PERMISSION。这允许接收活动权限访问意图中的特定数据URI，而不管其是否具有访问与意图相对应的内容提供者中的数据的任何权限。 这种机制允许一种通用的能力风格模型，在这种模型中，用户交互（例如打开附件或从列表中选择联系人）驱动临时授予细化权限。这可能是将应用程序所需的权限仅限于与其行为直接相关的权限的关键工具。要构建使其他应用程序对您的应用程序负责的最安全的实现，应该以这种方式使用细化的权限，并使用android:grantUriPermissions属性或标签声明您的应用程序的支持。 其他权限声明： 任何调用服务时都可以强制任意细化权限。这是通过Context.checkCallingPermission()方法完成的。使用所需的权限字符串进行调用，并返回一个整数，指示该权限是否已授予当前经常调用。请注意，只有当您执行从另一个进程调用的调用时（通常是通过从服务发布的IDL接口或以其他方式向另一个进程发送的调用），才可以使用它。 还有许多其他有用的方法来检查权限。如果应用拥有另一个进程的进程ID（PID），则可以使用Context.checkPermission()方法检查针对该PID的权限。如果拥有其他应用的软件包名称，则可以使用PackageManager.checkPermission()方法来确定该特定软件包是否已被授予特定权限。 权限自动调整 随着Android的更新，系统可能会某些API增加的限制，因此应用可能需要获取之前不需要的权限。由于应用之前对这些API的访问是不需要相应权限直接访问的，因此Android会将新的权限直接添加到清单文件，以避免在新版本的Android系统中应用的崩溃。Android会根据targetSdkVersion属性的值来确定应用是否需要添加权限。 如果应用自动添加了权限，那么即使您的应用实际上不需要它们，Google Play上的应用列表也会列出这些附加权限。为了避免这种情况并移除不需要的权限，请始终将targetSdkVersion更新为尽可能高。可在Build.VERSION_CODES文档中看到每个版本添加了哪些权限。 权限保护级别 权限分为几个保护级别。保护级别影响是否需要运行时权限请求。有三个保护级别会影响第三方应用程序：正常，签名和危险权限。 普通权限 普通权限包括应用程序需要访问应用程序沙箱外的数据或资源，该访问操作对用户的隐私或其他应用程序的风险很小。例如，设置时区的权限是普通权限。 如果应用程序在其清单中声明它需要正常许可，系统会在安装时自动授予应用程序该许可权。系统不会提示用户授予正常权限，并且用户无法撤消这些权限。 从Android8.1开始一下权限为普通权限： ACCESS_LOCATION_EXTRA_COMMANDS ACCESS_NETWORK_STATE ACCESS_NOTIFICATION_POLICY ACCESS_WIFI_STATE BLUETOOTH BLUETOOTH_ADMIN BROADCAST_STICKY CHANGE_NETWORK_STATE CHANGE_WIFI_MULTICAST_STATE CHANGE_WIFI_STATE DISABLE_KEYGUARD EXPAND_STATUS_BAR GET_PACKAGE_SIZE INSTALL_SHORTCUT INTERNET KILL_BACKGROUND_PROCESSES MANAGE_OWN_CALLS MODIFY_AUDIO_SETTINGS NFC READ_SYNC_SETTINGS READ_SYNC_STATS RECEIVE_BOOT_COMPLETED REORDER_TASKS REQUEST_COMPANION_RUN_IN_BACKGROUND REQUEST_COMPANION_USE_DATA_IN_BACKGROUND REQUEST_DELETE_PACKAGES REQUEST_IGNORE_BATTERY_OPTIMIZATIONS REQUEST_INSTALL_PACKAGES SET_ALARM SET_WALLPAPER SET_WALLPAPER_HINTS TRANSMIT_IR USE_FINGERPRINT VIBRATE WAKE_LOCK WRITE_SYNC_SETTINGS 签名权限 系统在安装时授予这些应用的权限，但仅当试图使用权限的应用程序由与定义权限的应用程序相同的证书签名时。 从Android 8.1（API级别27）开始，第三方应用程序可以使用的以下权限分类为PROTECTION_SIGNATURE： BIND_ACCESSIBILITY_SERVICE BIND_AUTOFILL_SERVICE BIND_CARRIER_SERVICES BIND_CHOOSER_TARGET_SERVICE BIND_CONDITION_PROVIDER_SERVICE BIND_DEVICE_ADMIN BIND_DREAM_SERVICE BIND_INCALL_SERVICE BIND_INPUT_METHOD BIND_MIDI_DEVICE_SERVICE BIND_NFC_SERVICE BIND_NOTIFICATION_LISTENER_SERVICE BIND_PRINT_SERVICE BIND_SCREENING_SERVICE BIND_TELECOM_CONNECTION_SERVICE BIND_TEXT_SERVICE BIND_TV_INPUT BIND_VISUAL_VOICEMAIL_SERVICE BIND_VOICE_INTERACTION BIND_VPN_SERVICE BIND_VR_LISTENER_SERVICE BIND_WALLPAPER CLEAR_APP_CACHE MANAGE_DOCUMENTS READ_VOICEMAIL REQUEST_INSTALL_PACKAGES SYSTEM_ALERT_WINDOW WRITE_SETTINGS WRITE_VOICEMAIL 危险权限 危险权限涵盖应用程序需要涉及用户私人信息的数据或资源的区域，或者可能会影响用户的存储数据或其他应用程序的操作。例如，阅读用户联系人的权限是危险的权限。如果一个应用程序声明它需要一个危险的权限，用户必须明确授予该应用程序的权限。在用户批准权限之前，应用无法提供取决于该权限的功能。要使用危险权限，应用必须提示用户在运行时授予权限。 特殊权限 有几个权限不具有正常和危险的权限。 SYSTEM_ALERT_WINDOW和WRITE_SETTINGS特别敏感，所以大多数应用程序不应该使用它们。如果应用程序需要这些权限之一，则必须在清单中声明权限，并发送请求用户授权的意图。系统通过向用户显示详细的管理屏幕来响应意图。 权限组 根据权限与之相关的功能权限被组织到权限组中。在此系统下，权限请求在组级别处理，并且单个权限组对应于应用清单中的多个权限声明。例如，SMS组包含READ_SMS和RECEIVE_SMS声明。以这种方式分组权限使用户能够做出更有意义和更明智的选择。 所有危险的Android权限都属于权限组。不管保护级别如何，任何权限都可以属于权限组。但是，如果权限是危险的，权限组只会影响用户体验。 如果设备运行的是Android 6.0（API级别23），并且该应用的targetSdkVersion为23或更高，则当您的应用请求危险权限时，以下系统行为适用： 如果应用程序当前没有权限组的权限，系统会向描述该应用程序想要访问的权限组的用户显示权限请求对话框。该对话框没有描述该组内的特定权限。例如，如果某个应用程序请求READ_CONTACTS权限，则系统对话框只是表示应用程序需要访问该设备的联系人。如果用户同意，系统只给予应用程序许可。 如果应用程序已被授予同一权限组中的另一个危险权限，系统会立即授予权限，而不会与用户进行任何交互。例如，如果一个应用程序先前已经请求并被授予了READ_CONTACTS权限，并且它然后请求了WRITE_CONTACTS，则系统立即授予该权限而不向用户显示权限对话框。 警告：未来版本的Android SDK可能会将特定权限从一个组移到另一个组。因此，不要将您的应用的逻辑基于这些权限组的结构。例如，从Android 8.1（API级别27）开始，READ_CONTACTS与WRITE_CONTACTS处于相同的权限组。如果应用程序请求READ_CONTACTS权限，然后请求WRITE_CONTACTS权限，请不要假定系统可以自动授予WRITE_CONTACTS权限。 如果设备运行Android 5.1（API级别22）或更低，或者应用程序的targetSdkVersion为22或更低，则系统会要求用户在安装时授予权限。系统再一次告诉用户应用程序需要什么权限组，而不是个人权限。例如，当应用程序请求READ_CONTACTS时，安装对话框会列出联系人组。当用户接受时，只有READ_CONTACTS权限被授予应用程序。 危险的权限和权限组 | Permission Group | Permissions || —————- | :———————————————————– || CALENDAR | READ_CALENDAR WRITE_CALENDAR || CAMERA | CAMERA || CONTACTS | READ_CONTACTS WRITE_CONTACTS GET_ACCOUNTS || LOCATION | ACCESS_FINE_LOCATION ACCESS_COARSE_LOCATION || MICROPHONE | RECORD_AUDIO || PHONE | READ_PHONE_STATE READ_PHONE_NUMBERS CALL_PHONE ANSWER_PHONE_CALLS (must request at runtime) READ_CALL_LOG WRITE_CALL_LOG ADD_VOICEMAIL USE_SIP PROCESS_OUTGOING_CALLS ANSWER_PHONE_CALLS || SENSORS | BODY_SENSORS || SMS | SEND_SMS RECEIVE_SMS READ_SMS RECEIVE_WAP_PUSH RECEIVE_MMS || STORAGE | READ_EXTERNAL_STORAGE`WRITE_EXTERNAL_STORAGE` | 查看应用程序的权限 可以使用Settings应用程序和shell命令adb shell pm列表权限查看系统中当前定义的所有权限。要使用设置应用，请转到设置&gt;应用。选择一个应用并向下滚动以查看该应用使用的权限。对于开发人员，adb’-s’选项以类似于用户看到它们的方式显示权限： 123456789101112$ adb shell pm list permissions -sAll Permissions:Network communication: view Wi-Fi state, create Bluetooth connections, fullinternet access, view network stateYour location: access extra location provider commands, fine (GPS) location,mock location sources for testing, coarse (network-based) locationServices that cost you money: send SMS messages, directly call phone numbers... 也可以使用adb -g选项在模拟器或测试设备上安装应用程序时自动授予所有权限： 1$ adb shell install -g MyApp.apk 在运行时请求权限 从 Android 6.0（API 级别 23）开始，用户开始在应用运行时向其授予权限，而不是在应用安装时授予。此方法可以简化应用安装过程，因为用户在安装或更新应用时不需要授予权限。它还让用户可以对应用的功能进行更多控制；例如，用户可以选择为相机应用提供相机访问权限，而不提供设备位置的访问权限。用户可以随时进入应用的“Settings”屏幕调用权限。 系统权限分为两类：正常权限和危险权限 正常权限不会直接给用户隐私权带来风险。如果应用在其清单中列出了正常权限，系统将自动授予该权限。 危险权限会授予应用访问用户机密数据的权限。如果列出了危险权限，则用户必须明确批准您的应用使用这些权限。 在所有版本的 Android 中，您应用都需要在其应用清单中同时声明它需要的正常权限和危险权限，如声明权限中所述。不过，该声明的影响因系统版本和应用的目标 SDK 级别的不同而有所差异： 如果设备运行的是 Android 5.1 或更低版本，或者应用的目标 SDK 为 22 或更低：如果您在清单中列出了危险权限，则用户必须在安装应用时授予此权限；如果他们不授予此权限，系统根本不会安装应用。 如果设备运行的是 Android 6.0 或更高版本，或者应用的目标 SDK 为 23 或更高：应用必须在清单中列出权限，并且它必须在运行时请求其需要的每项危险权限。用户可以授予或拒绝每项权限，且即使用户拒绝权限请求，应用仍可以继续运行有限的功能。 如果设备运行的是 Android 5.1 或更低版本，或者应用的目标 SDK 为 22 或更低：如果您清单中列出了危险权限，则用户必须在安装应用时授予此权限；如果他们不授予此权限，系统根本不会安装应用。 如果设备运行的是 Android 6.0 或更高版本，或者应用的目标 SDK 为 23 或更高：应用必须在清单中列出权限，并且它必须在运行时请求其需要的每项危险权限。用户可以授予或拒绝每项权限，且即使用户拒绝权限请求，应用仍可以继续运行有限的功能。 检查权限 如果应用需要危险权限，则每次执行需要这一权限的操作时您都必须检查自己是否具有该权限。用户始终可以自由调用此权限。 要检查您是否具有某项权限，请调用 ContextCompat.checkSelfPermission() 方法。例如，以下代码段显示了如何检查 Activity 是否具有在日历中进行写入的权限： int permissionCheck =ContextCompat.checkSelfPermission(thisActivity,Manifest.permission.WRITE_CALENDAR); 如果应用具有此权限，方法将返回 PackageManager.PERMISSION_GRANTED，并且应用可以继续操作。如果应用不具有此权限，方法将返回 PERMISSION_DENIED，且应用必须明确向用户要求权限 请求权限 如果应用需要应用清单中列出的危险权限，那么，它必须要求用户授予该权限。Android 为您提供了多种权限请求方式。调用这些方法将显示一个标准的 Android 对话框，不过，能对它们进行自定义。 向用户解释需要权限的原因 在某些情况下，可能需要让用户了解您的应用为什么需要某项权限。例如，如果用户启动一个摄影应用，用户对应用要求使用相机的权限可能不会感到吃惊，但用户可能无法理解为什么此应用想要访问用户的位置或联系人。在请求权限之前，不妨为用户提供一个解释。请记住，不需要通过解释来说服用户；如果提供太多解释，用户可能发现应用令人失望并将其移除。 可以采用的一个方法是仅在用户已拒绝某项权限请求时提供解释。如果用户继续尝试使用需要某项权限的功能，但继续拒绝权限请求，则可能表明用户不理解应用为什么需要此权限才能提供相关功能。对于这种情况，比较好的做法是显示解释。 为了帮助查找用户可能需要解释的情形，Android 提供了一个实用程序方法，即 shouldShowRequestPermissionRationale()。如果应用之前请求过此权限但用户拒绝了请求，此方法将返回 true。如果用户在过去拒绝了权限请求，并在权限请求系统对话框中选择了 Don’t ask again 选项，此方法将返回 false。如果设备规范禁止应用具有该权限，此方法也会返回 false。 请求需要的权限 如果应用尚无所需的权限，则应用必须调用一个 requestPermissions() 方法，以请求权限。应用将传递其所需的权限，以及指定用于识别此权限请求的整型请求代码。此方法异步运行：它会立即返回，并且在用户响应对话框之后，系统会使用结果调用应用的回调方法，将应用传递的相同请求代码传递到 requestPermissions()。 例如，以下代码可以检查应用是否具备读取用户联系人的权限，并根据需要请求该权限： 1234567891011121314151617181920212223242526// Here, thisActivity is the current activityif (ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) &#123; // Should we show an explanation? if (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity, Manifest.permission.READ_CONTACTS)) &#123; // Show an expanation to the user *asynchronously* -- don&apos;t block // this thread waiting for the user&apos;s response! After the user // sees the explanation, try again to request the permission. &#125; else &#123; // No explanation needed, we can request the permission. ActivityCompat.requestPermissions(thisActivity, new String[]&#123;Manifest.permission.READ_CONTACTS&#125;, MY_PERMISSIONS_REQUEST_READ_CONTACTS); // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an // app-defined int constant. The callback method gets the // result of the request. &#125;&#125; 注：当您的应用调用 requestPermissions() 时，系统将向用户显示一个标准对话框。应用无法配置或更改此对话框。如果需要为用户提供任何信息或解释，您应在调用 requestPermissions() 之前进行，如解释应用为什么需要权限中所述。 处理权限请求响应 当应用请求权限时，系统将向用户显示一个对话框。当用户响应时，系统将调用应用的 onRequestPermissionsResult() 方法，向其传递用户响应。应用必须重写改方法，以了解是否已获得相应权限。回调会将您传递的相同请求代码传递给 requestPermissions()。例如，如果应用请求 READ_CONTACTS 访问权限，则它可能采用以下回调方法： 123456789101112131415161718192021222324@Overridepublic void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) &#123; switch (requestCode) &#123; case MY_PERMISSIONS_REQUEST_READ_CONTACTS: &#123; // If request is cancelled, the result arrays are empty. if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; // permission was granted, yay! Do the // contacts-related task you need to do. &#125; else &#123; // permission denied, boo! Disable the // functionality that depends on this permission. &#125; return; &#125; // other &apos;case&apos; lines to check for other // permissions this app might request &#125;&#125; ​ 系统显示的对话框说明了您的应用需要访问的权限组；它不会列出具体权限。例如，如果请求 READ_CONTACTS 权限，系统对话框只显示应用需要访问设备的联系人。用户只需要为每个权限组授予一次权限。如果应用请求该组中的任何其他权限（已在您的应用清单中列出），系统将自动授予应用这些权限。当请求此权限时，系统会调用 onRequestPermissionsResult() 回调方法，并传递 PERMISSION_GRANTED，如果用户已通过系统对话框明确同意您的权限请求，系统将采用相同方式操作。 注：应用仍需要明确请求其需要的每项权限，即使用户已向应用授予该权限组中的其他权限。此外，权限分组在将来的 Android 版本中可能会发生变化。您的代码不应依赖特定权限属于或不属于相同组这种假设。 例如，假设应用清单中列出了 READ_CONTACTS 和 WRITE_CONTACTS。如果请求 READ_CONTACTS 且用户授予了此权限，那么，当请求 WRITE_CONTACTS 时，系统将立即授予您该权限，不会与用户交互。如果用户拒绝了某项权限请求，应用应采取适当的操作。例如，应用可能显示一个对话框，解释它为什么无法执行用户已经请求但需要该权限的操作。当系统要求用户授予权限时，用户可以选择指示系统不再要求提供该权限。这种情况下，无论应用在什么时候使用 requestPermissions() 再次要求该权限，系统都会立即拒绝此请求。系统会调用onRequestPermissionsResult() 回调方法，并传递 PERMISSION_DENIED，如果用户再次明确拒绝了应用的请求，系统将采用相同方式操作。这意味着当您调用 requestPermissions() 时，应用不能假设已经发生与用户的任何直接交互。 权限请求示例 权限请求保护设备中可用的敏感信息，并且只能在访问信息对于您的应用的运行是必需的时才使用。权限请求示例提供了有关如何在不需要访问此类信息的情况下实现相同（或更好）功能的提示; 使用Android权限的原则 只使用应用程序工作所需的权限：因为可能有另一种方法可以满足您的需求（系统意图，标识符，电话背景），而无需依赖敏感信息。 注意jar包所需要的权限：当你使用一个库时，应该清楚它所需要的权限以及权限的用途然后获取它所需要的权限。 权限透明原则：进行权限请求时，应当告知用户获取权限的原因。使此信息与权限请求一起提供，包括安装，运行时或更新权限对话。 确保系统访问清晰：当访问敏感功能（例如相机或麦克风）时，应在收集数据时提供连续请求以便清楚地向用户显示。 Android6.0的权限变更 Android 6.0 引入了一个新的权限策略，它允许应用程序在运行时向用户请求权限，而不是在安装之前。当应用程序实际需要受服务保护的服务或数据时，应用程序支持使用新的策略进行权限请求。虽然这不会（必然）改变整体应用程序行为，但它确实会引起敏感用户数据处理方式相关的一些更改。 权限请求增加提示：在运行时，会在应用程序对话框中提示用户所使用的功能会涵盖那些权限以及权限组组。用户对请求权限的对话框中的提示很敏感，更重要的是，如果要求的权限与应用的目的不匹配，应该向用户提供详细的解释，说明为什么要求获取该权限;只要有可能，应该在请求时提供请求的解释，并在用户拒绝请求时在后续对话框中提供解释。 授予权限的灵活性更大：用户可以在请求和设置时拒绝权限的授权，但当用户的操作或使用的功能因此而中断时。应用可以监控有多少用户拒绝权限，以便在重构时避免使用该权限，或者对为什么应用需要获得改权限才能正常工作提供更好的解释。还应该确保应用处理在用户拒绝权限请求或关闭设置中的权限时创建的异常。 增加了操作负担：要求用户单独授予权限的访问权限，而不是一组权限。这对于最小化请求的权限数量非常重要，因为它增加了用户授予权限的操作负担，并增加了至少拒绝一个请求的可能性。 避免请求不必要的权限 每当您要求获得权限时，都会强制用户做出决定。应用应该尽量减少请求获取权限。如果用户运行的是Android 6.0（API级别23）或更高版本，则每次用户尝试一些需要权限的程序功能时，应用程序都必须使用权限请求中断用户的工作。如果用户正在运行早期版本的Android，则用户必须在安装应用程序时授予每个应用程序的权限;如果列表太长或看起来不合适，用户可能决定根本不安装您的应用程序。出于这些原因，应该尽量减少应用程序需要的权限数量。 优先使用Intent 在很多情况下，应用可以选择两种方式执行任务。应用程序可以获取权限自己执行任务，也可以使用意图让另一个应用程序执行任务，这样就不必获取权限。 例如，假设应用需要能够使用设备相机拍照。应用可以请求CAMERA权限，该权限允许应用直接访问摄像头。然后，应用将使用相机API来控制相机并拍摄照片。这种方法中应用完全控制摄影过程，并让摄像头UI整合到应用中。 但是，如果应用对访问用户数据的需求不频繁 ， 换句话说，每次需要访问数据时，用户都都会看到一个请求权限的对话框，这会严重影响用户的体验。应用可以使用基于意图的请求。 Android提供了一些应用程序可以在不需要权限的情况下使用的系统意图，因为用户选择在发出基于意图的请求时与应用程序共享什么（如果有的话）。例如，MediaStore.ACTION_IMAGE_CAPTURE或MediaStore.ACTION_VIDEO_CAPTURE的intent操作类型可用于获取图像或视频，而无需直接使用Camera对象（需要权限）。在这种情况下，每次捕获图像时，系统意图都会代表应用请求用户的许可。 直接使用权限和使用Intent的优缺点： 使用权限： 执行操作时，应用可全面控制用户体验。但是，如此广泛的控制会增加代码的复杂性，因为需要设计合适的UI。 系统会在运行时或安装时提示用户授予一次权限（具体取决于用户的Android版本）。之后，应用可以执行操作，而无需用户进行额外的交互。但是，如果用户未授予权限（或稍后撤销权限），则应用程序将失去执行操作的能力。 使用Intent： 应用不必为操作设计UI。处理意图的应用程序提供UI。 用户可以使用他们的首选应用程序来完成任务。例如，用户可以选择最喜欢的照片应用拍照。 如果用户没有该操作的默认应用程序，系统会提示用户选择一个应用程序。如果用户没有指定默认处理程序，则每次执行操作时可能需要经过额外的对话框。 不要让用户陷于频繁的请求处理 如果用户运行Android 6.0（API级别23）或更高版本，则用户必须在运行应用程序时授予您的应用程序权限。如果您一次性向用户提出大量权限请求，您可能会压倒用户并导致他们退出应用。 开发者应该根据需求去请求权限。在某些情况下，一个或多个权限可能对应用程序绝对是必不可少的。应用程序启动后立即要求提供所有这些权限可能很有意义。例如，如果制作摄影应用程序，该应用程序需要访问设备摄像头。当用户第一次启动应用程序时，用户会被要求获得使用相机的权限并不感到惊讶。但是，如果同一个应用程序还具有与用户的联系人共享照片的功能，那么在首次启动时，可能不应要求提供READ_CONTACTS权限。相反，请等到用户尝试使用“共享”功能并要求获得许可。 如果应用程序提供了教程，那么在教程序列结尾处请求应用程序的基本权限也是很容易让用户接受的。 多媒体应用失去焦点进入后台是暂停播放 应用程序在用户接到电话时进入后台并且失去焦点，并且只有在呼叫停止后才能重新调整焦点。在这些情况下的常见方法（例如媒体播放器在通话期间静音或暂停）是使用PhoneStateListener监听呼叫状态的更改或监听android.intent.action.PHONE_STATE的广播。该解决方案的问题在于它需要READ_PHONE_STATE权限，这会强制用户授予对各种敏感数据的访问权限，例如设备和SIM硬件ID以及来电的电话号码。 应用可以通过请求AudioFocus来避免此问题，因为它不需要明确权限（因为它不访问敏感信息）。只需将代码置于onAudioFocusChange()事件处理程序中所需的代码，并在操作系统移动其音频焦点时自动运行。 确定应用运行的设备标识 应用程序可能具有对特定设备的偏好或消息传递（例如，在服务器为用户保存设备特定的播放列表，以便用户可以为他们的汽车和家中有不同的播放列表）。一种常见的解决方案是利用设备标识符，例如设备IMEI，但这需要设备ID和呼叫信息权限组（M +中的PHONE）。它还使用无法重置并在所有应用程序之间共享的标识符。 使用这些类型的标识符有两种选择： 使用com.google.android.gms.iid InstanceID API。 getInstance（上下文上下文）.getID()将为应用程序实例返回唯一的设备标识符。结果是一个应用程序实例作用域标识符，可以在存储有关应用程序的信息时用作键，并在用户重新安装应用程序时重置。 使用基本系统函数（如randomUUID()）创建属于应用程序存储空间的自己的标识符。 为广告和用户分析功能创建唯一标识符 对于广告和用户分析功能，需要一个唯一标识符来为未登录应用的用户构建配置文件（例如，针对广告的用户定位定位或计算广告转化率）。 为广告和用户分析构建配置文件有时需要和其他应用程序共享的标识符。常见的解决方案涉及利用设备标识符，如设备IMEI，它需要设备ID和呼叫信息权限组（API级别23+中的PHONE），并且不能由用户重置。在任何这些情况下，除了使用不可重置的标识符并要求用户特殊的权限外，还将违反Play开发者计划政策。不幸的是，在这些情况下，使用com.google.android.gms.iid InstanceID API或系统函数来创建应用程序范围ID不是合适的解决方案，因为ID可能需要跨应用程序共享。另一种解决方案是通过getId()方法使用AdvertisingIdClient.Info类中的广告标识符。应用可以使用getAdvertisingIdInfo(Context)方法创建AdvertisingIdClient.Info对象，并调用getId()方法以使用标识符。注意这个方法是阻塞的，所以你不应该从主线程调用它;这个方法的详细解释可以在这里找到 了解应用使用的第三方库 应用中使用的库也需要权限。例如，广告和分析库可能需要访问位置或身份权限组才能实现所需的功能。但从用户的角度来看，权限请求来自你的应用程序，而不是库。 正如用户选择相同功能使用较少权限的应用程序一样，开发人员应该查看其库并选择未使用不必要权限的第三方SDK。例如，尝试避免需要身份权限组的库，除非存在明确的面向用户的原因，为什么应用程序需要这些权限。特别是，对于提供位置功能的库，请确保您不需要请求FINE_LOCATION权限，除非使用基于位置的定位功能。 解释为什么需要权限 调用requestPermissions()时系统显示的权限对话框表示应用需要什么权限，但没有说明原因。在某些情况下，用户可能会觉得令人费解的。因此在调用requestPermissions()之前需要向用户解释为什么你的应用程序需要权限。 如果仅使用属于某个权限组的API调用的一小部分，则有助于明确列出正在使用哪些权限以及原因。例如： 如果只使用粗略位置，请让用户在应用说明中或在有关应用的帮助文章中了解这一点。 如果需要访问短信以接收验证码，以保护用户免遭欺诈，请让用户在应用说明中和/或第一次访问数据时了解相关信息。 注意：如果应用程序的适配版本是Android 8.0（API级别26）或更高，请不要请求READ_SMS权限作为验证用户凭据的一部分。相反，请使用createAppSpecificSmsToken()生成特定于应用程序的令牌，然后将此令牌传递给可发送验证SMS消息的其他应用程序或服务。 让用户实时了解敏感数据访问也是有利的也是有利的。例如，如果应用正在访问摄像头或麦克风，最好让用户知道应用程序中某处的通知图标或通知托盘中的通知图标（如果应用程序在后台运行），这表示应用不是在偷偷手机用户数据。 如果需要申请在应用中制作某些内容的权限，但其原因尚不清楚，请找到让用户知道为什么需要最敏感的权限。 测试两种权限模式 从 Android 6.0 开始，用户在应用运行时允许或者拒绝权限而不是在应用安装时，这导致你需要测试各种条件下app 的表现。在 Android 6.0之前，你可以合理假定你的 app 一直可运行，它拥有所有在 app manifest中声明的权限。在新的权限模式下，你不能这么认为了。 以下提示将帮助你验证 Android 6.0及以上系统的权限相关代码问题。 验证 app 当前权限以及相关代码路径。 测试用户通过权限保护服务和数据。 测试多种权限分别被允许、拒绝的组合情况。比如，相机 app 可能在 manifest 文件中声明了CAMERA 、 READ_CONTACTS 和 ACCESS_FINE_LOCATION 权限。你应该测试每个权限打开和关闭的情况来确保 app 可以优雅地处理所有权限配置情况。记住，从 Android 6.0开始用户可以打开或关闭任意一个app的权限，即便是 targets API 在 22及以下的。 使用 adb 工具通过命令行管理权限： 以组的形式列出权限和状态： $ adb shell pm list permissions -d -g 允许或拒绝一个或多个权限： $ adb shell pm [grant|revoke] 为使用权限的服务分析 app ##自定义应用权限 通过定义自定义权限，应用程序可以与其他应用程序共享其资源和功能。 背景 Android是一个权限隔离的操作系统，每个应用程序都以不同的系统标识（Linux用户标识和组标识）运行，Linux将应用程序与系统隔离开来。应用可以通过定义权限(其他应用可以请求)来将自身功能展示给其他应用。并且还可以定义自动提供给任何其他使用相同证书签名的应用程序的权限。 应用签名：所有APK必须使用其开发人员拥有私钥的证书进行签名。此证书标识应用的作者。证书不需要由证书颁发机构签名;对于Android应用程序来说，使用自签名证书是完全可以允许并常用的。 Android中证书的用途是区分应用作者。这允许系统授予或拒绝应用程序访问签名级别的权限，并授予或拒绝应用程序的请求获得与另一个应用程序相同的Linux身份。 用户ID和文件访问权限：在安装时，Android系统为每个应用提供独有的Linux用户ID。应用在该设备的使用寿命中，应用身份保持不变（UID不变）。同一个软件包在不同的设备上，可能有不同的UID;重要的是每个软件包在给定设备上具有不同的UID。由于安全实施发生在流程级别，因此任何两个软件包的代码通常无法在同一进程中运行，因为它们需要以不同的Linux用户身份运行。您可以使用每个软件包的AndroidManifest.xml清单标记中的sharedUserId属性为它们分配相同的用户ID。通过这样做，这两个包将被视为同一个应用程序，并具有相同的用户标识和文件权限。请注意，为了保持安全性，只有两个使用相同签名签名（并请求相同sharedUserId）的应用将被赋予相同的用户ID。应用程序存储的任何数据都将被分配该应用程序的用户ID，而其他软件包通常无法访问该ID。 定义和执行权限 要执行权限，首先必须在AndroidManifest.xml中使用一个或多个元素声明。 123456789101112&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.myapp&quot; &gt; &lt;permission android:name=&quot;com.example.myapp.permission.DEADLY_ACTIVITY&quot; android:label=&quot;@string/permlab_deadlyActivity&quot; android:description=&quot;@string/permdesc_deadlyActivity&quot; android:permissionGroup=&quot;android.permission-group.COST_MONEY&quot; android:protectionLevel=&quot;dangerous&quot; /&gt; ...&lt;/manifest&gt; ​ 注意：除非所有应用都使用相同的签名证书，否则系统不允许多个应用声明具有相同名称的权限。如果应用声明了权限，则系统不允许用户安装具有相同权限名的其它应用，除非应用的签名证书相同。为避免命名冲突，建议为自定义权限使用反向域名式命名，如com.example.myapp.ENGAGE_HYPERSPACE。 必需的使用protectionLevel属性，来告诉系统如何向用户通知需要许可的应用程序，或者允许谁拥有该许可权。 可选择使用android:permissionGroup属性，来帮助系统向用户显示权限。在大多数情况下，应用应该将其设置为标准系统权限组（在android.Manifest.permission_group中列出），尽管可以自己定义一个组。最好使用现有组，因为这简化了向用户显示的权限UI。 应用需要提供标签和描述权限。这些是用户在查看权限列表（android:label）或单个权限（android:description）上的详细信息时可以看到的字符串资源。标签应该是简短的，用几句话来描述权限所保护的关键功能。描述应该是几个句子，描述应用获取权限做什么。我们的约定是一个两个句子的描述：第一个句子描述权限，第二个句子警告用户在应用程序被授予权限时可能出错的类型。以下CALL_PHONE权限的标签和说明示例： 12345&lt;string name=&quot;permlab_callPhone&quot;&gt;directly call phone numbers&lt;/string&gt;&lt;string name=&quot;permdesc_callPhone&quot;&gt;Allows the app to call phone numbers without your intervention. Malicious apps may cause unexpected calls on your phone bill. Note that this does not allow the app to call emergency numbers.&lt;/string&gt; 创建一个权限组 应用可以使用android:permissionGroup属性来帮助系统向用户描述权限。在大多数情况下，会希望将其设置为标准系统组（在android.Manifest.permission_group中列出），但也可以使用定义自己的组。 元素为一组权限定义了一个标签 - 这两个标签都在清单中用元素声明并在别处声明。这仅影响将权限分配给用户时的分组方式。 元素不指定属于该组的权限，但是它给该组一个名称。应用可以通过将组名分配给元素的permissionGroup属性来在组中放置权限。 自定义权限的建议 如果正在设计一系列向其它应用公开功能的应用程序，在设计应用程序时请尽量保证每个权限仅定义一次。如果应用程序未使用相同的证书签名，每个权限只能定义一次。即使这些应用程序都使用相同的证书进行签名，最好只定义一次权限。 如果该功能仅适用于使用于提供应用程序签名相同的签名的应用程序，则可以通过使用签名检查来避免定义自定义权限。当其中一个应用程序向另一个应用程序发出请求时，第二个应用程序可以验证这两个应用程序是否已使用相同的证书进行签名，然后再执行该请求。 如果您正在开发仅在自己的设备上安装的应用程序，则应开发并安装管理套件中所有应用程序权限的程序包。这个包不需要自己提供任何服务。它只是声明所有权限，而套件中的其他应用程序则使用元素请求这些权限。]]></content>
      <categories>
        <category>guide</category>
      </categories>
      <tags>
        <tag>guide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[API Guide之应用基础知识]]></title>
    <url>%2F2018%2F03%2F14%2FAPI%20Guide%E4%B9%8B%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Android应用的沙箱机制最小权限原则 Android操作系统是一个多用户的Linux系统，其中每个应用都是不同的用户，并且系统会为每个应用分配一个唯一的Linux用户ID（用户ID仅系统使用，应用并不知晓）。系统为应用中的所有文件设置权限，并且只可用分配给该应用的用户ID才能访问这些文件； 默认情况下，每个应用都运行在自己的Linux进程内，并且每个进程都有自己的虚拟机（VM），应用代码是在与其它应用隔离的环境中运行的。Android会在需要执行任何应用组建时启动该组件所在的进程，然后在不再需要该进程或者系统必须为其它应用提供内存时关闭该进程； 默认情况下，每个应用只能访问或执行其工作所需的组建，而并不能访问其他组件，并且应用无法访问系统中其未获取权限的部分。 共享数据和访问系统服务 两个应用共享同一Linux用户ID时，它们可以相互访问彼此的文件，同时为了节省系统资源，可以安排具有相同用户ID的应用在同一Linux进程中运行，共享同一VM（签名证书相同）。 在获取相应权限的条件下，应用可以请求访问设备中的数据（如用户的联系人、短信、可装载存储装置 [SD 卡]、相机、蓝牙等）。 应用组件 应用组件是Android应用构建的基块。每个组件都是一个不同的点，系统可以通过组件进入应用。并非所有组件都是用户的实际入口，有些组件互相依赖，但每个组件都以独立实体的形式存在，并发挥特定作用 — 每个组件都是唯一的构建基块，有助于定义应用的总体行为。共有四种类型的组件分别是：Activity、服务、内容提供者、广播接收器。 Activity Activity表示具有用户界面的单一屏幕。 服务 服务是一种在后台运行的组件，用于执行长时间运行的操作或为远程进程执行作业。 服务不提供用户界面。 例如，当用户位于其他应用中时，服务可能在后台播放音乐或者通过网络获取数据，但不会阻断用户与 Activity 的交互。 诸如 Activity 等其他组件可以启动服务，让其运行或与其绑定以便与其进行交互。 内容提供程序 内容提供程序管理一组共享的应用数据。可以将数据存储在文件系统、SQLite 数据库、网络上或者应用可以访问的任何其他永久性存储位置。 其他应用可以通过内容提供程序查询数据，甚至修改数据（如果内容提供程序允许）。 例如，Android 系统可提供管理用户联系人信息的内容提供程序。 因此，任何具有适当权限的应用都可以查询内容提供程序的某一部分（如 ContactsContract.Data），以读取和写入有关特定人员的信息。内容提供程序也适用于读取和写入应用不共享的私有数据。 例如，记事本示例应用使用内容提供程序来保存笔记。 广播接收器 广播接收器是一种用于响应系统范围广播通知的组件。 许多广播都是由系统发起的，应用自身也可以发起广播 — 例如。 尽管广播接收器不会显示用户界面，但它们可以创建状态栏通知在发生广播事件时提醒用户。 但广播接收器更常见的用途只是作为通向其他组件的“通道”，设计用于执行极少量的工作。 启动组件在 Android 系统启动应用组件之前，系统必须通过读取应用的 AndroidManifest.xml 文件（“清单”文件）确认组件存在。 应用必须在此文件中声明其所有组件，该文件必须位于应用项目目录的根目录中。 除了声明应用的组件外，清单文件还有许多其他作用，如： 确定应用需要的任何用户权限，如互联网访问权限或对用户联系人的读取权限 根据应用使用的 API，声明应用所需的最低 API 级别 声明应用使用或需要的硬件和软件功能，如相机、蓝牙服务或多点触摸屏幕 应用需要链接的 API 库（Android 框架 API 除外），如 Google 地图库 其他功能 声明组件内容 清单文件的主要任务是告知系统有关应用组件的信息。例如，清单文件可以像下面这样声明 Activity： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest ... &gt; &lt;application android:icon=&quot;@drawable/app_icon.png&quot; ... &gt; &lt;activity android:name=&quot;com.example.project.ExampleActivity&quot; android:label=&quot;@string/example_label&quot; ... &gt; &lt;/activity&gt; ... &lt;/application&gt;&lt;/manifest&gt; 在 &lt;application&gt; 元素中，android:icon 属性指向标识应用的图标所对应的资源。 在 &lt;activity&gt; 元素中，android:name 属性指定 Activity 子类的完全限定类名，android:label 属性指定用作 Activity 的用户可见标签的字符串。 必须通过以下方式声明所有应用组件： Activity 的 &lt;activity&gt; 元素 服务的 &lt;service&gt; 元素 广播接收器的 &lt;receiver&gt; 元素 内容提供程序的 &lt;provider&gt; 元素 未在清单文件中声明的 Activity、服务和内容提供程序对系统不可见，因此也永远不会运行。 不过，广播接收器可以在清单文件中声明或在代码中动态创建（如 BroadcastReceiver 对象）并通过调用 registerReceiver() 在系统中注册。 功能 可以使用 Intent 来启动 Activity、服务和广播接收器。 可以通过在 Intent 中显式命名目标组件（使用组件类名）来执行此操作。 不过，Intent 的真正强大之处在于隐式 Intent 概念。 隐式 Intent 的作用无非是描述要执行的操作类型（还可选择描述您想执行的操作所针对的数据），让系统能够在设备上找到可执行该操作的组件，并启动该组件。 如果有多个组件可以执行 Intent 所描述的操作，则由用户选择使用哪一个组件。 系统通过将接收到的 Intent 与设备上的其他应用的清单文件中提供的 Intent 过滤器进行比较来确定可以响应 Intent 的组件。 当应用在清单文件中声明 Activity 时，可以选择性地加入声明 Activity 功能的 Intent 过滤器，以便响应来自其他应用的 Intent。 您可以通过将 元素作为组件声明元素的子项进行添加来为您的组件声明 Intent 过滤器。 例如，如果您开发的电子邮件应用包含一个用于撰写新电子邮件的 Activity，则可以像下面这样声明一个 Intent 过滤器来响应“send” Intent（以发送新电子邮件），然后，如果另一个应用创建了一个包含ACTION_SEND 操作的 Intent，并将其传递到 startActivity()，则系统可能会启动您的 Activity，以便用户能够草拟并发送电子邮件。 123456789101112&lt;manifest ... &gt; ... &lt;application ... &gt; &lt;activity android:name=&quot;com.example.project.ComposeEmailActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.SEND&quot; /&gt; &lt;data android:type=&quot;*/*&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; ​ 声明应用要求 基于 Android 系统的设备多种多样，并非所有设备都提供相同的特性和功能。 为防止将您的应用安装在缺少应用所需特性的设备上，您必须通过在清单文件中声明设备和软件要求，为您的应用支持的设备类型明确定义一个配置文件。 其中的大多数声明只是为了提供信息，系统不会读取它们，但 Google Play 等外部服务会读取它们，以便当用户在其设备中搜索应用时为用户提供过滤功能。 应用资源 Android 应用并非只包含代码 — 它还需要与源代码分离的资源，如图像、音频文件以及任何与应用的视觉呈现有关的内容。 例如，您应该通过 XML 文件定义 Activity 用户界面的动画、菜单、样式、颜色和布局。 使用应用资源能够在不修改代码的情况下轻松地更新应用的各种特性，并可通过提供备用资源集让您能够针对各种设备配置（如不同的语言和屏幕尺寸）优化您的应用。 对于 Android 项目中包括的每一项资源，SDK 构建工具都会定义一个唯一的整型 ID，您可以利用它来引用应用代码或 XML 中定义的其他资源中的资源。 例如，如果您的应用包含一个名为 logo.png 的图像文件（保存在 res/drawable/ 目录中），则 SDK 工具会生成一个名为 R.drawable.logo 的资源 ID，您可以利用它来引用该图像并将其插入您的用户界面。 提供与源代码分离的资源的其中一个最重要优点在于，您可以提供针对不同设备配置的备用资源。 例如，通过在 XML 中定义 UI 字符串，您可以将字符串翻译为其他语言，并将这些字符串保存在单独的文件中。 然后，Android 系统会根据向资源目录名称追加的语言限定符（如为法语字符串值追加 res/values-fr/）和用户的语言设置，对您的 UI 应用相应的语言字符串。 Android 支持许多不同的备用资源限定符。限定符是一种加入到资源目录名称中，用来定义这些资源适用的设备配置的简短字符串。 再举一例，您应该经常会根据设备的屏幕方向和尺寸为 Activity 创建不同的布局。 例如，当设备屏幕为纵向（长型）时，您可能想要一种垂直排列按钮的布局；但当屏幕为横向（宽型）时，应按水平方向排列按钮。 要想根据方向更改布局，您可以定义两种不同的布局，然后对每个布局的目录名称应用相应的限定符。 然后，系统会根据当前设备方向自动应用相应的布局。]]></content>
      <categories>
        <category>guide</category>
      </categories>
      <tags>
        <tag>guide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity的窗口管理机制]]></title>
    <url>%2F2018%2F02%2F25%2FActivity%E7%9A%84%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[上图为Activity的窗口结构图，每一个Activity都包含了一个Window对象，而Window对象通常由PhoneWindow实现。DecorView是一个应用窗口的根容器，它本质上是一个FrameLayout。DecorView有唯一一个子View也就是LinearLayout，包含两个子元素FrameLayout，一个是装载了TitleView（ActionBar的容器），另一个是ContentView（窗口内容的容器）。我们平常用的setContentView就是设置ContentView的子View,内部实现为PhoneWindow中的setContentView()中初始化DecorView后的LayoutInflater.inflate(layoutResID, mContentParent);方法。上图还表达了每个Activity都与一个Window（具体来说是PhoneWindow）相关联，用户界面则由Window所承载。 Activity：与用户交互的可视化组件。 Window：是Activity中的顶级窗口查看和行为的一个抽象基类。该类的实例作为一个顶级View添加到WindowManager。提供了一套标准的UI方法。可以将之理解为一个载体，各种View在这个载体上显示。 PhoneWindow： WIndow的唯一实现类，可以通过该类具体去绘制窗口。 并且，该类内部包含了一个DecorView对象，DectorView对象是所有应用窗口(Activity界面)的根View。 PhoneWindow类是把DecorView对象进行一定的包装，将它作为应用窗口的根View，并提供一组通用的窗口操作接口。 DecorView： DecorView是FrameLayout的子类，它可以被认为是Android视图树的根节点视图。 DecorView作为顶级View，一般情况下它内部包含一个竖直方向的LinearLayout，在这个LinearLayout里面有上下两个部分（具体情况和Android版本及主体有关），上面的是标题栏，下面的是内容栏。 ViewRoot以及ViewRootImpl： ViewRoot对应ViewRootImpl类，它是连接WindowManagerService和DecorView的纽带，View的三大流程（测量measure，布局layout，绘制draw）均通过ViewRoot来完成。 ViewRoot与ViewRootImpl的功能是一样的，只不过是Android不同版本的不同称呼，ViewRoot在Android2.2之后就被ViewRootImpl替换了。 ViewRoot是WindowManagerGlobal工作的实际实现者，它还需要负责与WMS交互通信以调整窗口的位置大小，以及对来自WMS的事件（如窗口尺寸改变等）作出相应的处理。 WindowManager：一个继承自ViewManager的接口。ViewManager定义了三个函数，分别用于添加/删除一个控件，以及更新控件的布局。 ViewManager：该接口的另一个实现者是ViewGroup，它是容器类控件的基类，用于将一组控件容纳到自身的区域中，这一组控件被称为子控件。ViewGroup可以根据子控件的布局参数（LayoutParams）在其自身的区域中对子控件进行布局。 PhoneWindow和DecorView的关系 Activity的setContentView()方法 123456789public void setContentView(@LayoutRes int layoutResID) &#123; /* * 获取Activity中的Window,这里获取到的是在Activity中的attach方法里面吗，通过 * mWindow = new PhoneWindow(this, window, activityConfigCallback);获取需要的Window对象 */ getWindow().setContentView(layoutResID); // 在ActionBarView中创建并初始化Actionbar initWindowDecorActionBar();&#125; PhoneWindow的setContentView()方法 12345678910111213141516171819202122232425262728293031@Overridepublic void setContentView(int layoutResID) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; // 创建DecorView，并添加到mContentParent上 installDecor(); // FEATURE_CONTENT_TRANSITIONS:标记当前内容加载有没有使用过度动画(转场动画)。 // 如果内容已经加载过，并且不需要动画，则会调用removeAllViews。 // 添加完Content后如有设置了FEATURE_CONTENT_TRANSITIONS则添加Scene来过度启动。 // 否则mLayoutInflater.inflate(layoutResID, mContentParent); // 将我们的资源文件通过LayoutInflater对象转换为View树，并且添加至mContentParent视图中。 &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; // Content后如有设置了FEATURE_CONTENT_TRANSITIONS则添加Scene来过度启动 if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,getContext()); transitionTo(newScene); &#125; else &#123; // 将资源文件通过LayoutInflater对象转换为View树,并添加到mContentParent上 mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125; ​ installDecor()创建DecorView 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139private void installDecor() &#123; mForceDecorInstall = false; if (mDecor == null) &#123; // 创建DecorView mDecor = generateDecor(-1); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) &#123; mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); &#125; &#125; else &#123; mDecor.setWindow(this); &#125; // 开始DecorView未加载到mContentParent，所以此时mContentParent=null if (mContentParent == null) &#123; // 将mDecorView添加到Window上绑定布局 mContentParent = generateLayout(mDecor); // Set up decor part of UI to ignore fitsSystemWindows if appropriate. mDecor.makeOptionalFitsSystemWindows(); final DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById( R.id.decor_content_parent); if (decorContentParent != null) &#123; mDecorContentParent = decorContentParent; mDecorContentParent.setWindowCallback(getCallback()); if (mDecorContentParent.getTitle() == null) &#123; mDecorContentParent.setWindowTitle(mTitle); &#125; final int localFeatures = getLocalFeatures(); for (int i = 0; i &lt; FEATURE_MAX; i++) &#123; if ((localFeatures &amp; (1 &lt;&lt; i)) != 0) &#123; mDecorContentParent.initFeature(i); &#125; &#125; mDecorContentParent.setUiOptions(mUiOptions); if ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_ICON) != 0 || (mIconRes != 0 &amp;&amp; !mDecorContentParent.hasIcon())) &#123; mDecorContentParent.setIcon(mIconRes); &#125; else if ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_ICON) == 0 &amp;&amp; mIconRes == 0 &amp;&amp; !mDecorContentParent.hasIcon()) &#123; mDecorContentParent.setIcon( getContext().getPackageManager().getDefaultActivityIcon()); mResourcesSetFlags |= FLAG_RESOURCE_SET_ICON_FALLBACK; &#125; if ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_LOGO) != 0 || (mLogoRes != 0 &amp;&amp; !mDecorContentParent.hasLogo())) &#123; mDecorContentParent.setLogo(mLogoRes); &#125; // Invalidate if the panel menu hasn&apos;t been created before this. // Panel menu invalidation is deferred avoiding application onCreateOptionsMenu // being called in the middle of onCreate or similar. // A pending invalidation will typically be resolved before the posted message // would run normally in order to satisfy instance state restoration. PanelFeatureState st = getPanelState(FEATURE_OPTIONS_PANEL, false); if (!isDestroyed() &amp;&amp; (st == null || st.menu == null) &amp;&amp; !mIsStartingWindow) &#123; invalidatePanelMenu(FEATURE_ACTION_BAR); &#125; &#125; else &#123; mTitleView = findViewById(R.id.title); if (mTitleView != null) &#123; if ((getLocalFeatures() &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) != 0) &#123; final View titleContainer = findViewById(R.id.title_container); if (titleContainer != null) &#123; titleContainer.setVisibility(View.GONE); &#125; else &#123; mTitleView.setVisibility(View.GONE); &#125; mContentParent.setForeground(null); &#125; else &#123; mTitleView.setText(mTitle); &#125; &#125; &#125; if (mDecor.getBackground() == null &amp;&amp; mBackgroundFallbackResource != 0) &#123; mDecor.setBackgroundFallback(mBackgroundFallbackResource); &#125; // Only inflate or create a new TransitionManager if the caller hasn&apos;t // already set a custom one. // 设置转场动画 if (hasFeature(FEATURE_ACTIVITY_TRANSITIONS)) &#123; if (mTransitionManager == null) &#123; final int transitionRes = getWindowStyle().getResourceId( R.styleable.Window_windowContentTransitionManager, 0); if (transitionRes != 0) &#123; final TransitionInflater inflater = TransitionInflater.from(getContext()); mTransitionManager = inflater.inflateTransitionManager(transitionRes, mContentParent); &#125; else &#123; mTransitionManager = new TransitionManager(); &#125; &#125; mEnterTransition = getTransition(mEnterTransition, null, R.styleable.Window_windowEnterTransition); mReturnTransition = getTransition(mReturnTransition, USE_DEFAULT_TRANSITION, R.styleable.Window_windowReturnTransition); mExitTransition = getTransition(mExitTransition, null, R.styleable.Window_windowExitTransition); mReenterTransition = getTransition(mReenterTransition, USE_DEFAULT_TRANSITION, R.styleable.Window_windowReenterTransition); mSharedElementEnterTransition = getTransition(mSharedElementEnterTransition, null, R.styleable.Window_windowSharedElementEnterTransition); mSharedElementReturnTransition = getTransition(mSharedElementReturnTransition, USE_DEFAULT_TRANSITION, R.styleable.Window_windowSharedElementReturnTransition); mSharedElementExitTransition = getTransition(mSharedElementExitTransition, null, R.styleable.Window_windowSharedElementExitTransition); mSharedElementReenterTransition = getTransition(mSharedElementReenterTransition, USE_DEFAULT_TRANSITION, R.styleable.Window_windowSharedElementReenterTransition); if (mAllowEnterTransitionOverlap == null) &#123; mAllowEnterTransitionOverlap = getWindowStyle().getBoolean( R.styleable.Window_windowAllowEnterTransitionOverlap, true); &#125; if (mAllowReturnTransitionOverlap == null) &#123; mAllowReturnTransitionOverlap = getWindowStyle().getBoolean( R.styleable.Window_windowAllowReturnTransitionOverlap, true); &#125; if (mBackgroundFadeDurationMillis &lt; 0) &#123; mBackgroundFadeDurationMillis = getWindowStyle().getInteger( R.styleable.Window_windowTransitionBackgroundFadeDuration, DEFAULT_BACKGROUND_FADE_DURATION_MS); &#125; if (mSharedElementsUseOverlay == null) &#123; mSharedElementsUseOverlay = getWindowStyle().getBoolean( R.styleable.Window_windowSharedElementsUseOverlay, true); &#125; &#125; &#125;&#125; 创建DecorView 123protected DecorView generateDecor() &#123; return new DecorView(getContext(), -1);&#125; 将setContentView的内容赋值到mContentParent generateLayout会根据当前用户设置的主题去设置对应的Feature 根据对应的Feature来选择加载对应的布局文件，(Window.FEATURE_NO_TITLE)接下来通过getLocalFeatures来获取你设置的feature，进而选择加载对应的布局，因此需要在setContentView之前调用requesetFeature 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748protected ViewGroup generateLayout(DecorView decor) &#123; // Apply data from current theme. // 根据当前设置的主题来加载默认布局 TypedArray a = getWindowStyle(); // 如果你在theme中设置了window_windowNoTitle，则这里会调用到，其他方法同理， // 这里是根据你在theme中的设置去设置的 if (a.getBoolean(R.styleable.Window_windowNoTitle, false)) &#123; requestFeature(FEATURE_NO_TITLE); &#125; else if (a.getBoolean(R.styleable.Window_windowActionBar, false)) &#123; // Don&apos;t allow an action bar if there is no title. requestFeature(FEATURE_ACTION_BAR); &#125; // 是否有设置全屏 if (a.getBoolean(R.styleable.Window_windowFullscreen, false)) &#123; setFlags(FLAG_FULLSCREEN, FLAG_FULLSCREEN &amp; (~getForcedWindowFlags())); &#125; ...//省略其他加载资源 /* * 添加布局到DecorView，前面说到，DecorView是继承与FrameLayout，它本身也是一个 * ViewGroup，而我们前面创建它的时候，只是调用了new DecorView，此时里面并无什么东西。而下 * 面的步奏则是根据用户设置的Feature来创建相应的默认布局主题。举个例子，如果我在 * setContentView之前调用了 requestWindowFeature(Window.FEATURE_NO_TITLE)，这里则会通 * 过getLocalFeatures来获取你设置的feature，进而选择加载对应的布局，此时是加载没有标题栏 * 的主题，对应的就是R.layout.screen_simple */ int layoutResource; int features = getLocalFeatures(); // System.out.println(&quot;Features: 0x&quot; + Integer.toHexString(features)); if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) &#123; layoutResource = R.layout.screen_swipe_dismiss; &#125; ... //省略其他判断方法 &#125; else &#123; // Embedded, so no decoration is needed. layoutResource = R.layout.screen_simple; // System.out.println(&quot;Simple!&quot;); &#125; mDecor.startChanging(); // 选择对应布局创建添加到DecorView中 View in = mLayoutInflater.inflate(layoutResource, null); decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); mContentRoot = (ViewGroup) in; ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); ... return contentParent; &#125; ​ 通知界面改变 调用Callback来通知界面发生改变。Callback是Window里面的一个接口，里面声明了当界面更改触摸时调用的各种方法。 而通知改变的回掉方法就是onContentChanged，在PhoneWindow里面并没有看到onContentChanged的实现类，而我们又知道Activity本身又是加载在Window上的，所以如下： 12345public class Activity extends ContextThemeWrapper implements LayoutInflater.Factory2, Window.Callback, KeyEvent.Callback, OnCreateContextMenuListener, ComponentCallbacks2, Window.OnWindowDismissedCallback &#123; ... &#125; Activity里面实现了Window.Callback接口而里面onContentChanged则是空的，因此可以重写改方法来监听布局的改变 12public void onContentChanged() &#123;&#125; ​ DecorView的添加 在Activity的启动过程中会执行ActivityThread#performLaunchActivity方法，其中调用Activity#attach。在attach()方法中实例化Activity持有的mWindow属性为Window的唯一实现类PhoneWindow。 在ActivityThread#handleResumeActivity中，通过wm.addView(decor, l);往 Window 添加 View。 123456789final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123; ... if (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123; a.mWindowAdded = true; wm.addView(decor, l);//往 Window 添加 View。vm为该Activity的WindowManager &#125; ...&#125; WindowManager 是一个接口，因此 addView 的操作是有其子类去实现的，而 WindowManager 的实现类就是 WindowManagerImpl。然而WindowManagerImpl又将其交由WindowManagerGlobal实现。 123456@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); // private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance(); mGlobal.addView(view, params, mDisplay, mParentWindow);&#125; WindowManagerGlobal.addView 的过程 创建ViewRootImpl实例; 在 addView 中创建 Window 对应的 ViewRootImpl 对象。并且往mViews、mRootsmParams、mDyingViews 中保存当前 View 的信息。最后调用 root.setView(view, wparams, panelParentView); 12345678910111213141516171819202122232425262728293031public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; //校验操作 final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; int index = findViewLocked(view, false); if (index &gt;= 0) &#123; if (mDyingViews.contains(view)) &#123; // Don&apos;t wait for MSG_DIE to make it&apos;s way through root&apos;s queue. mRoots.get(index).doDie(); &#125; else &#123; throw new IllegalStateException(&quot;View &quot; + view + &quot; has already been added to the window manager.&quot;); &#125; // The previous removeView() had not completed executing. Now it has. &#125; //创建 ViewRootImpl 对象。 root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); //保存到集合中 mViews.add(view); mRoots.add(root); mParams.add(wparams); &#125; // 调用 View 的绘制代码 root.setView(view, wparams, panelParentView);&#125; DecorView的真正显示 现在 Window 对应的视图已经准备好了，但是仍为不可见的，在ActivityThread#handleResumeActivity 代码。这时会去调用 Activity#makeVisible()方法。ActivityThread#handleResumeActivity中 DecorView 被设置为 invisible 因此在这时Decor 会被设置为 View.VISIBLE。至此 View 就真正的显示出来了。 123456789101112131415// ActivityThread#handleResumeActivityr.activity.mVisibleFromServer = true;if (r.activity.mVisibleFromClient) &#123; r.activity.makeVisible();&#125;// Activity#makeVisible()void makeVisible() &#123; if (!mWindowAdded) &#123;//判断 DecorView 是否被添加到 Window 中 ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; &#125; mDecor.setVisibility(View.VISIBLE);//让 View 设置为可见&#125; View的绘制 View的绘制流程从ViewRoot或ViewRootImpl开始的，经过measure、layout和draw三个过程才能最终绘制一个View。 measure 测量视图的大小的。View系统的绘制流程会从ViewRoot的performTraversals()方法中开始，在其内部调用View的measure()方法。 measure()方法接收两个参数，widthMeasureSpec和heightMeasureSpec，这两个值分别用于确定视图的宽度和高度的规格和大小。widthMeasureSpec和heightMeasureSpec由getRootMeasureSpec(windowSize, rootDimension)方法获得。注意方法中传入的参数，其中lp.width和lp.height在创建ViewGroup实例的时候就被赋值了，它们都等于MATCH_PARENT。 12childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width); childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height); 1234567891011121314151617181920212223242526272829303132/** * Figures out the measure spec for the root view in a window based on it&apos;s * layout params. * * @param windowSize * The available width or height of the window * * @param rootDimension * The layout params for one dimension (width or height) of the * window. * * @return The measure spec to use to measure the root view. */private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123; int measureSpec; switch (rootDimension) &#123; case ViewGroup.LayoutParams.MATCH_PARENT: // Window can&apos;t resize. Force root view to be windowSize. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT: // Window can resize. Set max size for root view. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default: // Window wants to be an exact size. Force root view to be that size. measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; &#125; return measureSpec;&#125; MeasureSpec：由specSize和specMode共同组成的，其中specSize记录的是大小，specMode记录的是规格。specMode一共有三种类型： EXACTLY：表示父视图希望子视图的大小应该是由specSize的值来决定的，系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。 AT_MOST：表父容器指定了一个可用大小即 SpecSize ,子视图最多只能是 specSize 中指定的大小，开发人员应该尽可能小得去设置这个视图，并且保证不会超过specSize。系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。 UNSPECIFIED：表示开发人员可以将视图按照自己的意愿设置成任意的大小，没有任何限制。这种情况比较少见，不太会用到。 measure从父容器传递到子元素中所以 View 的 measure 是由ViewGroup的measureChildWithMargins() 方法传递而来，在该方法中measure子元素之前会通过 getChildMeasureSpec方法来得到子元素的MeasureSpec 。 measureChildWithMargins()： 12345678910111213protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; getChildMeasureSpec()：根据父容器的 MeasureSpec 同时结合 View 本身的 LayoutParams 来确定子元素的 MeasureSpec ，参数中的 padding 是指父容器中已占空间的大小，因此子元素的可用大小位父容器的的尺寸减去 padding。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can&apos;t be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) &#123; // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can&apos;t be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; //noinspection ResourceType return MeasureSpec.makeMeasureSpec(resultSize, resultMode); &#125;]]></content>
      <categories>
        <category>Android源码分析</category>
      </categories>
      <tags>
        <tag>Android源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View之measure源码分析]]></title>
    <url>%2F2018%2F02%2F23%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8Bmeasure%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[measure方法概述 若该view与其父view对于是否使用视觉布局边界的策略不一致，那么将对widthMeasureSpec和heightMeasureSpec进行偏移量校正。 通过widthMeasureSpec和heightMeasureSpec计算出存储在mMeasureCache对象中量算值所需要的key。 判断缓存对象mMeasureCache是否存在，若不存在则创建缓存对象。 判断是否强制测量、与旧值是否相同、是否给定了精确大小、之前测量的到底。宽高与穿进来的宽高是否相同、是否需要重新布局。 在需要强制测量或者需要重新布局情况下，如果缓存中没有值或忽略缓存结果情况下传入值 onMeasure(widthMeasureSpec, heightMeasureSpec)进行测量，测量结束后 重置View的状态mPrivateFlags将其标记为在layout之前不必再进行量算的状态。如果缓存中有值或不忽略缓存结果情况下，获取缓存中的值并 调用setMeasuredDimensionRaw方法将当前量算的结果到成员变量中。 如果自定义的View重写了onMeasure方法，但是没 有调用setMeasuredDimension()方法,那么就会抛出异常。 在量算完成后将这次新传入的MeasureSpec赋值给它们。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** * &lt;p&gt; * This is called to find out how big a view should be. The parent * supplies constraint information in the width and height parameters. * &lt;/p&gt; * * &lt;p&gt; * The actual measurement work of a view is performed in * &#123;@link #onMeasure(int, int)&#125;, called by this method. Therefore, only * &#123;@link #onMeasure(int, int)&#125; can and must be overridden by subclasses. * &lt;/p&gt; * * * @param widthMeasureSpec Horizontal space requirements as imposed by the * parent * @param heightMeasureSpec Vertical space requirements as imposed by the * parent * * @see #onMeasure(int, int) */public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; // 判断是否使用视觉布局边界 boolean optical = isLayoutModeOptical(this); // 如果该view与其父view对于是否使用视觉布局边界的策略不一致 if (optical != isLayoutModeOptical(mParent)) &#123; // Insets实例包含四个整数偏移量，这些偏移量描述了对矩形四个边的更改。 /* * getOpticalInsets()获取偏移量insets，如果该View存在background则调用该background的 * getOpticalInsets()方法获取偏移量，若不存在background则偏移量为Insets.None即为0. */ Insets insets = getOpticalInsets(); int oWidth = insets.left + insets.right; int oHeight = insets.top + insets.bottom; // 该View使用视觉布局边界的话widthMeasureSpec、heightMeasureSpec中的宽和高数值size需减去偏移量 widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth); heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight); &#125; // Suppress sign extension for the low bytes // 计算key值 long key = (long) widthMeasureSpec &lt;&lt; 32 | (long) heightMeasureSpec &amp; 0xffffffffL; // mMeasureCache中缓存着View在不同widthMeasureSpec、heightMeasureSpec下量算过的结果 if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2); // 是否强制测量 final boolean forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT; // Optimize layout by avoiding an extra EXACTLY pass when the view is // already measured as the correct size. In API 23 and below, this // extra pass is required to make LinearLayout re-distribute weight. // 判断是否与旧值是否相同 final boolean specChanged = widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec; // 判断是否给定了精确的大小 final boolean isSpecExactly = MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY &amp;&amp; MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY; // 判断之前设置的measuredWidth、measuredHeight与现在传过来的数值是否相同 final boolean matchesSpecSize = getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec) &amp;&amp; getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec); // 若是需要重新测量、未给定精确度大小、measuredWidth、measuredHeight与现在数值不同则需要重新布局 final boolean needsLayout = specChanged &amp;&amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize); // 如果需要强制测量或者需要重新布局 if (forceLayout || needsLayout) &#123; // first clears the measured dimension flag // 通过按位操作，重置View的状态mPrivateFlags，将其标记为未量算状态 mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET; // 对阿拉伯语、希伯来语等从右到左书写、布局的语言进行特殊处理 resolveRtlPropertiesIfNeeded(); /* 在View真正进行量算之前，View进一步确认能否从已有的缓存mMeasureCache中读取缓存过的量算结果 * 若是强制layout导致的量算，那么将cacheIndex设置为-1，即不从缓存中读取量算结果 * 若不是强制layout导致的量算，那就用上面根据measureSpec计算出来的key值作为缓存索引cacheIndex。 ＊／ int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key); // 是否能找到缓存过的量算结果或者是否忽略缓存结果 if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123; // measure ourselves, this should set the measured dimension flag back // 调用onMeasure方法，并把尺寸限制条件widthMeasureSpec和heightMeasureSpec传入进去 // onMeasure方法中将会进行实际的量算工作，并把量算的结果保存到成员变量中 onMeasure(widthMeasureSpec, heightMeasureSpec); // onMeasure执行完后通过位操作， // 重置View的状态mPrivateFlags将其标记为在layout之前不必再进行量算的状态 mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; else &#123; // 获取缓存中的值 long value = mMeasureCache.valueAt(cacheIndex); // Casting a long to int drops the high 32 bits, no mask needed // 调用setMeasuredDimensionRaw方法将当前量算的结果到成员变量中 setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value); mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; // flag not set, setMeasuredDimension() was not invoked, we raise // an exception to warn the developer /* * 此处检查mPrivateFlags是否含有PFLAG_MEASURED_DIMENSION_SET状态即可判断setMeasuredDimension * 是否被调用，因为setMeasuredDimension()方法中会将mPrivateFlags设置为 * PFLAG_MEASURED_DIMENSION_SET状态，即已量算状态，如果自定义的View重写了onMeasure方法，但是没 * 有调用setMeasuredDimension()方法,那么就会抛出异常 */ if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123; throw new IllegalStateException(&quot;View with id &quot; + getId() + &quot;: &quot; + getClass().getName() + &quot;#onMeasure() did not set the&quot; + &quot; measured dimension by calling&quot; + &quot; setMeasuredDimension()&quot;); &#125; mPrivateFlags |= PFLAG_LAYOUT_REQUIRED; &#125; // mOldWidthMeasureSpec和mOldHeightMeasureSpec保存着最近一次量算时的MeasureSpec， // 在量算完成后将这次新传入的MeasureSpec赋值给它们 mOldWidthMeasureSpec = widthMeasureSpec; mOldHeightMeasureSpec = heightMeasureSpec; // 缓存本次量算的结果，以key作为键，量算结果作为值缓存在变量mMeasureCache中 mMeasureCache.put(key, ((long) mMeasuredWidth) &lt;&lt; 32 | (long) mMeasuredHeight &amp; 0xffffffffL); // suppress sign extension&#125; onMesure方法概述###onMeasure方法 1234protected void onMeasure( int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension( getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; getDefaultSize获取默认宽高123456789101112131415public static int getDefaultSize (int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec. getMode(measureSpec); int specSize = MeasureSpec. getSize(measureSpec); switch (specMode) &#123; case MeasureSpec. UNSPECIFIED: result = size; break; case MeasureSpec. AT_MOST: case MeasureSpec. EXACTLY: result = specSize; break; &#125; return result;&#125; ###为宽度获取建议最小值 12345678protected int getSuggestedMinimumWidth () &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth , mBackground.getMinimumWidth());&#125;public int getMinimumWidth()&#123; final int intrinsicWhidth = getIntrinsicWidtth(); retrun intrinsicWhidth &gt; 0 ? intrinsicWhidth : 0 ;&#125;]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View之布局]]></title>
    <url>%2F2018%2F02%2F10%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8B%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[布局过程 布局过程，就是程序在运行时利用布局文件的代码来计算出实际尺寸的过程。 测量阶段measure()测量的过程 从上到下递归地调用每个 View 或者 ViewGroup 的 measure() 方法，测量他们的尺寸并计算它们的位置； measure() 方法被父 View 调用，在 measure() 中做一些准备和优化工作后，调用 onMeasure() 来进行实际的自我测量。 onMeasure() 在View 和 ViewGroup所进行的操作并不相同： View：View 在 onMeasure() 中会计算出自己的尺寸然后保存； ViewGroup：ViewGroup 在 onMeasure() 中会调用所有子 View 的 measure() 让它们进行自我测量，并根据子 View 计算出的期望尺寸来计算出它们的实际尺寸和位置然后保存。同时，它也会根据子 View 的尺寸和位置来计算出自己的尺寸然后保存； 布局阶段layout() 从上到下递归地调用每个 View 或者 ViewGroup 的 layout() 方法，把测得的它们的尺寸和位置赋值给它们。 layout() 方法被父 View 调用，在 layout() 中它会保存父 View 传进来的自己的位置和尺寸，并且调用 onLayout() 来进行实际的内部布局。onLayout() 在 View 和 ViewGroup所进行的操作并不相同： View：由于没有子 View，所以 View 的 onLayout() 什么也不做。 ViewGroup：ViewGroup 在 onLayout() 中会调用自己的所有子 View 的 layout() 方法，把它们的尺寸和位置传给它们，让它们完成自我的内部布局。 自定义布局的方式重写 onMeasure() 来修改已有的 View 的尺寸 重写 onMeasure() 方法，并在里面调用 super.onMeasure()，触发原有的自我测量； 在 super.onMeasure() 的下面用 getMeasuredWidth() 和 getMeasuredHeight() 来获取到之前的测量结果，并使用自己的算法，根据测量结果计算出新的结果； 调用 setMeasuredDimension() 来保存新的结果。 重写 onMeasure() 来全新定制自定义 View 的尺寸父 View 的尺寸限制 由来：开发者的要求（布局文件中 layout_ 打头的属性）经过父 View 处理计算后的更精确的要求； 限制的分类： UNSPECIFIED：不限制 AT_MOST：限制上限 EXACTLY：限制固定值 自定义方式 重新 onMeasure()，并计算出 View 的尺寸； 使用 resolveSize() 来让子 View 的计算结果符合父 View 的限制（如果想用自己的方式来满足父 View 的限制也行）。 重写 onMeasure() 和 onLayout() 来全新定制自定义 ViewGroup 的内部布局定制 Layout 内部布局的方式 重写 onMeasure() 来计算内部布局 重写 onLayout() 来摆放子 View 重写 onMeasure() 的三个步骤 调用每个子 View 的 measure() 来计算子 View 的尺寸 计算子 View 的位置并保存子 View 的位置和尺寸 计算自己的尺寸并用 setMeasuredDimension() 保存 计算子 View 尺寸的关键计算子 View 的尺寸，关键在于 measure() 方法的两个参数——也就是子 View 的两个 MeasureSpec 的计算。 子 View 的 MeasureSpec 的计算方式： 结合开发者的要求（xml 中 layout_ 打头的属性）和自己的可用空间（自己的尺寸上限 - 已用尺寸） 尺寸上限根据自己的 MeasureSpec 中的 mode 而定 EXACTLY / AT_MOST：尺寸上限为 MeasureSpec 中的 size UNSPECIFIED：尺寸无上限 重写 onLayout() 的方式在 onLayout() 里调用每个子 View 的 layout() ，让它们保存自己的位置和尺寸。]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View之硬件加速]]></title>
    <url>%2F2018%2F02%2F09%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8B%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%2F</url>
    <content type="text"><![CDATA[本质和原理概念 所谓硬件加速，指的是把某些计算工作交给专门的硬件来做，而不是和普通的计算工作一样交给 CPU 来处理。这样不仅减轻了 CPU 的压力，而且由于有了「专人」的处理，这份计算工作的速度也被加快了。这就是「硬件加速」。 对于 Android 来说，硬件加速有它专属的意思：在 Android 里，硬件加速专指把 View 中绘制的计算工作交给 GPU 来处理。进一步地再明确一下，这个「绘制的计算工作」指的就是把绘制方法中的那些 Canvas.drawXXX() 变成实际的像素这件事。 原理 未开启硬件加速：Canvas 绘制的工作方式是：把要绘制的内容写进一个 Bitmap，然后在之后的渲染过程中，这个 Bitmap 的像素内容被直接用于渲染到屏幕。这种绘制方式的主要计算工作在于把绘制操作转换为像素的过程（例如由一句 Canvas.drawCircle() 来获得一个具体的圆的像素信息），这个过程的计算是由 CPU 来完成的，过程如下图： 开启硬件加速：只是把绘制的内容转换为 GPU 的操作保存了下来，然后就把它交给 GPU，最终由 GPU 来完成实际的显示工作。过程如下图： Android中的应用 硬件加速开启后，绘制的计算工作由 CPU 转交给了 GPU。那么硬件加速能够让绘制变快，主要有三个原因： 本来由 CPU 自己来做的事，分摊给了 GPU 一部分，自然可以提高效率； 相对于 CPU 来说，GPU 自身的设计本来就对于很多常见类型内容的计算（例如简单的圆形、简单的方形）具有优势； 由于绘制流程的不同，硬件加速在界面内容发生重绘的时候绘制流程可以得到优化，避免了一些重复操作，从而大幅提升绘制效率。 硬件加速绘制变快的机制： 在硬件加速关闭时，绘制内容会被 CPU 转换成实际的像素，然后直接渲染到屏幕。具体来说，这个「实际的像素」，它是由 Bitmap 来承载的。在界面中的某个 View 由于内容发生改变而调用 invalidate() 方法时，如果没有开启硬件加速，那么为了正确计算 Bitmap 的像素，这个 View 的父 View、父 View 的父 View 乃至一直向上直到最顶级 View，以及所有和它相交的兄弟 View，都需要被调用 invalidate()来重绘。一个 View 的改变使得大半个界面甚至整个界面都重绘一遍，这个工作量是非常大的。 而在硬件加速开启时，绘制的内容会被转换成 GPU 的操作保存下来（承载的形式称为 display list，对应的类也叫做 DisplayList），再转交给 GPU。由于所有的绘制内容都没有变成最终的像素，所以它们之间是相互独立的，那么在界面内容发生改变的时候，只要把发生了改变的 View 调用 invalidate()方法以更新它所对应的 GPU 操作就好，至于它的父 View 和兄弟 View，只需要保持原样。那么这个工作量就很小了。 限制 受到 GPU 绘制方式的限制，Canvas 的有些方法在硬件加速开启式会失效或无法正常工作。比如，在硬件加速开启时， clipPath() 在 API 18 及以上的系统中才有效。具体的 API 限制和 API 版本的关系如下图： View Layer 关闭硬件加速：view.setLayerType(LAYER_TYPE_SOFTWARE, null); setLayerType() 方法本来作用并不是用来开关硬件加速的，只是当它的参数为 LAYER_TYPE_SOFTWARE 的时候，可以「顺便」把硬件加速关掉而已；并且除了这个方法之外，Android 并没有提供专门的 View 级别的硬件加速开关，所以它就「顺便」成了一个开关硬件加速的方法。 View Layer，又称为离屏缓冲（Off-screen Buffer），它的作用是单独启用一块地方来绘制这个 View ，而不是使用软件绘制的 Bitmap 或者通过硬件加速的 GPU。这块「地方」可能是一块单独的 Bitmap，也可能是一块 OpenGL 的纹理（texture，OpenGL 的纹理可以简单理解为图像的意思），具体取决于硬件加速是否开启。采用什么来绘制 View 不是关键，关键在于当设置了 View Layer 的时候，它的绘制会被缓存下来，而且缓存的是最终的绘制结果，而不是像硬件加速那样只是把 GPU 的操作保存下来再交给 GPU 去计算。通过这样更进一步的缓存方式，View 的重绘效率进一步提高了：只要绘制的内容没有变，那么不论是 CPU 绘制还是 GPU 绘制，它们都不用重新计算，而只要只用之前缓存的绘制结果就可以了。基于这样的原理，在进行移动、旋转等（无需调用 invalidate()）的属性动画的时候开启 Hardware Layer 将会极大地提升动画的效率，因为在动画过程中 View 本身并没有发生改变，只是它的位置或角度改变了，而这种改变是可以由 GPU 通过简单计算就完成的，并不需要重绘整个 View。所以在这种动画的过程中开启 Hardware Layer，可以让本来就依靠硬件加速而变流畅了的动画变得更加流畅。实现方式大概是这样： 123456789101112131415view.setLayerType(LAYER_TYPE_HARDWARE, null); ObjectAnimator animator = ObjectAnimator.ofFloat(view, &quot;rotationY&quot;, 180);animator.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; view.setLayerType(LAYER_TYPE_NONE, null); &#125;&#125;);animator.start(); // 或者如果是使用 ViewPropertyAnimator，那么更简单：view.animate() .rotationY(90) .withLayer(); // withLayer() 可以自动完成上面这段代码的复杂操作 注意： 这种方式不适用于基于自定义属性绘制的动画 除了用于关闭硬件加速和辅助属性动画这两项功能外，Layer 还可以用于给 View 增加一些绘制效果，例如设置一个 ColorMatrixColorFilter 来让 View 变成黑白的： 1234567ColorMatrix colorMatrix = new ColorMatrix(); colorMatrix.setSaturation(0);Paint paint = new Paint(); paint.setColorFilter(new ColorMatrixColorFilter(colorMatrix));view.setLayerType(LAYER_TYPE_HARDWARE, paint); 由于设置了 View Layer 后，View 在初次绘制时以及每次 invalidate() 后重绘时，需要进行两次的绘制工作（一次绘制到 Layer，一次从 Layer 绘制到显示屏），所以其实它的每次绘制的效率是被降低了的。所以一定要慎重使用 View Layer，在需要用到它的时候再去使用。 总结 硬件加速指的是使用 GPU 来完成绘制的计算工作，代替 CPU。它从工作分摊和绘制机制优化这两个角度提升了绘制的速度。 硬件加速可以使用 setLayerType() 来关闭硬件加速，但这个方法其实是用来设置 View Layer 的： 参数为 LAYER_TYPE_SOFTWARE 时，使用软件来绘制 View Layer，绘制到一个 Bitmap，并顺便关闭硬件加速； 参数为 LAYER_TYPE_HARDWARE 时，使用 GPU 来绘制 View Layer，绘制到一个 OpenGL texture（如果硬件加速关闭，那么行为和 VIEW_TYPE_SOFTWARE 一致）； 参数为 LAYER_TYPE_NONE 时，关闭 View Layer。 View Layer 可以加速无 invalidate() 时的刷新效率，但对于需要调用 invalidate() 的刷新无法加速。 View Layer 绘制所消耗的实际时间是比不使用 View Layer 时要高的，所以要慎重使用。]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定View之属性动画]]></title>
    <url>%2F2018%2F02%2F07%2F%E8%87%AA%E5%AE%9AView%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[ViewPropertyAnimator View 的每个方法都对应了 ViewPropertyAnimator 的两个方法，其中一个是带有 -By 后缀的，例如，View.setTranslationX() 对应了 ViewPropertyAnimator.translationX() 和 ViewPropertyAnimator.translationXBy() 这两个方法。其中带有 -By() 后缀的是增量版本的方法，例如，translationX(100) 表示用动画把 View 的 translationX 值渐变为 100，而 translationXBy(100) 则表示用动画把 View 的 translationX 值渐变地增加 100 ViewPropertyAnimator介绍 专门针对View对象动画而操作的类。 支持链式操作，提供了更简洁调用设置多个属性动画方式，这些动画可以同时进行的。 拥有更好的性能，多个属性动画是一次同时变化，只执行一次UI刷新（也就是只调用一次invalidate,而n个ObjectAnimator就会进行n次属性变化，就有n次invalidate）。 每个属性提供两种类型方法设置。 该类只能通过View的animate()获取其实例对象的引用 ViewPropertyAnimator使用方式1234view.animate() .scaleX(1) .scaleY(1) .alpha(1); View.animate()之后配合下图种的translationX()、translationY()、rotation()、alpha()等方法。 ObjectAnimator使用方法： 如果是自定义控件，需要添加 setter / getter 方法，setter方法中需要在修改属性的值之后主动的通知界面重绘，也就是使用invalidate()方法，它会把之前绘制的内容标记位失效，在下一帧到来时View不会延用上一帧的内容，而是会自动调用draw()方法来重新绘制内容，这样才会刷新内容； 用 ObjectAnimator.ofXXX(目标对象,属性名,目标值 ) 创建 ObjectAnimator 对象，它会根据填写的属性名拼接成相应的setxx方法； 用 start() 方法执行动画。 1public class ProgressView extends View &#123; float progress = 0; Paint paint = new Paint(); RectF acres = new RectF(); public void setProgress(float progress){ this.progress = progress; invalidate(); } public float getProgress() { return progress; } public ProgressView(Context context) { super(context); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); paint.setColor(Color.parseColor(&quot;#FFFFFFF&quot;)); canvas.drawArc(acres, 135, progress * 2.7f, false, paint); } /** * ObjectAnimator mObjectAnimator = ObjectAnimator.ofFloat(this,&quot;progress&quot;,0,65); * mObjectAnimator.start(); */ } 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768### 通用功能：- setDuration(int duration) 设置动画时长- setInterpolator(Interpolator interpolator) 设置 Interpolator（设置插值器）### 插值器Interpolator：&gt; 根据时动画的时间完成度计算所对应的动画完成程度，可以说是一个速度设置器- **匀速**：LinearInterpolator；- **持续加速**：AccelerateInterpolator，主要用在离场效果中，比如某个物体从界面中飞离，就可以用这种效果。它给人的感觉就会是「从零起步，加速飞走了」。到了最后动画骤停的时候，物体已经飞出用户视野，看不到了，所以并不会察觉到这个骤停的；- **持续减速直到 0**：DecelerateInterpolator，主要用于入场效果，比如某个物体从界面的外部飞入界面后停在某处；- **蓄力**：AnticipateInterpolator先回拉一下再进行正常动画轨迹。效果看起来有点像投掷物体或跳跃等动作前的蓄力。平移动画，那么就是位置上的回拉；如果是放大动画，那么就是先缩小一下再放大；其他类型的动画同理；- **回弹**：OvershootInterpolator，动画会超过目标值一些，然后再弹回来；- **蓄力+回弹**：AnticipateOvershootInterpolator；- **正/余弦曲线**：CycleInterpolator可以自定义曲线的周期，所以动画可以不到终点就结束，也可以到达终点后回弹，回弹的次数由曲线的周期决定，曲线的周期由 `CycleInterpolator()` 构造方法的参数决定；- **自定义动画完成度 / 时间完成度曲线**：PathInterpolator，定制的方式是使用一个 `Path` 对象来绘制出你要的动画完成度 / 时间完成度曲线；- **贝塞尔加速**：FastOutLinearInInterpolator，和`AccelerateInterpolator` 一样，都是一个持续加速的运动路线。只不过 `FastOutLinearInInterpolator` 的曲线公式是用的贝塞尔曲线，而 `AccelerateInterpolator` 用的是指数曲线。具体来说，它俩最主要的区别是 `FastOutLinearInInterpolator` 的初始阶段加速度比 `AccelerateInterpolator` 要快一些； ![加速的AccelerateInterpolator与FastOutLinearInInterpolator的速度模型图](http://ouv36g1sw.bkt.clouddn.com/%E5%8A%A0%E9%80%9F%E7%9A%84AccelerateInterpolator%E4%B8%8EFastOutLinearInInterpolator%E7%9A%84%E9%80%9F%E5%BA%A6%E6%A8%A1%E5%9E%8B%E5%9B%BE)- **贝塞尔先加速再减速**：FastOutSlowInInterpolator，同样也是先加速再减速的还有前面说过的 `AccelerateDecelerateInterpolator`，不过它们的效果是明显不一样的。`FastOutSlowInInterpolator` 用的是贝塞尔曲线，`AccelerateDecelerateInterpolator` 用的是正弦 / 余弦曲线。具体来讲， `FastOutSlowInInterpolator` 的前期加速度要**快得多**。 ![先加速在减速的AccelerateDecelerateInterpolator与FastOutSlowInInterpolator速度模型图](http://ouv36g1sw.bkt.clouddn.com/%E5%85%88%E5%8A%A0%E9%80%9F%E5%9C%A8%E5%87%8F%E9%80%9F%E7%9A%84AccelerateDecelerateInterpolator%E4%B8%8EFastOutSlowInInterpolator%E9%80%9F%E5%BA%A6%E6%A8%A1%E5%9E%8B%E5%9B%BE)- **贝塞尔持续减速**：LinearOutSlowInInterpolator，和 `DecelerateInterpolator` 比起来，同为减速曲线，主要区别在于 `LinearOutSlowInInterpolator` 的初始速度更高。对于人眼的实际感觉，区别其实也不大，不过还是能看出来一些的。 ![持续减速的DecelerateInterpolator与LinearOutSlowInInterpolator的速度模型图](http://ouv36g1sw.bkt.clouddn.com/%E6%8C%81%E7%BB%AD%E5%87%8F%E9%80%9F%E7%9A%84DecelerateInterpolator%E4%B8%8ELinearOutSlowInInterpolator%E7%9A%84%E9%80%9F%E5%BA%A6%E6%A8%A1%E5%9E%8B%E5%9B%BE)### 设置监听器&gt; 给动画设置监听器，可以在关键时刻得到反馈，从而做出适合的操作- ViewPropertyAnimator.setListener() / ObjectAnimator.addListener() - 动画开始时回掉：` onAnimationStart(Animator animation)` - 动画结束时回掉：` onAnimationEnd(Animator animation)` - 动画取消时回掉：` onAnimationCancel(Animator animation)` - 动画重复执行是回掉：`onAnimationRepeat(Animator animation)`当动画通过 `setRepeatMode()` / `setRepeatCount()` 或 `repeat()` 方法重复执行时，这个方法被调用。由于 `ViewPropertyAnimator` 不支持重复，所以这个方法对 `ViewPropertyAnimator` 相当于无效。- ViewPropertyAnimator.setUpdateListener() / ObjectAnimator.addUpdateListener() - 和 上面的两个方法一样，这两个方法虽然名称和可设置的监听器数量不一样，但本质其实都一样的，它们的参数都是 `AnimatorUpdateListener`。但是它只有一个回调方法：`onAnimationUpdate(ValueAnimator animation)` - 当动画的属性更新时回掉：`onAnimationUpdate(ValueAnimator animation)`，方法的参数是一个 `ValueAnimator`，`ValueAnimator` 是 `ObjectAnimator` 的父类，也是 `ViewPropertyAnimator` 的内部实现，所以这个参数其实就是 `ViewPropertyAnimator` 内部的那个 `ValueAnimator`，或者对于 `ObjectAnimator` 来说就是它自己本身。- ObjectAnimator.addPauseListener()- ViewPropertyAnimator.withStartAction/EndAction() 这两个方法是 `ViewPropertyAnimator` 的独有方法。它们和 `set/addListener()` 中回调的 `onAnimationStart()` / `onAnimationEnd()` 相比起来的不同主要有两点： - `withStartAction()` / `withEndAction()` 是一次性的，在动画执行结束后就自动弃掉了，就算之后再重用 `ViewPropertyAnimator` 来做别的动画，用它们设置的回调也不会再被调用。而 `set/addListener()` 所设置的 `AnimatorListener` 是持续有效的，当动画重复执行时，回调总会被调用。 - `withEndAction()` 设置的回调只有在动画正常结束时才会被调用，而在动画被取消时不会被执行。这点和 `AnimatorListener.onAnimationEnd()` 的行为是不一致的。### 估值器TypeEvaluator&gt; 对指定的某个类型的参数设定一个算法来计算动画完成度与参数的关系&gt;&gt; 估值器用来确定在动画过程中每时每刻动画的执行程度值，从动画完成度转变为实际属性值。 public interface TypeEvaluator { /** * @param fraction The fraction from the starting to the ending values * 表示当前这段数值变化值得比例 * @param startValue The start value. 表示当前这段数值变化的开始值 * @param endValue The end value. 表示当前这段数据变化的结束值 * @return A linear interpolation between the start and end values, given the * &lt;code&gt;fraction&lt;/code&gt; parameter. 返回插值器 */ public T evaluate(float fraction, T startValue, T endValue); } 123456789101112#### 类型- ArgbEvaluator：可用于执行表示ARGB颜色的整数值之间的类型插值- FloatArrayEvaluator- FloatEvaluator- IntArrayEvaluator- IntEvaluator- PointFEvaluator- RectEvaluator#### 自定义 Evaluator // 自定义 HslEvaluatorprivate class HsvEvaluator implements TypeEvaluator { float[] startHsv = new float[3]; float[] endHsv = new float[3]; float[] outHsv = new float[3]; @Override public Integer evaluate(float fraction, Integer startValue, Integer endValue) { // 把 ARGB 转换成 HSV Color.colorToHSV(startValue, startHsv); Color.colorToHSV(endValue, endHsv); // 计算当前动画完成度（fraction）所对应的颜色值 if (endHsv[0] - startHsv[0] &gt; 180) { endHsv[0] -= 360; } else if (endHsv[0] - startHsv[0] &lt; -180) { endHsv[0] += 360; } outHsv[0] = startHsv[0] + (endHsv[0] - startHsv[0]) * fraction; if (outHsv[0] &gt; 360) { outHsv[0] -= 360; } else if (outHsv[0] &lt; 0) { outHsv[0] += 360; } outHsv[1] = startHsv[1] + (endHsv[1] - startHsv[1]) * fraction; outHsv[2] = startHsv[2] + (endHsv[2] - startHsv[2]) * fraction; // 计算当前动画完成度（fraction）所对应的透明度 int alpha = startValue &gt;&gt; 24 + (int) ((endValue &gt;&gt; 24 - startValue &gt;&gt; 24) * fraction); // 把 HSV 转换回 ARGB 返回 return Color.HSVToColor(alpha, outHsv); }} ObjectAnimator animator = ObjectAnimator.ofInt(view, “color”, 0xff00ff00);// 使用自定义的 HslEvaluatoranimator.setEvaluator(new HsvEvaluator());animator.start();1234567### PropertyValuesHolder 同一个动画中改变多个属性- PropertyValuesHolder：它是一个属性值的批量存放地，如果有多个属性需要修改，可以把它们放在不同的 `PropertyValuesHolder` 中，然后使用 `ofPropertyValuesHolder()` 统一放进 `Animator`。这样你就不用为每个属性单独创建一个 `Animator` 分别执行了。- 可能同一个动画中会需要改变多个属性，例如在改变透明度的同时改变尺寸。如果使用 `ViewPropertyAnimator`，可以直接用连写的方式来在一个动画中同时改变多个属性，但是对于ObjectAnimator无法这么使用，但是可以依靠 `PropertyValuesHolder` 来同时在一个动画中改变多个属性。这些属性如果放在同一个动画中，需要共享动画的开始时间、结束时间、Interpolator 等等一系列的设定。 PropertyValuesHolder holder1 = PropertyValuesHolder.ofFloat(“scaleX”, 1);PropertyValuesHolder holder2 = PropertyValuesHolder.ofFloat(“scaleY”, 1);PropertyValuesHolder holder3 = PropertyValuesHolder.ofFloat(“alpha”, 1); ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(view, holder1, holder2, holder3)animator.start();1234### AnimatorSet多个动画配合执行- 有时候需要在一个动画中改变多个属性，还会需要多个动画配合工作，比如，在内容的大小从 0 放大到 100% 大小后开始移动。 ObjectAnimator animator1 = ObjectAnimator.ofFloat(…);animator1.setInterpolator(new LinearInterpolator());ObjectAnimator animator2 = ObjectAnimator.ofInt(…);animator2.setInterpolator(new DecelerateInterpolator());AnimatorSet animatorSet = new AnimatorSet();// 两个动画依次执行animatorSet.playSequentially(animator1, animator2);animatorSet.start(); // 或者// 使用 AnimatorSet.play(animatorA).with/before/after(animatorB)// 的方式来精确配置各个 Animator 之间的关系animatorSet.play(animator1).with(animator2);animatorSet.play(animator1).before(animator2);animatorSet.play(animator1).after(animator2);animatorSet.start();1234### PropertyValuesHolders.ofKeyframe() 把同一个属性拆分- 除了合并多个属性和调配多个动画，还可以在 `PropertyValuesHolder` 的基础上更进一步，通过设置 `Keyframe` （关键帧），把同一个动画属性拆分成多个阶段。例如，你可以让一个进度增加到 100% 后再「反弹」回来。 // 在 0% 处开始Keyframe keyframe1 = Keyframe.ofFloat(0, 0);// 时间经过 50% 的时候，动画完成度 100%Keyframe keyframe2 = Keyframe.ofFloat(0.5f, 100);// 时间见过 100% 的时候，动画完成度倒退到 80%，即反弹 20%Keyframe keyframe3 = Keyframe.ofFloat(1, 80);PropertyValuesHolder holder = PropertyValuesHolder.ofKeyframe(“progress”, keyframe1, keyframe2, keyframe3); ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(view, holder);animator.start();123456## ValueAnimator&gt; 除了 ViewPropertyAnimator 和 ObjectAnimator，还有第三个选择是 ValueAnimator。ValueAnimator 并不常用，因为它的功能太基础了。ValueAnimator 是 ObjectAnimator 的父类，实际上，ValueAnimator 就是一个不能指定目标对象版本的 ObjectAnimator。ObjectAnimator 是自动调用目标对象的 setter 方法来更新目标属性的值，以及很多的时候还会以此来改变目标对象的 UI，而 ValueAnimator 只是通过渐变的方式来改变一个独立的数据，这个数据不是属于某个对象的，至于在数据更新后要做什么事，全都由你来定，你可以依然是去调用某个对象的 setter 方法（别这么为难自己），也可以做其他的事，不管要做什么，都是要你自己来写的，ValueAnimator 不会帮你做。功能最少、最不方便，但有时也是束缚最少、最灵活。比如有的时候，你要给一个第三方控件做动画，你需要更新的那个属性没有 setter 方法，只能直接修改，这样的话 ObjectAnimator 就不灵了啊。怎么办？这个时候你就可以用 ValueAnimator，在它的 onUpdate() 里面更新这个属性的值，并且手动调用 invalidate()。&gt;&gt; 所以，ViewPropertyAnimator、ObjectAnimator、ValueAnimator 这三种 Animator，它们其实是一种递进的关系：从左到右依次变得更加难用，也更加灵活。但我要说明一下，它们的性能是一样的，因为 ViewPropertyAnimator 和 ObjectAnimator 的内部实现其实都是 ValueAnimator，ObjectAnimator 更是本来就是 ValueAnimator 的子类，它们三个的性能并没有差别。它们的差别只是使用的便捷性以及功能的灵活性。所以在实际使用时候的选择，只要遵循一个原则就行：尽量用简单的。能用 View.animate() 实现就不用 ObjectAnimator，能用 ObjectAnimator 就不用 ValueAnimator。]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定View之绘制顺序]]></title>
    <url>%2F2018%2F02%2F07%2F%E8%87%AA%E5%AE%9AView%E4%B9%8B%E7%BB%98%E5%88%B6%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[super.onDraw() 前 or 后？ View 这个类中，onDraw() 是空实现，但是基于已有控件的自定义绘制，就不能不考虑 super.onDraw() 了：你需要根据自己的需求，判断出你绘制的内容需要盖住控件原有的内容还是需要被控件原有的内容盖住，从而确定你的绘制代码是应该写在 super.onDraw() 的上面还是下面。 写在 super.onDraw() 的下面 把绘制代码写在 super.onDraw() 的下面，由于绘制代码会在原有内容绘制结束之后才执行，所以绘制内容就会盖住控件原来的内容。 写在 super.onDraw() 的上面 如果把绘制代码写在 super.onDraw() 的上面，由于绘制代码会执行在原有内容的绘制之前，所以绘制的内容会被控件的原内容盖住。 dispatchDraw()：绘制子 View 的方法 Android 的绘制顺序：在绘制过程中，每一个 ViewGroup 会先调用自己的 onDraw()来绘制完自己的主体之后再去绘制它的子 View。对于上面这个例子来说，就是你的 LinearLayout 会在绘制完斑点后再去绘制它的子 View。那么在子 View 绘制完成之后，先前绘制的斑点就被子 View 盖住了。 「绘制子 View」是通过另一个绘制方法的调用来发生的，这个绘制方法叫做：dispatchDraw()。也就是说，在绘制过程中，每个 View 和 ViewGroup 都会先调用 onDraw() 方法来绘制主体，再调用 dispatchDraw() 方法来绘制子 View。注：虽然 View 和 ViewGroup 都有 dispatchDraw() 方法，不过由于 View 是没有子 View 的，所以一般来说 dispatchDraw() 这个方法只对 ViewGroup（以及它的子类）有意义。 写在 super.dispatchDraw() 的下面 只要重写 dispatchDraw()，并在 super.dispatchDraw() 的下面写上你的绘制代码，这段绘制代码就会发生在子 View 的绘制之后，从而让绘制内容盖住子 View 了。 写在 super.dispatchDraw() 的上面 把绘制代码写在 super.dispatchDraw() 的上面，这段绘制就会在 onDraw() 之后、 super.dispatchDraw() 之前发生，也就是绘制内容会出现在主体内容和子 View 之间 绘制过程简述 个完整的绘制过程会依次绘制以下几个内容： 背景（drawBackground()） 主体（onDraw()） 子 View（dispatchDraw()） 滑动边缘渐变和滑动条 前景 关于绘制方法，有两点需要注意一下： 出于效率的考虑，ViewGroup 默认会绕过 draw() 方法，换而直接执行 dispatchDraw()，以此来简化绘制流程。所以如果你自定义了某个 ViewGroup 的子类（比如 LinearLayout）并且需要在它的除 dispatchDraw() 以外的任何一个绘制方法内绘制内容，可能会需要调用 View.setWillNotDraw(false)这行代码来切换到完整的绘制流程（是「可能」而不是「必须」的原因是，有些 ViewGroup 是已经调用过 setWillNotDraw(false) 了的，例如 ScrollView）。 有的时候，一段绘制代码写在不同的绘制方法中效果是一样的，这时你可以选一个自己喜欢或者习惯的绘制方法来重写。但有一个例外：如果绘制代码既可以写在 onDraw() 里，也可以写在其他绘制方法里，那么优先写在 onDraw() ，因为 Android 有相关的优化，可以在不需要重绘的时候自动跳过 onDraw() 的重复执行，以提升开发效率。享受这种优化的只有 onDraw() 一个方法。]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定View之Canvas对绘制的辅助]]></title>
    <url>%2F2018%2F02%2F07%2F%E8%87%AA%E5%AE%9AView%E4%B9%8BCanvas%E5%AF%B9%E7%BB%98%E5%88%B6%E7%9A%84%E8%BE%85%E5%8A%A9%2F</url>
    <content type="text"><![CDATA[范围剪裁 范围裁切有两个方法： clipRect() 和 clipPath()。裁切方法之后的绘制代码，都会被限制在裁切范围内。 clipRect()1234canvas.save(); canvas.clipRect(left, top, right, bottom); canvas.drawBitmap(bitmap, x, y, paint); canvas.restore(); clipPath()123456789canvas.save(); canvas.clipPath(path1); canvas.drawBitmap(bitmap, point1.x, point1.y, paint); canvas.restore();canvas.save(); canvas.clipPath(path2); canvas.drawBitmap(bitmap, point2.x, point2.y, paint); canvas.restore(); 几何变换 几何变换的使用大概分为三类： 使用 Canvas 来做常见的二维变换； 使用 Matrix 来做常见和不常见的二维变换； 使用 Camera 来做三维变换。 使用 Canvas 来做常见的二维变换平移 Canvas.translate(float dx, float dy) 参数里的 dx 和 dy 表示横向和纵向的位移。 12345&gt; canvas.save(); &gt; canvas.translate(200, 0); &gt; canvas.drawBitmap(bitmap, x, y, paint); &gt; canvas.restore(); &gt; 移动 Canvas.translate(float x, float y, float z) 旋转 Canvas.rotate(float degrees, float px, float py) 参数里的 degrees 是旋转角度，单位是度（也就是一周有 360° 的那个单位），方向是顺时针为正向； px和 py 是轴心的位置。 缩放 Canvas.scale(float sx, float sy, float px, float py) 参数里的 sx sy 是横向和纵向的放缩倍数； px py 是放缩的轴心。 12345&gt; canvas.save(); &gt; canvas.scale(1.3f, 1.3f, x + bitmapWidth / 2, y + bitmapHeight / 2); &gt; canvas.drawBitmap(bitmap, x, y, paint); &gt; canvas.restore(); &gt; 错切 skew(float sx, float sy) 参数里的 sx 和 sy 是 x 方向和 y 方向的错切系数。 12345&gt; canvas.save(); &gt; canvas.skew(0, 0.5f); &gt; canvas.drawBitmap(bitmap, x, y, paint); &gt; canvas.restore(); &gt; 使用 Matrix 来做变换使用 Matrix 来做常见变换 Matrix 做常见变换的方式： 创建 Matrix 对象； 调用 Matrix 的 pre/postTranslate/Rotate/Scale/Skew() 方法来设置几何变换； 使用 Canvas.setMatrix(matrix) 或 Canvas.concat(matrix) 来把几何变换应用到 Canvas。 123456789101112Matrix matrix = new Matrix();...matrix.reset(); matrix.postTranslate(); matrix.postRotate();canvas.save(); canvas.concat(matrix); canvas.drawBitmap(bitmap, x, y, paint); canvas.restore(); 把 Matrix 应用到 Canvas 有两个方法： Canvas.setMatrix(matrix) 和 Canvas.concat(matrix)。 Canvas.setMatrix(matrix)：用 Matrix 直接替换 Canvas 当前的变换矩阵，即抛弃 Canvas 当前的变换，改用 Matrix 的变换（注：根据下面评论里以及我在微信公众号中收到的反馈，不同的系统中 setMatrix(matrix) 的行为可能不一致，所以还是尽量用 concat(matrix) 吧）； Canvas.concat(matrix)：用 Canvas 当前的变换矩阵和 Matrix 相乘，即基于 Canvas 当前的变换，叠加上 Matrix 中的变换。 使用 Matrix 来做自定义变换 Matrix 的自定义变换使用的是 setPolyToPoly() 方法。 用点对点映射的方式设置变换 Matrix.setPolyToPoly(float[] src, int srcIndex, float[] dst, int dstIndex, int pointCount) poly 就是「多」的意思。setPolyToPoly() 的作用是通过多点的映射的方式来直接设置变换。「多点映射」的意思就是把指定的点移动到给出的位置，从而发生形变。例如：(0, 0) -&gt; (100, 100) 表示把 (0, 0) 位置的像素移动到 (100, 100) 的位置，这个是单点的映射，单点映射可以实现平移。而多点的映射，就可以让绘制内容任意地扭曲。 参数里，src 和 dst 是源点集合目标点集；srcIndex 和 dstIndex 是第一个点的偏移；pointCount 是采集的点的个数（个数不能大于 4，因为大于 4 个点就无法计算变换了）。 12345678910111213Matrix matrix = new Matrix(); float pointsSrc = &#123;left, top, right, top, left, bottom, right, bottom&#125;; float pointsDst = &#123;left - 10, top + 50, right + 120, top - 90, left + 20, bottom + 30, right + 20, bottom + 60&#125;;...matrix.reset(); matrix.setPolyToPoly(pointsSrc, 0, pointsDst, 0, 4);canvas.save(); canvas.concat(matrix); canvas.drawBitmap(bitmap, x, y, paint); canvas.restore(); ​ 使用 Camera 来做三维变换 Camera 的三维变换有三类：旋转、平移、移动相机。 三维旋转 Camera.rotate() `Camera.rotate()一共有四个方法：rotateX(deg)rotateY(deg)rotateZ(deg)rotate(x, y, z) Camera 和 Canvas 一样也需要保存和恢复状态才能正常绘制，不然在界面刷新之后绘制就会出现问题。 如果你需要图形左右对称，需要配合上 Canvas.translate()，在三维旋转之前把绘制内容的中心点移动到原点，即旋转的轴心，然后在三维旋转后再把投影移动回来： 1234567891011canvas.save();camera.save(); // 保存 Camera 的状态 camera.rotateX(30); // 旋转 Camera 的三维空间 canvas.translate(centerX, centerY); // 旋转之后把投影移动回来 camera.applyToCanvas(canvas); // 把旋转投影到 Canvas canvas.translate(-centerX, -centerY); // 旋转之前把绘制内容移动到轴心（原点） camera.restore(); // 恢复 Camera 的状态canvas.drawBitmap(bitmap, point1.x, point1.y, paint); canvas.restore(); 平移 Camera.translate(float x, float y, float z) 设置虚拟相机的位置 Camera.setLocation(x, y, z) 参数的单位不是像素，而是 inch，英寸。这种设计源自 Android 底层的图像引擎 Skia 。在 Skia 中，Camera 的位置单位是英寸，英寸和像素的换算单位在 Skia 中被写死为了 72 像素，而 Android 中把这个换算单位照搬了过来。是的，它写死了。 在 Camera 中，相机的默认位置是 (0, 0, -8)（英寸）。8 x 72 = 576，所以它的默认位置是 (0, 0, -576)（像素）。如果绘制的内容过大，当它翻转起来的时候，就有可能出现图像投影过大的「糊脸」效果。而且由于换算单位被写死成了 72 像素，而不是和设备 dpi 相关的，所以在像素越大的手机上，这种「糊脸」效果会越明显。而使用 setLocation() 方法来把相机往后移动，就可以修复这种问题。Camera.setLocation(x, y, z) 的 x 和 y 参数一般不会改变，直接填 0 就好。]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定View之Paint详解]]></title>
    <url>%2F2018%2F02%2F07%2F%E8%87%AA%E5%AE%9AView%E4%B9%8BPaint%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"></content>
      <categories>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定View之Canvas的系列方法及 Paint最常见的使用]]></title>
    <url>%2F2018%2F02%2F07%2F%E8%87%AA%E5%AE%9AView%E4%B9%8BCanvas%E7%9A%84%E7%B3%BB%E5%88%97%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Canvas.drawXXX() 是自定义绘制最基本的操作。通过该方法可以绘制圆、方、图像、和文字，并且组合这些内容，在通过Paint的一些常见方法来对绘制内容的颜色和风格进行简单配置。 View的坐标系 在 Android 里，每个 View 都有一个自己的坐标系，彼此之间是不影响的。这个坐标系的原点是 View 左上角的那个点；水平方向是 x 轴，右正左负；竖直方向是 y 轴，下正上负。 Canvas.translate(dx,dy)：View的坐标系原点移动指定距离，dx为移动的x方向距离，dy为移动的y方向的问题。 Canvas.drawXXX() 和 Paint 基础 Canvas 类下的所有 draw- 开头的方法： drawCircle() drawBitmap() drawOval() drawPoint() drawRect() drawArc() drawPath() Paint 类的几个最常用的方法： Paint.setStyle(Style style) 设置绘制模式 Paint.Style.STROK：画线模式 Paint.Style.FILL：填充末世 FILL_AND_STROKE：既画线又填充 Paint.setColor(int color) 设置颜色 Paint.setStrokeWidth(float width) 设置线条宽度 Paint.setTextSize(float textSize) 设置文字大小 Paint.setAntiAlias(boolean aa) 设置抗锯齿开关 Paint.setTextAlign(Align align)设置文字居中，左对齐，右对齐 ​ 颜色填充 Canvas.drawColor(@ColorInt int color) 在整个绘制区域统一涂上指定的颜色,这类颜色填充方法一般用于在绘制之前设置底色，或者在绘制之后为界面设置半透明蒙版。 类似的方法还有 drawRGB(int r, int g, int b) 和 drawARGB(int a, int r, int g, int b) ，它们和 drawColor(color) 只是使用方式不同，作用都是一样的。 画圆 drawCircle(float centerX, float centerY, float radius, Paint paint) centerX , centerY：圆的圆心坐标（单位像素）。 radius：圆的半径（单位像素）。 画矩形 drawRect(float left, float top, float right, float bottom, Paint paint) left, top, right, bottom 是矩形四条边的坐标。 两个重载方法 drawRect(RectF rect, Paint paint) 和 drawRect(Rect rect, Paint paint)，直接设置RectF 或 Rect 对象来绘制矩形。 画点 drawPoint(float x, float y, Paint paint) x 和 y 是点的坐标。点的大小可以通过 paint.setStrokeWidth(width) 来设置； 点的形状可以通过 paint.setStrokeCap(cap) 来设置：ROUND 画出来是圆形的点，SQUARE 或 BUTT 画出来是方形的点 Paint.setStrokeCap(cap) 可以设置点的形状，但这个方法并不是专门用来设置点的形状的，而是一个设置线条端点形状的方法。端点有圆头 (ROUND)、平头 (BUTT) 和方头 (SQUARE) 三种。 drawPoints(float[] pts, int offset, int count, Paint paint) / drawPoints(float[] pts, Paint paint) 批量画点,pts 这个数组是点的坐标，每两个成一对；offset表示跳过数组的前几个数再开始记坐标；count 表示一共要绘制几个点。 画椭圆 drawOval(float left, float top, float right, float bottom, Paint paint) 只能绘制横着的或者竖着的椭圆，不能绘制斜的（斜的倒是也可以，但不是直接使用 drawOval()，而是配合几何变换）。left, top, right, bottom 是这个椭圆的左、上、右、下四个边界点的坐标。 重载方法 drawOval(RectF rect, Paint paint)，让你可以直接填写 RectF 来绘制椭圆。 画线 drawLine(float startX, float startY, float stopX, float stopY, Paint paint) 由于直线不是封闭图形，所以 setStyle(style) 对直线没有影响。 drawLines(float[] pts, int offset, int count, Paint paint) / drawLines(float[] pts, Paint paint) 批量画线。 画圆角矩形 drawRoundRect(float left, float top, float right, float bottom, float rx, float ry, Paint paint) left, top, right, bottom 是四条边的坐标，rx 和 ry 是圆角的横向半径和纵向半径。 重载方法 drawRoundRect(RectF rect, float rx, float ry, Paint paint)，让你可以直接填写 RectF 来绘制圆角矩形。 画 Bitmap drawBitmap(Bitmap bitmap, float left, float top, Paint paint) 重载方法： drawBitmap(Bitmap bitmap, Rect src, RectF dst, Paint paint) drawBitmap(Bitmap bitmap, Rect src, Rect dst, Paint paint) drawBitmap(Bitmap bitmap, Matrix matrix, Paint paint) drawBitmapMesh()，可以绘制具有网格拉伸效果的 Bitmap。 绘制弧形或扇形 drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint) left, top, right, bottom 描述的是这个弧形所在的椭圆；startAngle 是弧形的起始角度（x 轴的正向，即正右的方向，是 0 度的位置；顺时针为正角度，逆时针为负角度），sweepAngle 是弧形划过的角度；useCenter 表示是否连接到圆心，如果不连接到圆心，就是弧形，如果连接到圆心，就是扇形。 画自定义图形 drawPath(Path path, Paint paint) Path 方法第一类：直接描述路径 addXxx()：添加字图形。 添加圆： addCircle(float x, float y, float radius, Direction dir) 添加椭圆： addOval(float left, float top, float right, float bottom, Direction dir) / addOval(RectF oval, Direction dir) 添加矩形： addRect(float left, float top, float right, float bottom, Direction dir) / addRect(RectF rect, Direction dir) 添加圆角矩形： addRoundRect(RectF rect, float rx, float ry, Direction dir) / addRoundRect(float left, float top, float right, float bottom, float rx, float ry, Direction dir) / addRoundRect(RectF rect, float[] radii, Direction dir) / addRoundRect(float left, float top, float right, float bottom, float[] radii, Direction dir) 添加一个 Path： addPath(Path path) dir：画圆的路径的方向，路径方向是顺时针 (CW clockwise) 和逆时针 (CCW counter-clockwise) 。对于普通情况，这个参数填 CW 还是填 CCW 没有影响。它只是在需要填充图形 (Paint.Style 为 FILL 或 FILL_AND_STROKE) ，并且图形出现自相交时，用于判断填充范围。 xxxTo()：画线（直线或曲线） 第一组是添加的完整封闭图形（除了 addPath() ），而这一组添加的只是一条线。 画直线： lineTo(float x, float y) / rLineTo(float x, float y) ，从当前位置向目标位置画一条直线， x 和 y 是目标位置的坐标。这两个方法的区别是，lineTo(x, y) 的参数是绝对坐标，而 rLineTo(x, y) 的参数是相对当前位置的相对坐标 （前缀 r 指的就是 relatively 「相对地」)。当前位置：所谓当前位置，即最后一次调用画 Path 的方法的终点位置。初始值为原点 (0, 0)。 画二次贝塞尔曲线： quadTo(float x1, float y1, float x2, float y2) / rQuadTo(float dx1, float dy1, float dx2, float dy2)。x1, y1 和 x2, y2 则分别是控制点和终点的坐标。 画三次贝塞尔曲线： cubicTo(float x1, float y1, float x2, float y2, float x3, float y3) / rCubicTo(float x1, float y1, float x2, float y2, float x3, float y3) 。 移动到目标位置： moveTo(float x, float y) / rMoveTo(float x, float y)，设置图形的起点。 封闭当前子图形： close() Path 方法第二类：辅助的设置或计算 Path.setFillType(Path.FillType ft) 设置填充方式,FillType 值: EVEN_ODD ：全填充 WINDING （默认值）：交叉填充 INVERSE_EVEN_ODD INVERSE_WINDING ​ EVEN_ODD： even-odd rule （奇偶原则）：对于平面中的任意一点，向任意方向射出一条射线，这条射线和图形相交的次数（相交才算，相切不算哦）如果是奇数，则这个点被认为在图形内部，是要被涂色的区域；如果是偶数，则这个点被认为在图形外部，是不被涂色的区域。 WINDING non-zero winding rule （非零环绕数原则）：从平面中的点向任意方向射出一条射线，以 0 为初始值，对于射线和图形的所有交点，遇到每个顺时针的交点（图形从射线的左边向右穿过）把结果加 1，遇到每个逆时针的交点（图形从射线的右边向左穿过）把结果减 1，最终把所有的交点都算上，得到的结果如果不是 0，则认为这个点在图形内部，是要被涂色的区域；如果是 0，则认为这个点在图形外部，是不被涂色的区域。 图形的方向：对于添加子图形类方法（如 Path.addCircle() Path.addRect()）的方向，由方法的 dir 参数来控制，这个在前面已经讲过了；而对于画线类的方法（如 Path.lineTo() Path.arcTo()）就更简单了，线的方向就是图形的方向。 INVERSE_EVEN_ODD 和 INVERSE_WINDING，只是把EVEN_ODD和INVERSE_WINDING效果进行反转而已。 EVEN_ODD和INVERSE_WINDING完整效果图]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有关MVP的设计]]></title>
    <url>%2F2018%2F02%2F04%2F%E6%9C%89%E5%85%B3MVP%E7%9A%84%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[BasePresenter中BaseView的绑定和解绑：由于Presenter要获取View对象调用View中方法，所以需要对View进行绑定，当View销毁时因为View的对象为null，需要Presenter对View进行解绑，不然Presenter会持有View的引用导致内存泄漏。 代理模式 抽象角色：声明真实对象和代理对象的共同接口； 代理角色：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。 真实角色：代理角色所代表的真实对象，是我们最终要引用的对象。 代理模式在MVP设计中的体现 第一重代理: 绑定与解绑的代理（代理角色ProxyMvpCallback为真实角色BaseActivity实现绑定与解绑功能） 抽象角色：MvpCallBack，创建与设置BasePresenter和BaseView的接口。 代理角色：ProxyMvpCallback 真实角色：BaseActivity 第二重代理：Activity生命周期的代理（代理对象BaseActivity为真实对象抽象角色MvpActivityDelegate实现Activity的生命周期方法） 抽象角色：MvpActivityDelegate 即代理Activity的生命周期 代理角色：BaseActivity为代理角色内部在Activity生命周期中调用了真实角色的MvpActivityDelegateImpl的生命周期方法。 真实角色：MvpActivityDelegateImpl，实现了Activity的生命周期。 第一重代理与第二重代理相结合即是双重代理：代理对象ProxyMvpCallback为真实对象MvpActivityDelegate在生命周期方法中实现绑定与解绑功能]]></content>
      <categories>
        <category>Android架构</category>
      </categories>
      <tags>
        <tag>MVP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LRUCache原理]]></title>
    <url>%2F2018%2F02%2F04%2FLRUCache%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[LRUCache算法中LRU是指Last Recently Used，也就是最近最少使用算法。当缓存控件满了的时候，将最近最少使用的数据从缓存控件中删除以增加缓存空间来缓存新内容。这个算法内部有一个缓存列表，每当一个数据被访问的时候，改数据就会被提到列表头部，蓑衣列表尾部的数据就是最近最不常是使用的了，当缓存空间不足，就会删除列表尾部的缓存数据。 LRUCache源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345/** * LruCache通过强引用来缓存一定数量的值，每当一个值被访问时，这个值就会移动到缓存列表的头部。 * 如果插入数据时发现缓存不够，就会将队列中访问次数最少的数据删掉。 */public class LruCache&lt;K, V&gt; &#123; // 存放缓存内容的map private final LinkedHashMap&lt;K, V&gt; map; /** * Size of this cache in units. Not necessarily the number of elements. * 当前缓存已使用大小，不一定是元素的个数 */ private int size; // 内存最大值 private int maxSize; // 各个方法被调用的次数 private int putCount; private int createCount; private int evictionCount; private int hitCount; private int missCount; /** * @param maxSize for caches that do not override &#123;@link #sizeOf&#125;, this is * the maximum number of entries in the cache. For all other caches, * this is the maximum sum of the sizes of the entries in this cache. * 构造方法 传入maxSize是缓存的最大值 */ public LruCache(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;); &#125; this.maxSize = maxSize; // 初始化LinkedHashMap // 第一个参数是初始容量 // 第二个参数为填装因子或加载因子 // 第三个参数为排序模式，true表示在访问的时候进行排序，否则只在插入的时候排序。 this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true); &#125; /** * Sets the size of the cache. * 重置最大缓存 * @param maxSize The new maximum size. */ public void resize(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;); &#125; synchronized (this) &#123; this.maxSize = maxSize; &#125; trimToSize(maxSize); &#125; /** * Returns the value for &#123;@code key&#125; if it exists in the cache or can be * created by &#123;@code #create&#125;. If a value was returned, it is moved to the * head of the queue. This returns null if a value is not cached and cannot * be created. * 通过Key获取缓存的数据，如果通过这个方法得到的需要的元素,那么该元素会被放在缓存队列的头部 */ public final V get(K key) &#123; if (key == null) &#123; throw new NullPointerException(&quot;key == null&quot;); &#125; V mapValue; // 同步代码块 synchronized (this) &#123; // 从LinkedHashMap中获取数据 mapValue = map.get(key); if (mapValue != null) &#123; hitCount++; return mapValue; &#125; missCount++; &#125; /* * Attempt to create a value. This may take a long time, and the map * may be different when create() returns. If a conflicting value was * added to the map while create() was working, we leave that value in * the map and release the created value. * 如果通过Key从缓存集合中获取缓存不到的数据，就尝试使用creat(key)方法创造一个新数据。 * create(key)默认返回的也是null,需要重写该方法 */ V createdValue = create(key); if (createdValue == null) &#123; return null; &#125; // 若是重写了create(key)方法，便将新的数据放入缓存中。 synchronized (this) &#123; createCount++; mapValue = map.put(key, createdValue); if (mapValue != null) &#123; // There was a conflict so undo that last put 有冲突撤销之前设置的值 map.put(key, mapValue); &#125; else &#123; size += safeSizeOf(key, createdValue); &#125; &#125; if (mapValue != null) &#123; entryRemoved(false, key, createdValue, mapValue); return mapValue; &#125; else &#123; trimToSize(maxSize); return createdValue; &#125; &#125; /** * Caches &#123;@code value&#125; for &#123;@code key&#125;. The value is moved to the head of * the queue. * 向缓存队列中添加数据，并将数据移动到队列头部 * @return the previous value mapped by &#123;@code key&#125;. */ public final V put(K key, V value) &#123; if (key == null || value == null) &#123; throw new NullPointerException(&quot;key == null || value == null&quot;); &#125; V previous; synchronized (this) &#123; putCount++; // safeSizeOf(Key,value);该方法返回的是1，也就是将缓存的个数加1. // 当缓存的是图片的时候，这个size应该表示图片占用的内存的大小， // 所以应该重写里面调用sizeOf(key,value)的方法 size += safeSizeOf(key, value); // 将新创建的元素加入缓存队列，并在添加成功后返回这个元素 previous = map.put(key, value); if (previous != null) &#123; // 如果换回为null,则说明缓存失败，在已用的缓存大小中减去改元素大小 size -= safeSizeOf(key, previous); &#125; &#125; if (previous != null) &#123; entryRemoved(false, key, previous, value); &#125; trimToSize(maxSize); return previous; &#125; /** * Remove the eldest entries until the total of remaining entries is at or * below the requested size. * 修改缓存大小，是已用的缓存不大于设置的缓存最大值 * @param maxSize the maximum size of the cache before returning. May be -1 * to evict even 0-sized elements. */ public void trimToSize(int maxSize) &#123; while (true) &#123; K key; V value; synchronized (this) &#123; if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException(getClass().getName() + &quot;.sizeOf() is reporting inconsistent results!&quot;); &#125; // 已用缓存小于最大缓存，则完成任务退出循环 if (size &lt;= maxSize || map.isEmpty()) &#123; break; &#125; // 否则在缓存队列中先找到最近最少使用的元素， // 调用LinkedHashMap的eldest()方法返回最不经常使用的元素。 Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next(); // 删掉改元素减少已使用的缓存空间 key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); size -= safeSizeOf(key, value); evictionCount++; &#125; entryRemoved(true, key, value, null); &#125; &#125; /** * Removes the entry for &#123;@code key&#125; if it exists. * 删除 * @return the previous value mapped by &#123;@code key&#125;. */ public final V remove(K key) &#123; if (key == null) &#123; throw new NullPointerException(&quot;key == null&quot;); &#125; V previous; synchronized (this) &#123; previous = map.remove(key); if (previous != null) &#123; size -= safeSizeOf(key, previous); &#125; &#125; if (previous != null) &#123; entryRemoved(false, key, previous, null); &#125; return previous; &#125; /** * Called for entries that have been evicted or removed. This method is * invoked when a value is evicted to make space, removed by a call to * &#123;@link #remove&#125;, or replaced by a call to &#123;@link #put&#125;. The default * implementation does nothing. * * &lt;p&gt;The method is called without synchronization: other threads may * access the cache while this method is executing. * * @param evicted true if the entry is being removed to make space, false * if the removal was caused by a &#123;@link #put&#125; or &#123;@link #remove&#125;. * @param newValue the new value for &#123;@code key&#125;, if it exists. If non-null, * this removal was caused by a &#123;@link #put&#125;. Otherwise it was caused by * an eviction or a &#123;@link #remove&#125;. * 默认为空方法，有需要才会自己实现，evicted如果是true,则表示这个元素因为空间不够而被自动清理了，所以 * 可以在这个地方队被清理的元素进行再次缓存 */ protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) &#123;&#125; /** * Called after a cache miss to compute a value for the corresponding key. * Returns the computed value or null if no value can be computed. The * default implementation returns null. * * &lt;p&gt;The method is called without synchronization: other threads may * access the cache while this method is executing. * * &lt;p&gt;If a value for &#123;@code key&#125; exists in the cache when this method * returns, the created value will be released with &#123;@link #entryRemoved&#125; * and discarded. This can occur when multiple threads request the same key * at the same time (causing multiple values to be created), or when one * thread calls &#123;@link #put&#125; while another is creating a value for the same * key. */ protected V create(K key) &#123; return null; &#125; private int safeSizeOf(K key, V value) &#123; int result = sizeOf(key, value); if (result &lt; 0) &#123; throw new IllegalStateException(&quot;Negative size: &quot; + key + &quot;=&quot; + value); &#125; return result; &#125; /** * Returns the size of the entry for &#123;@code key&#125; and &#123;@code value&#125; in * user-defined units. The default implementation returns 1 so that size * is the number of entries and max size is the maximum number of entries. * 用来定义已用缓存的数量算法，默认是返回数量 * &lt;p&gt;An entry&apos;s size must not change while it is in the cache. */ protected int sizeOf(K key, V value) &#123; return 1; &#125; /** * Clear the cache, calling &#123;@link #entryRemoved&#125; on each removed entry. * 清空所有缓存 */ public final void evictAll() &#123; trimToSize(-1); // -1 will evict 0-sized elements &#125; /** * For caches that do not override &#123;@link #sizeOf&#125;, this returns the number * of entries in the cache. For all other caches, this returns the sum of * the sizes of the entries in this cache. * 不可重写，返回的值是缓存的条目数 */ public synchronized final int size() &#123; return size; &#125; /** * For caches that do not override &#123;@link #sizeOf&#125;, this returns the maximum * number of entries in the cache. For all other caches, this returns the * maximum sum of the sizes of the entries in this cache. */ public synchronized final int maxSize() &#123; return maxSize; &#125; /** * Returns the number of times &#123;@link #get&#125; returned a value that was * already present in the cache. * 已缓存的value的数目 */ public synchronized final int hitCount() &#123; return hitCount; &#125; /** * Returns the number of times &#123;@link #get&#125; returned null or required a new * value to be created. */ public synchronized final int missCount() &#123; return missCount; &#125; /** * Returns the number of times &#123;@link #create(Object)&#125; returned a value. */ public synchronized final int createCount() &#123; return createCount; &#125; /** * Returns the number of times &#123;@link #put&#125; was called. */ public synchronized final int putCount() &#123; return putCount; &#125; /** * Returns the number of values that have been evicted. */ public synchronized final int evictionCount() &#123; return evictionCount; &#125; /** * Returns a copy of the current contents of the cache, ordered from least * recently accessed to most recently accessed. */ public synchronized final Map&lt;K, V&gt; snapshot() &#123; return new LinkedHashMap&lt;K, V&gt;(map); &#125; @Override public synchronized final String toString() &#123; int accesses = hitCount + missCount; int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0; return String.format(Locale.US, &quot;LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]&quot;, maxSize, hitCount, missCount, hitPercent); &#125;&#125; LinkedHashMap LRUCache使用LinkedHashMap来存储缓存，LinkedHashMap内部有排序功能，当其构造方法第三个参数为true时，数据在被访问的时候就会排序，该排序的结果就是把最近访问的数据放在放在集合的最后面。所以要缓存不够是就会从前面开始删除。 构造方法1234567891011121314151617/** * Constructs an empty &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with the * specified initial capacity, load factor and ordering mode. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @param accessOrder the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for * access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */ public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder; &#125; Entity的定义LinkedHashMap内部是使用双向循环链表来存储数据，也就是每一个元素都持有他上一个元素的地址和下一个元素的地址 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * LinkedHashMap entry. */ private static class LinkedHashMapEntry&lt;K,V&gt; extends HashMapEntry&lt;K,V&gt; &#123; // These fields comprise the doubly linked list used for iteration. LinkedHashMapEntry&lt;K,V&gt; before, after; LinkedHashMapEntry(int hash, K key, V value, HashMapEntry&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125; /** * 从链表中删除这个元素 */ private void remove() &#123; before.after = after; after.before = before; &#125; /** * Inserts this entry before the specified existing entry in the list. */ private void addBefore(LinkedHashMapEntry&lt;K,V&gt; existingEntry) &#123; after = existingEntry; before = existingEntry.before; before.after = this; after.before = this; &#125; /** * 当集合的get方法被调用时，会调用这个方法。 * 如果accessOrder为true，就把这个元素放在集合的最末端。 */ void recordAccess(HashMap&lt;K,V&gt; m) &#123; LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m; if (lm.accessOrder) &#123; lm.modCount++; remove(); addBefore(lm.header); &#125; &#125; void recordRemoval(HashMap&lt;K,V&gt; m) &#123; remove(); &#125; &#125; get方法排序过程1234567public V get(Object key) &#123; LinkedHashMapEntry&lt;K,V&gt; e = (LinkedHashMapEntry&lt;K,V&gt;)getEntry(key); if (e == null) return null; e.recordAccess(this); return e.value; &#125; 每一个元素都持有他上一个元素的地址和下一个元素的地址，对于最后一个元素它会和header相互持有也就是header会持有最后一个元素地址作为before，而最后一个元素会持有header地址作为after。 recordAccess（this）方法，this就是这个LinkedHashMap123456789101112131415161718192021void recordAccess(HashMap&lt;K,V&gt; m) &#123; LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m; if (lm.accessOrder) &#123; lm.modCount++; remove(); addBefore(lm.header); &#125; &#125; // 调用remove方法，把自己从链表中移除： private void remove() &#123; before.after = after; after.before = before; &#125; // addBefore(lm.header)方法，把自己添加到链表的结尾 private void addBefore(LinkedHashMapEntry&lt;K,V&gt; existingEntry) &#123; after = existingEntry; before = existingEntry.before; before.after = this; after.before = this; &#125; 获取最该清楚的常用元素 eldest()方法，提供的就是最近最少使用的元素： 1234public Map.Entry&lt;K, V&gt; eldest() &#123; Entry&lt;K, V&gt; eldest = header.after; return eldest != header ? eldest : null;&#125; LruCache和LinkedHashMap结合实现缓存 LinkedHashMap第三个参数为true时，每次访问LinkedHashMap的数据，LinkedHashMap都回去进行排序，将最近访问的放在链表的末尾。 LruCache的put方法调用了LinkedHashMap的put来存储数据，自己进行了对缓存空间的计算。LinkedHashMap的put方法也会进行排序。 LruCache的get方法调用了LinkedHashMap的get来获取数据，由于LinkedHashMap构造方法的第三个参数为true,因此get也会触发LinkedHashMap的排序。 trimToSize(int maxSize) trimToSize(int maxSize)是LruCache的核心方法了，get和put都可能会执行这个方法。 1234567891011121314151617181920212223242526272829public void trimToSize(int maxSize) &#123; while (true) &#123; K key; V value; synchronized (this) &#123; if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException(getClass().getName() + &quot;.sizeOf() is reporting inconsistent results!&quot;); &#125; if (size &lt;= maxSize) &#123; break; &#125; Map.Entry&lt;K, V&gt; toEvict = map.eldest(); if (toEvict == null) &#123; break; &#125; key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); size -= safeSizeOf(key, value); evictionCount++; &#125; entryRemoved(true, key, value, null); &#125; &#125; 使用LruCache来缓存Bitmap12345678910111213141516171819202122LruCache&lt;String, Bitmap&gt; mLruCache; //获取手机最大内存 单位 kb int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); //一般都将1/8设为LruCache的最大缓存 int cacheSize = maxMemory / 8; mLruCache = new LruCache&lt;String, Bitmap&gt;(maxMemory / 8) &#123; /** * 这个方法从源码中看出来是设置已用缓存的计算方式的。 * 默认返回的值是1，也就是没缓存一张图片就将已用缓存大小加1. * 缓存图片看的是占用的内存的大小，每张图片的占用内存也是不一样的，一次不能这样算。 * 因此要重写这个方法，手动将这里改为本次缓存的图片的大小。 */ @Override protected int sizeOf(String key, Bitmap value) &#123; return value.getByteCount() / 1024; &#125; &#125;; //加入缓存 mLruCache.put(&quot;key&quot;, BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)); //从缓存中读取 Bitmap bitmap = mLruCache.get(&quot;key&quot;);]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
</search>
