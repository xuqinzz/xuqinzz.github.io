<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Okhttp3源码浅析]]></title>
    <url>%2F2019%2F04%2F29%2FOkhttp3%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Okhttp简介 Okhttp是一个http客户端，默认提供一下支持： HTTP / 2支持允许同一主机的所有请求共享socket。 在HTTP / 2不可用的情况下，Okhttp的连接池将会减少请求延迟。 通过GZIP压缩减少数据大小。 通过响应缓存完全避免重复的网络请求。 Okhttp的使用12345678910111213141516171819202122232425262728// 创建请求客户端 OkhttpClientOkHttpClient okHttpClient = new OkHttpClient.Builder().build();// 构建请求体Request request = new Request .Builder() .url(&quot;www.github.com&quot;) .addHeader(&quot;token&quot;, &quot;70DA53F9B9D8A3D6345F1A7C4BC1A4A8&quot;) .build();// 生成一个call（呼叫）对象 由RealCall实现Call接口的方法Call call = okHttpClient.newCall(request);try &#123; // 同步请求 Response response = call.execute(); // 异步请求 call.enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; &#125; &#125;);&#125; catch (IOException e) &#123; e.printStackTrace();&#125; OkhttpClient的创建OkHttpClient okHttpClient = new OkHttpClient.Builder().build(); OkhttpClient中使用建造者设计模式进行初始化，Builder()初始化代码 123456789101112131415161718192021222324252627public Builder() &#123; dispatcher = new Dispatcher(); protocols = DEFAULT_PROTOCOLS; connectionSpecs = DEFAULT_CONNECTION_SPECS; eventListenerFactory = EventListener.factory(EventListener.NONE); proxySelector = ProxySelector.getDefault(); if (proxySelector == null) &#123; // 如果不存在系统代理，新建一个类型为直接连接的代理 proxySelector = new NullProxySelector(); &#125; cookieJar = CookieJar.NO_COOKIES; socketFactory = SocketFactory.getDefault(); hostnameVerifier = OkHostnameVerifier.INSTANCE; certificatePinner = CertificatePinner.DEFAULT; proxyAuthenticator = Authenticator.NONE; authenticator = Authenticator.NONE; connectionPool = new ConnectionPool(); dns = Dns.SYSTEM; followSslRedirects = true; followRedirects = true; retryOnConnectionFailure = true; callTimeout = 0; connectTimeout = 10_000; readTimeout = 10_000; writeTimeout = 10_000; pingInterval = 0;&#125; OkhttpClient初始化的值： Dispatcher dispatcher：调度器，⽤于调度线程从后台发起的⽹络请求，有后台总请求数和单主机总请求数的限制。 List&lt;Protocol&gt; protocols：⽀持的应⽤层协议，即 HTTP/1.1、HTTP/2 等。 List connectionSpecs：：应⽤层⽀持的 Socket 设置，使⽤明⽂传输（⽤于 HTTP）还是某个版本的 TLS（⽤于 HTTPS）。 EventListener.Factory eventListenerFactory：事件监听工厂，所有的开始、连接、取得结果事件都会有一个相匹配的结束或释放事件。 ProxySelector proxySelector：代理服务器，获取系统的代理，如果不存在系统代理，新建一个类型为直接连接的代理。 CookieJar cookieJar：管理 Cookie 的控制器。OkHttp 提供了 Cookie 存取的判断⽀持（即何时存何时取，但没有给出如何存取。所以需自己实现存取Cookie，如⽤ Map 存在内存⾥，或者存在本地存储或者数据库中。 SocketFactory socketFactory：socket工厂。 HostnameVerifier hostnameVerifier：用于验证 HTTPS 握⼿过程中下载到的证书所属者是否与请求要访问的主机域名是否⼀致。 CertificatePinner certificatePinner：⽤于设置 HTTPS 握⼿过程中针对某个Host 的 Certificate Public Key Pinner，即把⽹站证书链中的每⼀个证书公钥直接拿来提前配置进 OkHttpClient ⾥去，以跳过本地根证书，直接从代码⾥进⾏认证。这种⽤法⽐较少⻅，⼀般⽤于防⽌⽹站证书被⼈仿制（ As 中对CertificatePinner 使用 ctrl + Q 可以直接查看文档），具体使用如下： 123456789101112String hostname = &quot;publicobject.com&quot;;CertificatePinner certificatePinner = new CertificatePinner.Builder() .add(hostname, &quot;sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;) .build();OkHttpClient client = OkHttpClient.Builder() .certificatePinner(certificatePinner) .build();Request request = new Request.Builder() .url(&quot;https://&quot; + hostname) .build();client.newCall(request).execute(); Authenticator proxyAuthenticator：连接代理服务器之前需要进行身份验证或者从原始Web服务器或代理服务器接收质询后执行响应式身份验证，默认为不进行身份验证。 Authenticator authenticator：连接代理服务器之前需要进行身份验证或者从原始Web服务器或代理服务器接收质询后执行响应式身份验证，默认为不进行身份验证。 12345678910OkHttpClient okHttpClient = new OkHttpClient.Builder() .authenticator(new Authenticator() &#123; @Override public Request authenticate(Route route, Response response) throws IOException &#123; // 调用获取Token接口获取token return response.request().newBuilder() .addHeader(&quot;Authorization&quot;,&quot;Bearer token&quot;) .build(); &#125; &#125;).build(); ConnectionPool connectionPool：连接池，重复使用HTTP和HTTP / 2连接以减少网络延迟，访问同一个地址的HTTP请求可以共享同一个连接。 Dns dns：解析主机名IP地址的域名，默认使用系统的DNS服务，应用程序也可提供自己的实现来使用不同的DNS服务器，选择IPv6地址、IPv4地址或强制使用特定的已知IP地址。 boolean followSslRedirects：在重定向时，如果原先请求的是 http ⽽重定向的⽬标是 https，或者原先请求的是 https ⽽重定向的⽬标是 http，是否依然⾃动 follow。（不是「是否⾃动 follow HTTPS URL 重定向的意思，⽽是是否⾃动 follow 在 HTTP 和HTTPS 之间切换的重定向）默认为 true ； boolean followRedirects ：遇到重定向的要求是，是否⾃动 follow，默认为 true 。 boolean retryOnConnectionFailure：在请求失败的时候是否⾃动重试。注意，⼤多数的请求失败并不属于 OkHttp 所定义的「需要重试」，这种重试只适⽤于「同⼀个域名的多个 IP 切换重试」「Socket 失效重试」等情况，默认为 true 。 int callTimeout：发起请求的超时时间，默认为10_000。 int connectTimeout：建⽴连接（TCP 或 TLS）的超时时间，默认为10_000。 int readTimeout：发起请求到读到响应数据的超时时间，默认为10_000。 int writeTimeout：发起请求并被⽬标服务器接受的超时时间（因为有时候目标服务器可能由于某种原因⽽不读取你的 Request），默认为10_000； int pingInterval：维持心跳ping间隔时间。 List&lt;Interceptor&gt; interceptors：拦截器配置。 List networkInterceptors：直接和⽹络请求交互的 Interceptor 配置到这⾥，如果查看返回的 301 报⽂或者未解压的 Response Body，需要在这⾥配置。 Cache cache：Cache 存储的配置。默认是没有，如果需要⽤，得⾃⼰配置出 Cache 存储的⽂件位置以及存储空间上限。 请求体Request的创建 request中包含了请求的相关信息url、method、headers、body、tags等。 request的默认 method 是 GET 创建Call对象 RealCall是Call接口的实现类所以，实际上创建的对象是 Call 的实现类 RealCall 对象。 RealCall 的同步请求 execute()方法：首先判断该异步请求是否正在执行，如果正在执行则抛出异常。随后开启发射器 Transmitter 的请求开始事件监听。最终通过调度器 Dispatcher 的 enqueue(AsyncCall call)进行同步请求。 123456789101112131415@Overridepublic Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; transmitter.timeoutEnter(); transmitter.callStart(); try &#123; client.dispatcher().executed(this); return getResponseWithInterceptorChain(); &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125; RealCall 的异步请求 enqueue(Callback responseCallback)方法：首先判断是否该请求正在执行，如果执行则抛出异常。随后开启发射器 Transmitter 的请求超时计时，以及请求开始的事件监听。然后让调度器 Dispatcher 将该同步请求 RealCall 加入同步请求就绪队列，最后网络请求是拦截链 getResponseWithInterceptorChain()方法进行链式拦截并获取 Response。无论请求结果如果都要在 finally 中通过 Dispatcher 中的同步请求队列移除该 RealCall。 123456789@Overridepublic void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; transmitter.callStart(); client.dispatcher().enqueue(new RealCall.AsyncCall(responseCallback));&#125; AsyncCall：RealCall 中的内部类，本质是一个异步请求的线程。 executeOn(ExecutorService executorService)： 传入的是一个线程池 ThreadPoolExecutor 通过断言 assert 判断当前线程调度器 Dispatcher 是否被锁住，若是未被锁住则继续执行。 通过线程池的execute(Runnable command)方法传入该异步请求线程，如果出现异常则 responseCallback 返回失败回调。 最终由 ThreadPoolExecutor 的内部类 Worker 进行该线程启动，启动线程方法runWorker(Worker w)中通过 w.firstTask 获取到了异步线程， 并最终调用了该线程的run()方法。 但是 AsyncCall 继承自 NamedRunnable 线程，并且NamedRunnable 的run()方法中调用了自身的抽象方法 execute(),该方法的具体实现是在 AsyncCall 中进行的。 最终关闭调度器 1234567891011121314151617void executeOn(ExecutorService executorService) &#123; assert (!Thread.holdsLock(client.dispatcher())); boolean success = false; try &#123; executorService.execute(this); success = true; &#125; catch (RejectedExecutionException e) &#123; InterruptedIOException ioException = new InterruptedIOException(&quot;executor rejected&quot;); ioException.initCause(e); transmitter.noMoreExchanges(ioException); responseCallback.onFailure(RealCall.this, ioException); &#125; finally &#123; if (!success) &#123; client.dispatcher().finished(this); // This call is no longer running! &#125; &#125;&#125; execute()： 开启发射器的超时定时。 getResponseWithInterceptorChain()方法进行链式拦截和请求。请求成功 Response，将请求结果 Response 通过 responseCallback 回调回去，请求失败回调失败方法。 最终关闭调度器。 12345678910111213141516171819@Overrideprotected void execute() &#123; boolean signalledCallback = false; transmitter.timeoutEnter(); try &#123; Response response = getResponseWithInterceptorChain(); signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e); &#125; else &#123; responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125; Transmitter发射器 Transmitter：OkHttp 的应用程序和网络层之间的桥梁，将应用层的函数发射到网络层，提供了应用层的原函数连接、请求、响应和流。 设置连接池，最终调用的还是OkHttpClient中通过Builder设置的连接池对象，如果没有自定义连接池泽会使用默认的连接池。 设置Call对象。 设置相关指标的监听器，可以通过扩展这个类来监听程序的HTTP的调用数量、大小和持续时间。设置的监听器最终还是调用的OkHttpClient中通过Builder设置的监听对象。1234567public Transmitter(OkHttpClient client, Call call) &#123; this.client = client; this.connectionPool = Internal.instance.realConnectionPool(client.connectionPool()); this.call = call; this.eventListener = client.eventListenerFactory().create(call); this.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS); &#125; Dispatcher Dispatcher ：调度器是执行异步请求的策略。Dispatcher 在异步请求时，维护了一个线程池。这个线程池就是okHttp高效的原因。 readyAsyncCalls ：异步请求的就绪队列。 runningAsyncCalls ：异步请求的执行队列。 runningSyncCalls ：同步请求的执行队列。 executorService(): 创建线程池，在异步请求的时候，如果异步请求结束，所有线程都空闲超过60秒后，会回收该线程池中的所有空闲线程，构造方法传入的参数分别为： 核心线程个数，这里设置的是0，也就是说在真正执行的时候才会去创建线程。 允许的最大线程数量，这里设置的是Integer.MAX_VALUE，但是请求数量是受到了maxRequests限制的。 空闲线程存活的时间，60秒。 setMaxRequests（int maxRequests）：设置最大的请求数。因为最大请求数变动，所以 runningSyncCalls 有所变化，通过promoteAndExecute()方法更新 runningSyncCalls ，也就是将符合条件的 readyAsyncCalls 中的请求提到runningSyncCalls中并运行。 setMaxRequestsPerHost(int maxRequestsPerHost)：设置请求的最大主机数目。因为 maxRequestsPerHost 变化那么 runningSyncCalls 可能有所变动，通过promoteAndExecute()方法更新 runningSyncCalls ，也就是将符合条件的 readyAsyncCalls 中的请求提到runningSyncCalls中并运行。 enqueue(AsyncCall call)：异步方法，将异步请求加入异步请求就绪队列中，对于非websoket请求的异步请求，使之与就绪队列和执行队列中host相同的异步请求，共享当前 host 请求数目（原子数）。 findExistingCallWithHost(String host)：通过请求域名从 readyAsyncCalls 或者 runningAsyncCalls 中，获取host相同的请求。 cancelAll()：取消三个队列中的所有请求。 promoteAndExecute()：如果执行队列中的请求数大于最大请求，那么取消执行。如果当前异步请求的hots请求数目，大于或等于host 请求数目的最大值，那么跳出本次循环。readyAsyncCalls ( 异步请求的就绪队列 ) 中符合条件的请求提升为 runningAsyncCalls ( 异步请求的执行队列 ) 并在执行程序服务上运行它们。 executed(RealCall call)：同步方法，直接将该同步请求加入 runningSyncCalls 中。 finished(AsyncCall call)：结束一个异步请求，首先将其host请求原子数目减一，从 runningAsyncCalls 中删除改异步请求，如果调度器未在运行，那么执行调度器空闲的的回调。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250public final class Dispatcher &#123; private int maxRequests = 64; private int maxRequestsPerHost = 5; private @Nullable Runnable idleCallback; /** * Executes calls. Created lazily. */ private @Nullable ExecutorService executorService; /** * Ready async calls in the order they&apos;ll be run. */ private final Deque&lt;RealCall.AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;(); /** * Running asynchronous calls. Includes canceled calls that haven&apos;t finished yet. */ private final Deque&lt;RealCall.AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;(); /** * Running synchronous calls. Includes canceled calls that haven&apos;t finished yet. */ private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); public Dispatcher(ExecutorService executorService) &#123; this.executorService = executorService; &#125; public Dispatcher() &#123; &#125; public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false)); &#125; return executorService; &#125; /** * Set the maximum number of requests to execute concurrently. Above this requests queue in * memory, waiting for the running calls to complete. * * &lt;p&gt;If more than &#123;@code maxRequests&#125; requests are in flight when this is invoked, those requests * will remain in flight. */ public void setMaxRequests(int maxRequests) &#123; if (maxRequests &lt; 1) &#123; throw new IllegalArgumentException(&quot;max &lt; 1: &quot; + maxRequests); &#125; synchronized (this) &#123; this.maxRequests = maxRequests; &#125; promoteAndExecute(); &#125; public synchronized int getMaxRequests() &#123; return maxRequests; &#125; /** * Set the maximum number of requests for each host to execute concurrently. This limits requests * by the URL&apos;s host name. Note that concurrent requests to a single IP address may still exceed * this limit: multiple hostnames may share an IP address or be routed through the same HTTP * proxy. * * &lt;p&gt;If more than &#123;@code maxRequestsPerHost&#125; requests are in flight when this is invoked, those * requests will remain in flight. * * &lt;p&gt;WebSocket connections to hosts &lt;b&gt;do not&lt;/b&gt; count against this limit. */ public void setMaxRequestsPerHost(int maxRequestsPerHost) &#123; if (maxRequestsPerHost &lt; 1) &#123; throw new IllegalArgumentException(&quot;max &lt; 1: &quot; + maxRequestsPerHost); &#125; synchronized (this) &#123; this.maxRequestsPerHost = maxRequestsPerHost; &#125; promoteAndExecute(); &#125; public synchronized int getMaxRequestsPerHost() &#123; return maxRequestsPerHost; &#125; /** * Set a callback to be invoked each time the dispatcher becomes idle (when the number of running * calls returns to zero). * * &lt;p&gt;Note: The time at which a &#123;@linkplain Call call&#125; is considered idle is different depending * on whether it was run &#123;@linkplain Call#enqueue(Callback) asynchronously&#125; or * &#123;@linkplain Call#execute() synchronously&#125;. Asynchronous calls become idle after the * &#123;@link Callback#onResponse onResponse&#125; or &#123;@link Callback#onFailure onFailure&#125; callback has * returned. Synchronous calls become idle once &#123;@link Call#execute() execute()&#125; returns. This * means that if you are doing synchronous calls the network layer will not truly be idle until * every returned &#123;@link Response&#125; has been closed. */ public synchronized void setIdleCallback(@Nullable Runnable idleCallback) &#123; this.idleCallback = idleCallback; &#125; void enqueue(RealCall.AsyncCall call) &#123; synchronized (this) &#123; readyAsyncCalls.add(call); // Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to // the same host. if (!call.get().forWebSocket) &#123; RealCall.AsyncCall existingCall = findExistingCallWithHost(call.host()); if (existingCall != null) call.reuseCallsPerHostFrom(existingCall); &#125; &#125; promoteAndExecute(); &#125; @Nullable private RealCall.AsyncCall findExistingCallWithHost(String host) &#123; for (RealCall.AsyncCall existingCall : runningAsyncCalls) &#123; if (existingCall.host().equals(host)) return existingCall; &#125; for (RealCall.AsyncCall existingCall : readyAsyncCalls) &#123; if (existingCall.host().equals(host)) return existingCall; &#125; return null; &#125; /** * Cancel all calls currently enqueued or executing. Includes calls executed both &#123;@linkplain * Call#execute() synchronously&#125; and &#123;@linkplain Call#enqueue asynchronously&#125;. */ public synchronized void cancelAll() &#123; for (RealCall.AsyncCall call : readyAsyncCalls) &#123; call.get().cancel(); &#125; for (RealCall.AsyncCall call : runningAsyncCalls) &#123; call.get().cancel(); &#125; for (RealCall call : runningSyncCalls) &#123; call.cancel(); &#125; &#125; /** * Promotes eligible calls from &#123;@link #readyAsyncCalls&#125; to &#123;@link #runningAsyncCalls&#125; and runs * them on the executor service. Must not be called with synchronization because executing calls * can call into user code. * * @return true if the dispatcher is currently running calls. */ private boolean promoteAndExecute() &#123; assert (!Thread.holdsLock(this)); List&lt;RealCall.AsyncCall&gt; executableCalls = new ArrayList&lt;&gt;(); boolean isRunning; synchronized (this) &#123; for (Iterator&lt;RealCall.AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123; RealCall.AsyncCall asyncCall = i.next(); if (runningAsyncCalls.size() &gt;= maxRequests) break; // Max capacity. if (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) continue; // Host max capacity. i.remove(); asyncCall.callsPerHost().incrementAndGet(); executableCalls.add(asyncCall); runningAsyncCalls.add(asyncCall); &#125; isRunning = runningCallsCount() &gt; 0; &#125; for (int i = 0, size = executableCalls.size(); i &lt; size; i++) &#123; RealCall.AsyncCall asyncCall = executableCalls.get(i); asyncCall.executeOn(executorService()); &#125; return isRunning; &#125; /** * Used by &#123;@code Call#execute&#125; to signal it is in-flight. */ synchronized void executed(RealCall call) &#123; runningSyncCalls.add(call); &#125; /** * Used by &#123;@code AsyncCall#run&#125; to signal completion. */ void finished(RealCall.AsyncCall call) &#123; call.callsPerHost().decrementAndGet(); finished(runningAsyncCalls, call); &#125; /** * Used by &#123;@code Call#execute&#125; to signal completion. */ void finished(RealCall call) &#123; finished(runningSyncCalls, call); &#125; private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call) &#123; Runnable idleCallback; synchronized (this) &#123; if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&apos;t in-flight!&quot;); idleCallback = this.idleCallback; &#125; boolean isRunning = promoteAndExecute(); if (!isRunning &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125; &#125; /** * Returns a snapshot of the calls currently awaiting execution. */ public synchronized List&lt;Call&gt; queuedCalls() &#123; List&lt;Call&gt; result = new ArrayList&lt;&gt;(); for (RealCall.AsyncCall asyncCall : readyAsyncCalls) &#123; result.add(asyncCall.get()); &#125; return Collections.unmodifiableList(result); &#125; /** * Returns a snapshot of the calls currently being executed. */ public synchronized List&lt;Call&gt; runningCalls() &#123; List&lt;Call&gt; result = new ArrayList&lt;&gt;(); result.addAll(runningSyncCalls); for (RealCall.AsyncCall asyncCall : runningAsyncCalls) &#123; result.add(asyncCall.get()); &#125; return Collections.unmodifiableList(result); &#125; public synchronized int queuedCallsCount() &#123; return readyAsyncCalls.size(); &#125; public synchronized int runningCallsCount() &#123; return runningAsyncCalls.size() + runningSyncCalls.size(); &#125;&#125; 同步请求123456789101112131415@Override public Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; transmitter.timeoutEnter(); transmitter.callStart(); try &#123; client.dispatcher().executed(this); return getResponseWithInterceptorChain(); &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125; 同步代码块中判断该请求是否已经执行，如果执行了则抛出异常，如果未执行则将excuted置为true。 超时输入定时器，最终调用的是 AsyncTimeout 类中的enter() 方法。 transmitter.callStart() 开始请求的监听，getStackTraceForCloseable() ，应该是追踪捕捉堆栈信息，调用EventListener的callStart()方法（如果没有自定义 EventListener ，那么callStart()是一个空方法）。 1234public void callStart() &#123; this.callStackTrace = Platform.get().getStackTraceForCloseable(&quot;response.body().close()&quot;); eventListener.callStart(call);&#125; 将请求call添加到调度器中的同步请求的执行队列中。 123synchronized void executed(RealCall call) &#123; runningSyncCalls.add(call);&#125; getResponseWithInterceptorChain()：通过拦截器链获取响应并返回。 不管请求是否成功都会执行 Dispatcher 的 finished(RealCall call) 方法，首先在同步代码快中判断同步请求的执行队列是否已经移除当前请求，在同步请求已经结束后从同步请求执行队列中移除该请求。 1234567891011121314151617void finished(RealCall call) &#123; finished(runningSyncCalls, call);&#125; private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call) &#123; Runnable idleCallback; synchronized (this) &#123; if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&apos;t in-flight!&quot;); idleCallback = this.idleCallback; &#125; boolean isRunning = promoteAndExecute(); if (!isRunning &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125;&#125; promoteAndExecute()将 readyAsyncCalls ( 异步请求的就绪队列 ) 中符合条件的请求提升为 runningAsyncCalls ( 异步请求的执行队列 ) 并在执行程序服务上运行它们。该方法中迭代了异步请求就绪队列，在同步请求中并未向该队列添加请求所以不会执行。因此 executableCalls 也为空第二个迭代也不会执行 isRunning 在同步请求中默认为 false。 12345678910111213141516171819202122232425private boolean promoteAndExecute() &#123; assert (!Thread.holdsLock(this)); List&lt;AsyncCall&gt; executableCalls = new ArrayList&lt;&gt;(); boolean isRunning; synchronized (this) &#123; for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123; AsyncCall asyncCall = i.next(); // Max capacity if (runningAsyncCalls.size() &gt;= maxRequests) break; // Host max capacity. if (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) continue; i.remove(); asyncCall.callsPerHost().incrementAndGet(); executableCalls.add(asyncCall); runningAsyncCalls.add(asyncCall); &#125; isRunning = runningCallsCount() &gt; 0; &#125; for (int i = 0, size = executableCalls.size(); i &lt; size; i++) &#123; AsyncCall asyncCall = executableCalls.get(i); asyncCall.executeOn(executorService()); &#125; return isRunning;&#125; 异步请求123456789@Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; transmitter.callStart(); client.dispatcher().enqueue(new AsyncCall(responseCallback));&#125; 同步代码块，判断请求是否还在执行，如果正在执行则抛出异常。 transmitter.callStart() 开始请求的监听，getStackTraceForCloseable() ，应该是追踪捕捉堆栈信息，调用EventListener的callStart()方法（如果没有自定义 EventListener ，那么callStart()是一个空方法）； 1234public void callStart() &#123; this.callStackTrace = Platform.get().getStackTraceForCloseable(&quot;response.body().close()&quot;); eventListener.callStart(call);&#125; 调度器的异步方法 1234567891011void enqueue(AsyncCall call) &#123; synchronized (this) &#123; readyAsyncCalls.add(call); // 使同一域名请求的 AsyncCall 共享原子操作 if (!call.get().forAsyncCallWebSocket) &#123; AsyncCall existingCall = findExistingCallWithHost(call.host()); if (existingCall != null) call.reuseCallsPerHostFrom(existingCall); &#125; &#125; promoteAndExecute();&#125; promoteAndExecute()将 readyAsyncCalls ( 异步请求的就绪队列 ) 中符合条件的请求提升为 runningAsyncCalls ( 异步请求的执行队列 ) 并在执行程序服务上运行它们。 12345678910111213141516171819202122232425private boolean promoteAndExecute() &#123; assert (!Thread.holdsLock(this)); List&lt;AsyncCall&gt; executableCalls = new ArrayList&lt;&gt;(); boolean isRunning; synchronized (this) &#123; for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123; AsyncCall asyncCall = i.next(); // Max capacity if (runningAsyncCalls.size() &gt;= maxRequests) break; // Host max capacity. if (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) continue; i.remove(); asyncCall.callsPerHost().incrementAndGet(); executableCalls.add(asyncCall); runningAsyncCalls.add(asyncCall); &#125; isRunning = runningCallsCount() &gt; 0; &#125; for (int i = 0, size = executableCalls.size(); i &lt; size; i++) &#123; AsyncCall asyncCall = executableCalls.get(i); asyncCall.executeOn(executorService()); &#125; return isRunning;&#125; 创建集合 executableCalls 添加并存储可执行的 Call 。 遍历准备好的异步请求队列 readyAsyncCalls 。 检验正在运行的异步请求队列 runningAsyncCalls 的大小数量，是否超过了最大请求数 maxRequests 默认为64，如果超过了最大的请求个数，直接跳出循环，结束对readyAsyncCalls的遍历。 在遍历的时候会校验异步请求每个主机的请求数是否超过主机最大请求数 maxRequestsPerHost 默认为5，若超过，则跳过这次循环，直接进入下一次循环。 将当前 host 的请求数目加1。 将遍历到的 AsyncCall 添加到可执行队列 executableCalls 和异步请求的执行队列 runningAsyncCalls 中，并在 异步请求就绪队列 readyAsyncCalls 中移除此请求。 依次调用可执行队列 executableCalls 中 AsyncCall 的异步方法，并传入线程池。 AsyncCall类 AsyncCal l类是 RealCall 的一个内部类。 RealCall 异步请求的会调用到该类的 executeOn(）方法，执行相关异步请求操作，该方法中线程池对象 executorService 调用 execute () 方法并传入了 AsyncCall 对象并调用 AsyncCall 的 execute() 方法。 123456789101112131415161718void executeOn(ExecutorService executorService) &#123; assert (!Thread.holdsLock(client.dispatcher())); boolean success = false; try &#123; executorService.execute(this); success = true; &#125; catch (RejectedExecutionException e) &#123; InterruptedIOException ioException = new InterruptedIOException(&quot;executor rejected&quot;); ioException.initCause(e); transmitter.noMoreExchanges(ioException); responseCallback.onFailure(RealCall.this, ioException); &#125; finally &#123; if (!success) &#123; // This call is no longer running! client.dispatcher().finished(this); &#125; &#125;&#125; AsyncCal 父类 NamedRunnable 只做了一件事就是执行execute() 方法，execute() 方法具体实现如下： 12345678910111213141516171819@Override protected void execute() &#123; boolean signalledCallback = false; transmitter.timeoutEnter(); try &#123; Response response = getResponseWithInterceptorChain(); signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e); &#125; else &#123; responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125; getResponseWithInterceptorChain() 放回 Response 对象，然后判断retryAndFollowUpInterceptor是否取消回调CallBack接口的onFailure()或onResponse()方法，最后finally中，和同步请求的处理一样，调用了Dispatcher对象的finished()方法。 1234void finished(AsyncCall call) &#123; call.callsPerHost().decrementAndGet(); finished(runningAsyncCalls, call);&#125; getResponseWithInterceptorChain() 通过拦截器链获取响应并返回 1234567891011121314151617181920212223242526272829303132333435363738394041Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); // 用户自定义的拦截器，用在与服务器建立链接之前进行拦截 interceptors.addAll(client.interceptors()); // 重试和失败重定向拦截器 interceptors.add(new RetryAndFollowUpInterceptor(client)); // 桥接和适配拦截器。主要补充用户创建请求当中的一些请求头Content-Type、Content-Type等 interceptors.add(new BridgeInterceptor(client.cookieJar())); // 缓存拦截器 interceptors.add(new CacheInterceptor(client.internalCache())); // 与服务器建立连接 interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; // 用户自定义的拦截器 用在与服务器建立链接之后进行拦截 interceptors.addAll(client.networkInterceptors()); &#125; // 向服务器发送请求和接收数据的拦截器，将请求写入IO流，再从IO流中读取响应数据。 interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, transmitter, null, 0, originalRequest, this, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); boolean calledNoMoreExchanges = false; try &#123; Response response = chain.proceed(originalRequest); if (transmitter.isCanceled()) &#123; closeQuietly(response); throw new IOException(&quot;Canceled&quot;); &#125; return response; &#125; catch (IOException e) &#123; calledNoMoreExchanges = true; throw transmitter.noMoreExchanges(e); &#125; finally &#123; if (!calledNoMoreExchanges) &#123; transmitter.noMoreExchanges(null); &#125; &#125;&#125; RetryAndFollowUpInterceptor RetryAndFollowUpInterceptor：重试和重定向拦截器，该拦截器可在失败后进行重试并且根据需要进行重定向，如果请求取消会抛出IOException。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300public final class RetryAndFollowUpInterceptor implements Interceptor &#123; /** * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox, * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5. */ // 重定向最多20次数 private static final int MAX_FOLLOW_UPS = 20; private final OkHttpClient client; public RetryAndFollowUpInterceptor(OkHttpClient client) &#123; this.client = client; &#125; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); RealInterceptorChain realChain = (RealInterceptorChain) chain; Transmitter transmitter = realChain.transmitter(); // 重连次数 int followUpCount = 0; Response priorResponse = null; // 循环直到请求成功 while (true) &#123; // 准备创建一个流来承载请求参数。如果存在连接，则优先使用现有连接。 transmitter.prepareToConnect(request); // 如果请求已取消，抛出IOException if (transmitter.isCanceled()) &#123; throw new IOException(&quot;Canceled&quot;); &#125; Response response; boolean success = false; try &#123; // 链式调用下一个拦截器 response = realChain.proceed(request, transmitter, null); success = true; &#125; catch (RouteException e) &#123; // The attempt to connect via a route failed. The request will not have been sent. // 尝试通过路由连接失败。请求将不会被发送。 if (!recover(e.getLastConnectException(), transmitter, false, request)) &#123; throw e.getFirstConnectException(); &#125; continue; &#125; catch (IOException e) &#123; // An attempt to communicate with a server failed. The request may have been sent. // 尝试与服务器通信失败，可能请求已发送 boolean requestSendStarted = !(e instanceof ConnectionShutdownException); // 并尝试从与服务器通信失败中恢复 // 在缓冲主体或在发送请求之前发生故障时，才能恢复具有正文的请求，如果不可恢复则抛出异常 if (!recover(e, transmitter, requestSendStarted, request)) throw e; continue; &#125; finally &#123; // The network call threw an exception. Release any resources. // 释放资源 if (!success) &#123; transmitter.exchangeDoneDueToException(); &#125; &#125; // Attach the prior response if it exists. Such responses never have a body. // 新建一个不含body的响应，并把先前的响应内容附加进去 if (priorResponse != null) &#123; response = response.newBuilder() .priorResponse(priorResponse.newBuilder() .body(null) .build()) .build(); &#125; // 传输单个HTTP请求和响应对。 Exchange exchange = Internal.instance.exchange(response); Route route = exchange != null ? exchange.connection().route() : null; // 重定向的Request，如果请求成功返回空 Request followUp = followUpRequest(response, route); // 请求成功直接返回响应 if (followUp == null) &#123; if (exchange != null &amp;&amp; exchange.isDuplex()) &#123; transmitter.timeoutEarlyExit(); &#125; return response; &#125; // 请求体不为空并且请求体最多可以传输一次，结束重连并返回响应 RequestBody followUpBody = followUp.body(); if (followUpBody != null &amp;&amp; followUpBody.isOneShot()) &#123; return response; &#125; closeQuietly(response.body()); if (transmitter.hasExchange()) &#123; exchange.detachWithViolence(); &#125; // 更新重连次数，如果重连次数大于最大的限制则抛出异常 if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123; throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount); &#125; // 更新Request request = followUp; // 更新响应 priorResponse = response; &#125; &#125; /** * Report and attempt to recover from a failure to communicate with a server. Returns true if * &#123;@code e&#125; is recoverable, or false if the failure is permanent. Requests with a body can only * be recovered if the body is buffered or if the failure occurred before the request has been * sent. */ private boolean recover(IOException e, Transmitter transmitter, boolean requestSendStarted, Request userRequest) &#123; // The application layer has forbidden retries. if (!client.retryOnConnectionFailure()) return false; // We can&apos;t send the request body again. if (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) return false; // This exception is fatal. if (!isRecoverable(e, requestSendStarted)) return false; // No more routes to attempt. if (!transmitter.canRetry()) return false; // For failure recovery, use the same route selector with a new connection. return true; &#125; private boolean requestIsOneShot(IOException e, Request userRequest) &#123; RequestBody requestBody = userRequest.body(); return (requestBody != null &amp;&amp; requestBody.isOneShot()) || e instanceof FileNotFoundException; &#125; private boolean isRecoverable(IOException e, boolean requestSendStarted) &#123; // If there was a protocol problem, don&apos;t recover. if (e instanceof ProtocolException) &#123; return false; &#125; // If there was an interruption don&apos;t recover, but if there was a timeout connecting to a route // we should try the next route (if there is one). if (e instanceof InterruptedIOException) &#123; return e instanceof SocketTimeoutException &amp;&amp; !requestSendStarted; &#125; // Look for known client-side or negotiation errors that are unlikely to be fixed by trying // again with a different route. if (e instanceof SSLHandshakeException) &#123; // If the problem was a CertificateException from the X509TrustManager, // do not retry. if (e.getCause() instanceof CertificateException) &#123; return false; &#125; &#125; if (e instanceof SSLPeerUnverifiedException) &#123; // e.g. a certificate pinning error. return false; &#125; // An example of one we might want to retry with a different route is a problem connecting to a // proxy and would manifest as a standard IOException. Unless it is one we know we should not // retry, we return true and try a new route. return true; &#125; /** * Figures out the HTTP request to make in response to receiving &#123;@code userResponse&#125;. This will * either add authentication headers, follow redirects or handle a client request timeout. If a * follow-up is either unnecessary or not applicable, this returns null. */ private Request followUpRequest(Response userResponse, @Nullable Route route) throws IOException &#123; if (userResponse == null) throw new IllegalStateException(); int responseCode = userResponse.code(); final String method = userResponse.request().method(); switch (responseCode) &#123; case HTTP_PROXY_AUTH: Proxy selectedProxy = route != null ? route.proxy() : client.proxy(); if (selectedProxy.type() != Proxy.Type.HTTP) &#123; throw new ProtocolException(&quot;Received HTTP_PROXY_AUTH (407) code while not using proxy&quot;); &#125; return client.proxyAuthenticator().authenticate(route, userResponse); case HTTP_UNAUTHORIZED: return client.authenticator().authenticate(route, userResponse); case HTTP_PERM_REDIRECT: case HTTP_TEMP_REDIRECT: // &quot;If the 307 or 308 status code is received in response to a request other than GET // or HEAD, the user agent MUST NOT automatically redirect the request&quot; if (!method.equals(&quot;GET&quot;) &amp;&amp; !method.equals(&quot;HEAD&quot;)) &#123; return null; &#125; // fall-through case HTTP_MULT_CHOICE: case HTTP_MOVED_PERM: case HTTP_MOVED_TEMP: case HTTP_SEE_OTHER: // Does the client allow redirects? if (!client.followRedirects()) return null; String location = userResponse.header(&quot;Location&quot;); if (location == null) return null; HttpUrl url = userResponse.request().url().resolve(location); // Don&apos;t follow redirects to unsupported protocols. if (url == null) return null; // If configured, don&apos;t follow redirects between SSL and non-SSL. boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme()); if (!sameScheme &amp;&amp; !client.followSslRedirects()) return null; // Most redirects don&apos;t include a request body. Request.Builder requestBuilder = userResponse.request().newBuilder(); if (HttpMethod.permitsRequestBody(method)) &#123; final boolean maintainBody = HttpMethod.redirectsWithBody(method); if (HttpMethod.redirectsToGet(method)) &#123; requestBuilder.method(&quot;GET&quot;, null); &#125; else &#123; RequestBody requestBody = maintainBody ? userResponse.request().body() : null; requestBuilder.method(method, requestBody); &#125; if (!maintainBody) &#123; requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;); requestBuilder.removeHeader(&quot;Content-Length&quot;); requestBuilder.removeHeader(&quot;Content-Type&quot;); &#125; &#125; // When redirecting across hosts, drop all authentication headers. This // is potentially annoying to the application layer since they have no // way to retain them. if (!sameConnection(userResponse.request().url(), url)) &#123; requestBuilder.removeHeader(&quot;Authorization&quot;); &#125; return requestBuilder.url(url).build(); case HTTP_CLIENT_TIMEOUT: // 408&apos;s are rare in practice, but some servers like HAProxy use this response code. The // spec says that we may repeat the request without modifications. Modern browsers also // repeat the request (even non-idempotent ones.) if (!client.retryOnConnectionFailure()) &#123; // The application layer has directed us not to retry the request. return null; &#125; RequestBody requestBody = userResponse.request().body(); if (requestBody != null &amp;&amp; requestBody.isOneShot()) &#123; return null; &#125; if (userResponse.priorResponse() != null &amp;&amp; userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) &#123; // We attempted to retry and got another timeout. Give up. return null; &#125; if (retryAfter(userResponse, 0) &gt; 0) &#123; return null; &#125; return userResponse.request(); case HTTP_UNAVAILABLE: if (userResponse.priorResponse() != null &amp;&amp; userResponse.priorResponse().code() == HTTP_UNAVAILABLE) &#123; // We attempted to retry and got another timeout. Give up. return null; &#125; if (retryAfter(userResponse, Integer.MAX_VALUE) == 0) &#123; // specifically received an instruction to retry without delay return userResponse.request(); &#125; return null; default: return null; &#125; &#125; private int retryAfter(Response userResponse, int defaultDelay) &#123; String header = userResponse.header(&quot;Retry-After&quot;); if (header == null) &#123; return defaultDelay; &#125; // https://tools.ietf.org/html/rfc7231#section-7.1.3 // currently ignores a HTTP-date, and assumes any non int 0 is a delay if (header.matches(&quot;\\d+&quot;)) &#123; return Integer.valueOf(header); &#125; return Integer.MAX_VALUE; &#125;&#125; BridgeInterceptor BridgeInterceptor：桥接拦截器，负责构建请求和封装响应结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public final class BridgeInterceptor implements Interceptor &#123; private final CookieJar cookieJar; public BridgeInterceptor(CookieJar cookieJar) &#123; this.cookieJar = cookieJar; &#125; @Override public Response intercept(Chain chain) throws IOException &#123; // 获取请求 Request userRequest = chain.request(); // 生成请求的建造者以便进行自定义 Request.Builder requestBuilder = userRequest.newBuilder(); // 获取请求体 RequestBody body = userRequest.body(); if (body != null) &#123; // 添加header，body类型、body长度 MediaType contentType = body.contentType(); if (contentType != null) &#123; requestBuilder.header(&quot;Content-Type&quot;, contentType.toString()); &#125; long contentLength = body.contentLength(); if (contentLength != -1) &#123; requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength)); requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;); &#125; else &#123; requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;); requestBuilder.removeHeader(&quot;Content-Length&quot;); &#125; &#125; if (userRequest.header(&quot;Host&quot;) == null) &#123; // 如果未指定host，则在此添加host requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false)); &#125; if (userRequest.header(&quot;Connection&quot;) == null) &#123; requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;); &#125; // If we add an &quot;Accept-Encoding: gzip&quot; header field we&apos;re responsible for also decompressing // the transfer stream. boolean transparentGzip = false; // 对未添加压缩模式的请求添加gzip压缩 if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) &#123; transparentGzip = true; requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;); &#125; // 添加cookie List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url()); if (!cookies.isEmpty()) &#123; requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies)); &#125; if (userRequest.header(&quot;User-Agent&quot;) == null) &#123; requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent()); &#125; // 交由下一个拦截器处理 Response networkResponse = chain.proceed(requestBuilder.build()); // 缓存服务器返回的Cookie HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers()); // 构建响应的建造者 Response.Builder responseBuilder = networkResponse.newBuilder() .request(userRequest); // 如果使用了压缩并且压缩方式gzip并且响应有内容，使用gzip进行解压，并添加到响应的建造者中。 if (transparentGzip &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;)) &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123; GzipSource responseBody = new GzipSource(networkResponse.body().source()); Headers strippedHeaders = networkResponse.headers().newBuilder() .removeAll(&quot;Content-Encoding&quot;) .removeAll(&quot;Content-Length&quot;) .build(); responseBuilder.headers(strippedHeaders); String contentType = networkResponse.header(&quot;Content-Type&quot;); responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody))); &#125; // 返回response return responseBuilder.build(); &#125; /** * Returns a &apos;Cookie&apos; HTTP request header with all cookies, like &#123;@code a=b; c=d&#125;. */ private String cookieHeader(List&lt;Cookie&gt; cookies) &#123; StringBuilder cookieHeader = new StringBuilder(); for (int i = 0, size = cookies.size(); i &lt; size; i++) &#123; if (i &gt; 0) &#123; cookieHeader.append(&quot;; &quot;); &#125; Cookie cookie = cookies.get(i); cookieHeader.append(cookie.name()).append(&apos;=&apos;).append(cookie.value()); &#125; return cookieHeader.toString(); &#125;&#125; CacheInterceptor CacheInterceptor：向请求写入缓存，并将响应写入缓存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239public final class CacheInterceptor implements Interceptor &#123; final @Nullable InternalCache cache; public CacheInterceptor(@Nullable InternalCache cache) &#123; this.cache = cache; &#125; @Override public Response intercept(Chain chain) throws IOException &#123; // 如果缓存不为空，获取缓存的响应 Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); // 通过当前的请求request和之前缓存的响应，获取当前请求可以使用网络的情况下的缓存的策略。 CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); Request networkRequest = strategy.networkRequest; Response cacheResponse = strategy.cacheResponse; if (cache != null) &#123; // 追踪满足缓存策略的响应 cache.trackResponse(strategy); &#125; // 缓存不适用，关闭缓存处理 if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123; // The cache candidate wasn&apos;t applicable. Close it. closeQuietly(cacheCandidate.body()); &#125; // 网络不可用，并且缓存不足 // If we&apos;re forbidden from using the network and the cache is insufficient, fail. if (networkRequest == null &amp;&amp; cacheResponse == null) &#123; return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message(&quot;Unsatisfiable Request (only-if-cached)&quot;) .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); &#125; // 在不需要网络救完成的情况下直接返回缓存（缓存有效） // If we don&apos;t need the network, we&apos;re done. if (networkRequest == null) &#123; return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); &#125; Response networkResponse = null; try &#123; networkResponse = chain.proceed(networkRequest); &#125; finally &#123; // 遇到异常并且没有响应关闭缓存处理 // If we&apos;re crashing on I/O or otherwise, don&apos;t leak the cache body. if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123; closeQuietly(cacheCandidate.body()); &#125; &#125; // If we have a cache response too, then we&apos;re doing a conditional get. if (cacheResponse != null) &#123; // 如果我们请求时使用了缓存，并且返回的code告诉我们未对响应做修改。那么我们直接使用缓存作为 // 响应只需要更新缓存的时间戳信息、header if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123; Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); // Update the cache after combining headers but before stripping the // Content-Encoding header (as performed by initContentStream()). cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response; &#125; else &#123; // 关闭之前的缓存 closeQuietly(cacheResponse.body()); &#125; &#125; Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); if (cache != null) &#123; // 网络请求的响应有相应体，并且该请求和响应都有缓存，那么存储响应到缓存 if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; // Offer this request to the cache. CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); &#125; // 如果请求方法是POST、PATCH、PUT、DELETE、MOVE代表不可缓存的请求，删除已有缓存 if (HttpMethod.invalidatesCache(networkRequest.method())) &#123; try &#123; cache.remove(networkRequest); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; &#125; &#125; return response; &#125; private static Response stripBody(Response response) &#123; return response != null &amp;&amp; response.body() != null ? response.newBuilder().body(null).build() : response; &#125; /** * Returns a new source that writes bytes to &#123;@code cacheRequest&#125; as they are read by the source * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we * may never exhaust the source stream and therefore not complete the cached response. */ private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response) throws IOException &#123; // Some apps return a null body; for compatibility we treat that like a null cache request. if (cacheRequest == null) return response; Sink cacheBodyUnbuffered = cacheRequest.body(); if (cacheBodyUnbuffered == null) return response; final BufferedSource source = response.body().source(); final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered); Source cacheWritingSource = new Source() &#123; boolean cacheRequestClosed; @Override public long read(Buffer sink, long byteCount) throws IOException &#123; long bytesRead; try &#123; bytesRead = source.read(sink, byteCount); &#125; catch (IOException e) &#123; if (!cacheRequestClosed) &#123; cacheRequestClosed = true; cacheRequest.abort(); // Failed to write a complete cache response. &#125; throw e; &#125; if (bytesRead == -1) &#123; if (!cacheRequestClosed) &#123; cacheRequestClosed = true; cacheBody.close(); // The cache response is complete! &#125; return -1; &#125; sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead); cacheBody.emitCompleteSegments(); return bytesRead; &#125; @Override public Timeout timeout() &#123; return source.timeout(); &#125; @Override public void close() throws IOException &#123; if (!cacheRequestClosed &amp;&amp; !discard(this, ExchangeCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) &#123; cacheRequestClosed = true; cacheRequest.abort(); &#125; source.close(); &#125; &#125;; String contentType = response.header(&quot;Content-Type&quot;); long contentLength = response.body().contentLength(); return response.newBuilder() .body(new RealResponseBody(contentType, contentLength, Okio.buffer(cacheWritingSource))) .build(); &#125; /** * Combines cached headers with a network headers as defined by RFC 7234, 4.3.4. */ private static Headers combine(Headers cachedHeaders, Headers networkHeaders) &#123; Headers.Builder result = new Headers.Builder(); for (int i = 0, size = cachedHeaders.size(); i &lt; size; i++) &#123; String fieldName = cachedHeaders.name(i); String value = cachedHeaders.value(i); if (&quot;Warning&quot;.equalsIgnoreCase(fieldName) &amp;&amp; value.startsWith(&quot;1&quot;)) &#123; continue; // Drop 100-level freshness warnings. &#125; if (isContentSpecificHeader(fieldName) || !isEndToEnd(fieldName) || networkHeaders.get(fieldName) == null) &#123; Internal.instance.addLenient(result, fieldName, value); &#125; &#125; for (int i = 0, size = networkHeaders.size(); i &lt; size; i++) &#123; String fieldName = networkHeaders.name(i); if (!isContentSpecificHeader(fieldName) &amp;&amp; isEndToEnd(fieldName)) &#123; Internal.instance.addLenient(result, fieldName, networkHeaders.value(i)); &#125; &#125; return result.build(); &#125; /** * Returns true if &#123;@code fieldName&#125; is an end-to-end HTTP header, as defined by RFC 2616, * 13.5.1. */ static boolean isEndToEnd(String fieldName) &#123; return !&quot;Connection&quot;.equalsIgnoreCase(fieldName) &amp;&amp; !&quot;Keep-Alive&quot;.equalsIgnoreCase(fieldName) &amp;&amp; !&quot;Proxy-Authenticate&quot;.equalsIgnoreCase(fieldName) &amp;&amp; !&quot;Proxy-Authorization&quot;.equalsIgnoreCase(fieldName) &amp;&amp; !&quot;TE&quot;.equalsIgnoreCase(fieldName) &amp;&amp; !&quot;Trailers&quot;.equalsIgnoreCase(fieldName) &amp;&amp; !&quot;Transfer-Encoding&quot;.equalsIgnoreCase(fieldName) &amp;&amp; !&quot;Upgrade&quot;.equalsIgnoreCase(fieldName); &#125; /** * Returns true if &#123;@code fieldName&#125; is content specific and therefore should always be used * from cached headers. */ static boolean isContentSpecificHeader(String fieldName) &#123; return &quot;Content-Length&quot;.equalsIgnoreCase(fieldName) || &quot;Content-Encoding&quot;.equalsIgnoreCase(fieldName) || &quot;Content-Type&quot;.equalsIgnoreCase(fieldName); &#125;&#125; ConnectInterceptor ConnectInterceptor：打开与目标服务器的连接，然后继续执行下一个拦截器 1234567891011121314151617181920public final class ConnectInterceptor implements Interceptor &#123; public final OkHttpClient client; public ConnectInterceptor(OkHttpClient client) &#123; this.client = client; &#125; @Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); Transmitter transmitter = realChain.transmitter(); // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;); Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks); return realChain.proceed(request, transmitter, exchange); &#125;&#125; networkInterceptors networkInterceptors：用户自定义的拦截器 用在与服务器建立链接之后进行拦截。 12345678910public class DemoInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; // 前置工作 Request request = chain.request(); Response response = chain.proceed(request); // 后置工作 return response; &#125;&#125; CallServerInterceptor CallServerInterceptor：向服务器发送请求和接收数据的拦截器，将请求写入IO流，再从IO流中读取响应数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128public final class CallServerInterceptor implements Interceptor &#123; private final boolean forWebSocket; public CallServerInterceptor(boolean forWebSocket) &#123; this.forWebSocket = forWebSocket; &#125; @Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; // 获取实际请求编码响应解码（Http1ExchangeCodec）的连接管理和时间分层 Exchange exchange = realChain.exchange(); // 获取请求 Request request = realChain.request(); long sentRequestMillis = System.currentTimeMillis(); // 将请求头编码 exchange.writeRequestHeaders(request); boolean responseHeadersStarted = false; Response.Builder responseBuilder = null; // 不是GET或HEAD方法并且包含请求体时 if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) &#123; // If there&apos;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100 // Continue&quot; response before transmitting the request body. If we don&apos;t get that, return // what we did get (such as a 4xx response) without ever transmitting the request body. // 如果请求头中有“Expect：100-continue”标头，在那么发送请求主体之前等待“HTTP / 1.1 // 100.Continue”响应 if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) &#123; exchange.flushRequest(); responseHeadersStarted = true; exchange.responseHeadersStart(); responseBuilder = exchange.readResponseHeaders(true); &#125; if (responseBuilder == null) &#123; //是否双工请求 isDuplex()方法除非被重写，默认返回false if (request.body().isDuplex()) &#123; // Prepare a duplex body so that the application can send a request body later. // 准备双工体，以便应用程序可以稍后发送请求正文。 exchange.flushRequest(); BufferedSink bufferedRequestBody = Okio.buffer( exchange.createRequestBody(request, true)); // 写入双工请求体 request.body().writeTo(bufferedRequestBody); &#125; else &#123; // Write the request body if the &quot;Expect: 100-continue&quot; expectation was met. // 如果是&quot;Expect: 100-continue&quot;那么写下请求体 BufferedSink bufferedRequestBody = Okio.buffer( exchange.createRequestBody(request, false)); request.body().writeTo(bufferedRequestBody); bufferedRequestBody.close(); &#125; &#125; else &#123; exchange.noRequestBody(); // 是否不属于Http/2（此类连接可以同时用于多个HTTP请求。）连接 if (!exchange.connection().isMultiplexed()) &#123; // If the &quot;Expect: 100-continue&quot; expectation wasn&apos;t met, // prevent the HTTP/1 connection from being reused. Otherwise we&apos;re still // obligated to transmit the request body to leave the connection // in a consistent state. exchange.noNewExchangesOnConnection(); &#125; &#125; &#125; else &#123; exchange.noRequestBody(); &#125; // 不存在请求体也不是双工请求 if (request.body() == null || !request.body().isDuplex()) &#123; exchange.finishRequest(); &#125; // 响应头未启动 if (!responseHeadersStarted) &#123; exchange.responseHeadersStart(); &#125; if (responseBuilder == null) &#123; responseBuilder = exchange.readResponseHeaders(false); &#125; Response response = responseBuilder .request(request) .handshake(exchange.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); int code = response.code(); if (code == 100) &#123; // 服务器发送了100-continue，即使我们没有请求，还是应该再请求一次读取实际请求 // server sent a 100-continue even though we did not request one. // try again to read the actual response response = exchange.readResponseHeaders(false) .request(request) .handshake(exchange.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); code = response.code(); &#125; exchange.responseHeadersEnd(response); if (forWebSocket &amp;&amp; code == 101) &#123; // Connection is upgrading, but we need to ensure interceptors see a non-null response body. response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build(); &#125; else &#123; response = response.newBuilder() .body(exchange.openResponseBody(response)) .build(); &#125; if (&quot;close&quot;.equalsIgnoreCase(response.request().header(&quot;Connection&quot;)) || &quot;close&quot;.equalsIgnoreCase(response.header(&quot;Connection&quot;))) &#123; exchange.noNewExchangesOnConnection(); &#125; if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) &#123; throw new ProtocolException( &quot;HTTP &quot; + code + &quot; had non-zero Content-Length: &quot; + response.body().contentLength()); &#125; return response; &#125;&#125;]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java动态代理]]></title>
    <url>%2F2019%2F02%2F17%2FJava%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[代理是什么？ 代理是一种模式，提供对目标对象的间接访问方式，即通过代理访问目标对象。 便于在目标的实现基础上实现额外的功能操作，前拦截、后拦截等。 静态代理 编写一个代理类，实现与目标对象相同的接口，并在内部维护一个目标对象的引用。通过构造器塞入目标对象，在代理对象中调用目标对象的同名方法，并添加前拦截，后拦截等所需的业务功能。 静态代理的实现方式 统一接口 123public interface Human &#123; void eat(String food);&#125; 目标对象实现类实际实现功能 1234567public class HumanImpl implements Human &#123; @Override public void eat(String food) &#123; System.out.println(&quot;Today human eat&quot; + food); &#125;&#125; 代理对象实现类 123456789101112131415public class HumanProxy implements Human &#123; Human human; public HumanProxy(Human human) &#123; this.human = human; &#125; @Override public void eat(String food) &#123; // 前拦截 dosSomething(); human.eat(food); // 后拦截 dosSomething(); &#125;&#125; 最终通过代理对象访问目标对象 12345678public class Test &#123; public static void main(String[] args) &#123; //把目标对象通过构造器塞入代理对象 Human human = new HumanProxy(new HumanImpl()); //代理对象调用目标对象方法，并在前后打印日志或其它操作 human.eat(&quot;西兰花&quot;); &#125;&#125; 静态代理的优点： 可以在不修改目标对象的前提下，对目标对象进行功能的扩展和拦截。 对扩展开发，对修改关闭 静态代理的缺点： 如果Human接口有几十上百的方法，对每一个方法扩展和拦截，需要一个个方法进行修改，工作量太大并且不利于后期的维护。 可能存在重复代码。 HumanProxy只能接收Human的实现类对象，所以对于不同的接口每一次都需创建相应的代理对象。 动态代理从静态代理到动态代理 通过静态代理的实现，我们发现真正需要的是代理对象，而不是代理类。因为我们的一贯认知是：先有类，再有对象。 接口和类的区别：接口定义了方法，只是没有具体实现（方法体），除此之外和类都是相同的。 对于代理对象来说方法体并不重要，因为代理对象可以直接调用目标对象的方法来完成需求。即对于代理对象来说，自身方法实现并不重要，重要的是如何调用目标对象的方法实现。 本质上我们只需要一个根据接口生成一个“空壳”的代理对象的壳而已。 JDK提供了一组API，可以让我们动态地在内存中构建代理对象（需传入目标类实现的接口）。这种代理方式称为JDK动态代理 对象创建的过程 加载类，ClassLoader加载.class（字节码）文件到内存，执行静态代码块和静态初始化语句。 执行new，申请一片内存空间。 调用构造器，创建一个空白的Class对象。 子类调用父类的构造器。 构造器执行，执行构造代码块和初始化语句，构造器内容。 接口也是一个类，所以当接口类被加载到内存会创建一个空白的对象，此时我们所需的代理对象已经有了，但是接口对象有方法但是缺少方法体，但是我们最终只需调用目标对象实现类的方法即可，所以方法体也不是必须。 动态代理实现 Proxy.getProxyClass(ClassLoader loader,Class&lt;?&gt;… interfaces)：传入ClassLoader和一组接口返回代理类的Class对象，而不用实际编写代理类。本质上我们是通过Proxy类的静态方法，从接口Class身上“借”了它的方法信息，自己本身又有一个构造器，最终才创建了一个新的加强版的代理Class&lt;$Proxy0&gt;对象，也就是$Proxy0。与原先接口Class当然不存在继承或实现关系。 获取新的加强版的代理Class&lt;$Proxy0&gt;对象之后，便是通过反射获取代理对象$Proxy0的实例。通过反射getConstructor(InvocationHandler.class)方法获取指定类InvocationHandler.class的构造方法。 通过指定类InvocationHandler.class的构造方法获取代理对象$Proxy0的实例。 每次调用代理对象的方法时，都会调用它里面的invocationHandler的invoke()方法。但是我们需要的是代理对象调用目标对象的方法。 在invoke()方法内部调用目标对象。 1234567891011121314151617181920212223242526272829// 获取加强版的代理Class&lt;$Proxy0&gt;对象Class&lt;?&gt; humanProxyClass = Proxy.getProxyClass(Human.class.getClassLoader(), Human.class);try &#123; // 获取InvocationHandler的构造方法 Constructor&lt;?&gt; constructor = humanProxyClass.getConstructor(InvocationHandler.class); // 通过指定类InvocationHandler.class的构造方法获取代理对象$Proxy0的实例 Human humanProxyImpl = (Human) constructor.newInstance(new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 前拦截 dosSomething(); // 手动创建目标对象 HumanImpl humanImpl = new HumanImpl(); // 反射执行目标对象方法 Object result = method.invoke(humanImpl, args); // 后拦截 dosSomething(); // 返回目标对象执行结果 return result; &#125; &#125;); humanProxyImpl.eat(&quot;猪肉&quot;);&#125; catch (NoSuchMethodException e) &#123; e.printStackTrace();&#125; catch (IllegalAccessException e) &#123; e.printStackTrace();&#125; catch (InstantiationException e) &#123; e.printStackTrace();&#125; catch (InvocationTargetException e) &#123; e.printStackTrace();&#125; 动态代理实现优化1234567891011121314151617181920public class Test &#123; public static void main(String[] args) &#123; HumanImpl humanImpl = new HumanImpl(); Human humanProxy = (Human) getProxy(humanImpl); humanProxy.eat(&quot;瘦肉&quot;); &#125; private static Object getProxy(final HumanImpl target) &#123; Object proxyInstance = Proxy.newProxyInstance(Human.class.getClassLoader(), Human.class.getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 前拦截 dosSomething(); Object result = method.invoke(target, args); // 后拦截 dosSomething(); return result; &#125; &#125;); return proxyInstance; &#125;&#125;]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Broadcast基础]]></title>
    <url>%2F2018%2F09%2F26%2FBroadcast%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[广播机制概述 广播机制是在组件之间传播数据的一种机制，这些组件可以位于不同的进程中，起到进程间通信的作用。通过广播可以通知系统或指定应用消息，或者监听来自系统或者应用的广播通知，类似于发布——订阅设计模式。其包含两个角色：广播发送者、广播接收者。 系统广播权限的变化 Android 7.0（API24）开始不会发送以下系统广播： ACTION_NEW_PICTURE ACTION_NEW_VIDEO 并且从Adnroid 7.0 开始，CONNECTIVITY_ACTION广播（网络连接状态改变）的广播接收者必须使用使用显示注册registerReceiver(BroadcastReceiver, IntentFilter)，在清单文件种直接声明该广播接收者将不在起作用。 Android 8.0（API26）系统堆清单文件种声明的广播接收者新增了限制，也就是Android 8.0开始，开发者无法使用清单为大多数隐式广播声明接收方，但是任然可以使用显式注册的方式声明广播接收者。 Android 9 （API28）开始NETWORK_STATE_CHANGED_ACTION(WIFI连接状态改变)广播中将无法接收到有关用户位置或个人身份数据的信息，例如SSID，BSSID，连接信息或扫描结果等。但是可以通过getConnectionInfo()的方式获取相关数据。 广播发送广播发送内容广播消息包装在一个Intent对象中。intent的操作字符串必须提供应用程序的Java包名称语法，并唯一标识广播事件。可以使用附加信息或附加其他信息putExtra(String, Bundle)。还可以通过调用setPackage(String)intent 将广播限制为同一组织中的一组应用程序。 广播发送方式： 发送有序广播：sendOrderedBroadcast(Intent, String) 方法一次向一个接收器发送广播。当每个接收者依次执行时，它可以将结果传播到下一个接收者，或者它可以完全中止广播，以便它不会传递给其他接收器。运行的接收者可以使用匹配的intent-filter的android:priority属性进行控制; 具有相同优先级的接收器将以任意顺序运行。 发送正常广播：sendBroadcast(Intent)方法以未定义的顺序向所有接收者发送广播。效率更高，但接收者无法从其他接收器读取结果，无法发送从广播接收的数据或中止广播。 发送本地广播：LocalBroadcastManager.sendBroadcast方法将广播发送到与发送者位于同一应用程序中的接收者。如果不需要向其它应用程序发送广播，请使用本地广播。实现效率更高（无需进程间通信），并且无需担心与其他应用程序能够接收或发送广播相关的任何安全问题。 广播接收者 广播接收者可以对发送过来的Broadcast进行过滤、接收和响应。 广播接收方式——清单文件声明广播接收者 系统软件包管理器在安装应用程序时注册接收器。接收器就成为应用程序的单独入口点，这意味着如果应用程序当前未运行，那么系统会在发送该广播时启动应用（应用未启动）。但是自Android 8.0（API26）开始，无法使用清单文件声明的方式来声明隐式广播的广播接收者。 &lt;revceiver&gt;在应用清单文件中声明指定元素，intent过滤器指定接收者订阅的广播操作。 12345678&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt; &lt;action android:name=&quot;android.intent .action.INPUT_METHOD_CHANGED&quot; /&gt; &lt;/ intent-filter&gt;&lt;/ receiver&gt; 创建BroadcastReceiver子类并实现onReceive(Context, Intent)。广播接收者记录并显示广播的内容： 12345678910public class MyBroadcastReceiver extends BroadcastReceiver &#123; private static final String TAG = &quot;MyBroadcastReceiver&quot;; @Override public void onReceive(Context context, Intent intent) &#123; String log = &quot;Action: &quot; + intent.getAction() + &quot;\n&quot; + &quot;URI: &quot; + intent.toUri(Intent.URI_INTENT_SCHEME) + &quot;\n&quot;; Log.w(TAG,log); Toast.makeText(context, log, Toast.LENGTH_LONG).show(); &#125;&#125; 广播接收方式——通过上下文注册广播接收者 创建一个实例BroadcastReceiver。 1MyBroadcastReceiver myBroadcastReceiver = new MyBroadcastReceiver(); IntentFilter通过调用registerReceiver(BroadcastReceiver, IntentFilter)以下命令创建并注册接收者，广播接收者的声明周期和注册上下文的声明周期一致： 123IntentFilter filter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);filter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);this.registerReceiver(br, filter); 通过unregisterReceiver(android.content.BroadcastReceiver)停止广播接收者，当不在需要广播接收者或上下文失效时必须停止广播接收者。需要注意注册和取消注册接收器的位置，例如，在onCreate(Bundle)使用Activity的上下文中注册接收器，则应在onDestroy()取消注册以防止接收者内存泄漏。如果在onResume()注册了接收者，则应在onPause()取消注册，以防止多次注册（如果不想在暂停时接收广播，这可以减少不必要的系统开销）。不要在onSaveInstanceState(Bundle)取消注册，因为用户触发back操作则不会调用此方法。 发送和接收广播的限制发送限制 当调用sendBroadcast(Intent, String)或 sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)时，可以指定权限参数。只有已经请求该许可的接收者他们的清单中的标签（如果它是危险的，则随后被授予许可）可以接收广播。例如： 1sendBroadcast(new Intent(&quot;com.example.NOTIFY&quot;),Manifest.permission.SEND_SMS); 对于广播接收者需要声明相关权限才可接收到广播： 1&lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot;/&gt; 不仅可以使用系统的权限，也可以自定义权限。 接收权限 在注册广播接收器时指定了权限（在清单中带有registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)或在&lt;recevicer&gt;标签中），那么只有已经&lt;uses-permission&gt;在其清单中声明的相应的权限（危险权限需要用户授权权限）的发送者才可以发送对接收者的意图。]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment基础]]></title>
    <url>%2F2018%2F09%2F16%2FFragment%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[第五组件Fragment Fragment 表示 Activity 中的行为或用户界面部分。可以将多个片段组合在一个 Activity 中来构建多窗口 UI，以及在多个 Activity 中重复使用某个片段。可以将片段视为 Activity 的模块化组成部分，它具有自己的生命周期，能接收自己的输入事件，并且可以在 Activity 运行时添加或移除片段（类似可以在不同 Activity 中重复使用的“子 Activity”）。 Fragment两种加载方式静态加载 创建继承Fragment的子类并生成相应布局文件。 在需加载Fragment的布局文件中声明fragment控件，指定android:name为刚刚创建的Fragment(Fragment必须用id或tag作为唯一标识)。 动态加载 Fragment事务：对Fragment进行添加、移除、替换或执行其它动作，提交给Activity的每一个变化。 FragmentManage：管理Fragment。 通过FragmentManager.beginTransaction()我们可以开始一个事务。在事务中，我们可以对Fragment进行的操作以及对应的方法如下： 添加：add() 移除：remove() 替换：replace() 提交事务：commit() 还有attach()、detach()、hide()、addToBackStack()等方法。 加载方法 获取Fragment管理器开始事务； 替换Fragment，将替换事务保存到返回栈，以便用户能够通过按返回按钮撤消事务并回退到上一片段； 提交commi()方法； 1234567Fragment newFragment = new ExampleFragment();FragmentTransaction transaction = getFragmentManager().beginTransaction();transaction.replace(R.id.fragment_container, newFragment);transaction.addToBackStack(null);transaction.commit(); FragmentPagerAdapter与FragmentStatePagerAdapter FragmentPagerAdapter适用于页面较少的的情况，FragmentStatePagerAdapter适用于页面较多的情况。 FragmentPagerAdapter：destroyItem调用detach方法，它并不是真正的内存回收只是把Fragment的UI和Activity的UI脱离开来。该类内的每一个生成的 Fragment 都将保存在内存之中。 123456789@Overridepublic void destroyItem(ViewGroup container, int position, Object object) &#123; if (mCurTransaction == null) &#123; mCurTransaction = mFragmentManager.beginTransaction(); &#125; if (DEBUG) Log.v(TAG, &quot;Detaching item #&quot; + getItemId(position) + &quot;: f=&quot; + object + &quot; v=&quot; + ((Fragment)object).getView()); mCurTransaction.detach((Fragment)object); &#125;&#125; FragmentStatepagerAdapter：在destroyItem的时调用remove是真正的释放了Fragment的内存，所以更加节省内存。所以说在每次切换ViewPager的时候是真正回收内存的，该 PagerAdapter 的实现将只保留当前页面，当页面离开视线后，就会被销毁，释放其资源；而在页面需要显示时，生成新的页面)。FragmentStatePagerAdapter在销毁Fragment时会调用onSaveInstanceState方法保存一些数据信息，然后下一次创建Fragment时会将这些数据读取出来。 1234567891011121314151617@Overridepublic void destroyItem(ViewGroup container, int position, Object object) &#123; Fragment fragment = (Fragment) object; if (mCurTransaction == null) &#123; mCurTransaction = mFragmentManager.beginTransaction(); &#125; if (DEBUG) Log.v(TAG, &quot;Removing item #&quot; + position + &quot;: f=&quot; + object+ &quot; v=&quot; + ((Fragment)object).getView()); while (mSavedState.size() &lt;= position) &#123; mSavedState.add(null); &#125; mSavedState.set(position, fragment.isAdded() ? mFragmentManager.saveFragmentInstanceState(fragment) : null); mFragments.set(position, null); mCurTransaction.remove(fragment);&#125; Fragment生命周期Fragment的生命周期图 onActtach()：当Fragment第一次绑定上下文时调用 onCreate()：初始化Fragment，可以通过saveInstanceState获取保存的值。 onCreateView()：初始化Fragment布局，加载布局和获取控件通常在次方法呢i完成，但不建议做耗时操作。非图形的片段可以返回null。 onActivityCreated()：当Fragment绑定的Activity创建完成并且Fragment的视图已经实例化，在该方法内可以进行与Activity交互的UI操作。 onStart()：当Fragment对用户可见时调用 onResume()：Fragment对用户可见，处于前台可以响应用户交互动作。 onPause()：Fragment处于暂停状态，但依然可见，用户不能与之交互。 onStop()：Fragment不可见。 onDestroyView()：销毁与Fragment有关的视图，但未与Activity解除绑定，依然可以通过onCreateView方法重新创建视图。通常在ViewPager+Fragment的方式下会调用此方法。 onDestroy()：销毁Fragment。通常按Back键退出或者Fragment被回收时调用此方法。 onDetach()：解除与Activity的绑定。 onSaveInstanceState()：保存当前Fragment的状态。该方法会自动保存Fragment的状态，比如EditText键入的文本，即使Fragment被回收又重新创建，一样能恢复EditText之前键入的文本。 Fragment与Activity的生命周期关系图 Fragment通信 在Fragment中通过getActivity()获得Activity实例然后调用Activity的方法。 在Activity中调用Fragment方法的接口回调。 在Fragment中通过getActivity()获取到Activity的实例，然后通过该实例调用findFragmentById()获取到其它Fragment的实例，最后调用其它Fragment的方法。]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity基础]]></title>
    <url>%2F2018%2F09%2F07%2FActivity%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[生命周期 Activity的状态 running：处于活动状态，用户可以点击屏幕与之交互，即当前Activity处于栈顶。 pause：失去焦点。例：被非全屏或者透明的Activity占据，当前Activity不处于栈顶但还是可见，不可与用户交互，但是所有的状态信息和成员变量都还在。 stopped：当前Activity完全覆盖，不再可见，如果内存不紧张那么它的状态信息、成员变量可能还在，如果内存紧张会被回收。 killed：Activity已经被系统回收，保存的信息和成员变量不存在。 正常情况下的生命周期 正常生命周期：有用户参与的情况下Activity所经过的生命周期，常见用户操作引起的生命周期回调有： Activity第一次启动回调：onCreate→onStart→onResume 用户回到Activity回调：onRestart→onStart→onResume 用户打开新的Activity或切换到桌面是原Activity的回调：onPause→onStop，但是当新的Activity为透明时，原Activity不会回调onStop因为原Activity依旧可见。 当Activity按back回退回调：onPause→onStop→onDestory 各生命周期方法概述： onCreate：Activity处于创建之中，在进行加载布局资源、初始化所需的数据、绑定相关View等工作，onCreat始终节onStart方法。 onRestart：Activity正在重新启动（从不可见到可见），常见的情况为Home键切换到桌面或者跳转到新的Activity导致当前的Activity暂停，之后又重新回到改Activity时。 onStart：Activity正在启动，Activity已经处于可见状态但是还未处于前台无法与用户交互。 onResume：Activity已经可见并可与用户交互（处于前台）。 onPasuse：Activity正在停止，正常情况下跟着会调用onStop。但是在特殊情况下，快速回到当前Activity那么onResume会被调用。此时可以进行不耗时存储数据、停止动画的操作，否则回影响新Activity的显示，因为当前Activity的onPasuse必须执行完，新Activity的onResume才会执行。 onStop：Activity处于不可见且不可交互状态即将停止（如果新的Activity是透明主题那么不会调用onStop），做一些较为重量级的回收工作，但是同样不能太过耗时。 onStop：Activity即将销毁，可以在此做回收以及资源释放。 各生命周期的联系： onStart和onStop从Activity是否可见的角度来回调。 onResume和onPause从Activity是否可交互（处于前台状态）的角度回调。 从FirstActivity启动SecondActivity，必须等到FirstActivity先onPause之后SecondActivity才能启动。 异常情况下的生命周期 异常情况下的生命周期：Activity被系统回收或者设备的Configuration发生改变，从而导致Activity销毁重建情况下生命周期的改变。 资源相关的系统配置发生改变导致Activity被杀死并重新创建 Activity状态的保存与恢复：系统配置发生改变后Activity会被销毁，在销毁之前会调用onPause、onStop、onDestroy。但是由于是在异常情况下终止，系统会调用onSaveInstancestate来保存当前Activity的状态（正常情况不会回调该方法，该方法只有在Activity即将被销毁并且有机会重新显示才被调用）。 该方法在onStop之前调用，但是该方法可能在onPause之前调用，也可能在onPause之后调用。Activity被重新创建后系统回调用onRestoreInstanceState方法将保存状态的Bundle对象作为参数传给onRestoreInstanceState方法和onCreate方法（调用onRestoreInstanceState其参数Bundle必定有值，而onCreate则不一定有值）。 Activity视图结构的保存与恢复：Activity在异常情况下需要重新创建时，系统会默认保存当前当前Activity的视图结构，并在Activity重启之后来恢复数据，如文本框中用户输入的数据、Listview滚动的位置、Radiobutton的选中状态等等。具体可以恢复View的哪些数据，需要查看View的onSaveInstanceState和onRestroeInstanceState方法。具体流程：Activity会调用onSaveInstanceState保存数据，然后Activity委托Window去保存数据，接着Window再委托它上面的顶层容器去保存数据，顶层容器一般来说很可能是DecorView，最后顶层容器一一通知它的子容器保存数据。 系统配置改变却不重建Activity的方式：指定Activtiy的configChanges属性，常使用的是locale、orientation和keyboardHidden这三个属性，其他属性可查询官方文档。 横竖屏切换的生命周期改变： 在Android3.2，API13以前： 不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次。 设置Activity的android:configChanges=&quot;orientation&quot;时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次。 设置Activity的android:configChanges=&quot;orientation|keyboardHidden&quot;时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged()方法。 在Android3.2，API13以后： 不设置Activity的android:configChanges，或设置Activity的android:configChanges=&quot;orientation&quot;，android:configChanges=&quot;orientation|keyboardHidden&quot;，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行一次。 配置 android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;，才不会销毁 activity，且只调用 onConfigurationChanged()方法。 onConfigurationChanged()：可以切换UI; 资源内存不足导致优先级低的Activity被杀死 当系统内存不足时，系统按照Activity的优先级杀死Activity所在的进程，并在后续通过onSavaInstanceState和onRestoreInstancdState来存储和恢复数据。 Activity的优先级： 前台Activity：正在和用户交互的Activity，优先级最高。 可见但是非前台的Activity：Activity可见但是位于后台无法与用户直接交互，如Activity弹出一个对话框时，该Activity此时就是可见但非前台的。 后台Activity：已经被暂停的Activity，如执行onStop既无法与用户交互又不可见，优先级最低。 管理生命周期 Activity生命周期三大状态。 继续：此 Activity 位于屏幕前台并具有用户焦点。（有时也将此状态称作“运行中”）。 暂停：另一个 Activity 位于屏幕前台并具有用户焦点，但此 Activity 仍可见。也就是说，另一个 Activity 显示在此 Activity 上方，并且该 Activity 部分透明或未覆盖整个屏幕。 暂停的 Activity 处于完全活动状态（Activity对象保留在内存中，它保留了所有状态和成员信息，并与窗口管理器保持连接），但在内存极度不足的情况下，可能会被系统终止。 停止：该 Activity 被另一个 Activity 完全遮盖（该 Activity 目前位于“后台”）。 已停止的 Activity 同样仍处于活动状态（Activity 对象保留在内存中，它保留了所有状态和成员信息，但未与窗口管理器连接）。 不过，它对用户不再可见，在他处需要内存时可能会被系统终止。 Activity生命周期： Activity 的整个生命周期：发生在 onCreate(调用与 onDestroy() 调用之间。 Activity 应在 onCreate()中执行“全局”状态设置（如定义布局），并在 onDestroy() 中释放的所有资源。例如，如果的 Activity 有一个在后台运行的线程，用于从网络上下载数据，它可能会在 onCreate()中创建该线程，然后在 onDestroy() 中停止该线程。 Activity 的可见生命周期：发生在 onStart()调用与 onStop()调用之间。在这段时间，用户可以在屏幕上看到 Activity 。 例如，当一个新 Activity 启动，并且当前 Activity 不再可见时，系统会调用 onStop()。开发者可以在调用这两个方法间保留向用户显示 Activity 所需的资源。 例如在 onStart() 中注册BroadcastReceiver以监控影响 UI 的变化，并在用户无法再看到显示的内容时在 onStop()中将其取消注册。在 Activity 的整个生命周期，当 Activity 在对用户可见和隐藏两种状态中交替变化时，系统可能会多次调用 onStart()和 onStop()。 Activity 的前台生命周期：发生在 onResume() 与 onPause()之间。在这段时间，Activity 位于屏幕上的所有其他 Activity 之前，并具有用户输入焦点。 Activity 可频繁转入和转出前台 — 例如，当设备转入休眠状态或出现对话框时，系统会调用 onPause()。 由于此状态可能经常发生转变，因此这两个方法中应采用适度轻量级的代码，以避免因转变速度慢而让用户等待 启动模式启动模式的两种设置方式 通过AndroidMenifest为Activity指定启动模式android:launchMode。 通过在Intent设置标志为来为Activity指定启动模式。 区别：第二张指定方式优先级高于第一种指定方式，第一种指定方式无法直接为Activity设定FLAG_ACTIVITY_CLEAR_TOP标识，第二张无法为Activity指定singleInstance模式。 任务栈 任务栈是一种后进先出的栈结构。 standard启动模式下每次启动Activity都会生成新实例加入返回栈处于栈顶，每按下back键一次就会使栈顶的Activity销毁出栈，直 至任务栈清空，当栈中没有任何Activity时，系统就会回收该任务栈。 只有处于任务栈栈顶的Activity才可以与用户进行交互。 当退出应用时，必须把所有任务栈中所有Activity清除出栈，任务栈才会被销毁。 任务栈中的Activity可能并不来自同一App，同时应用中的Activity也可能处于不同任务栈中。 standard标准模式 每次启动Activity不管任务栈中是否存在该Activity的实例，都会重新创建一个实例。 Activity标准的启动模式，启动时会调用onCreat、onStart、onResume方法。 被启动的Activity会处于启动它的Activity的所在的任务栈中。 singleTop栈顶复用模式 如果新的Activity已经存在并位于任务栈的栈顶，那么该Activity不会被创建，只是调用它的onNewInstent方法。 如果新的Activity实例已经存在但不是位于栈顶，那么该Activity会被重新创建。 singTask栈内复用模式 单实例模式，在新Activity启动后，系统会检查是否存在新Activity所需的任务栈，如果所需任务栈不存在，那么系统会创建所需的任务栈。如果所需的任务栈已经存在，那么会判断栈中是否存在该Activity实例，如果在栈中已经存在该Activity实例，该Activity实例上的其它Activity实例全部出栈，使该Activity实例成为栈顶对象，系统也会回调onNewInstent。如果此栈中该Activity不存在，那么就会创建该Activity实例并把其压入栈中。 默认状态下所有Activity所需的任务栈的名字都为应用的包名，但是我们可以制定TaskAffinity的属性值来设置目标任务栈。TaskAffinity属性主要和singTask模式或者allowTaskReparenting属性配对使用，在其它情况下没有意义。 TaskAffinity和allowTaskReparenting结合使用时，如果当A应用启动了B应用的某个ActivityC并且这ActivityC的allowTaskReparenting为true时，那么此当B应用启动时ActivityC会直接从A的任务栈转移到B的任务栈中。此时桌面启动B应用那么打开的会是B应用中的ActivityC，因为ActivityC已经从A应用的任务栈中转移到B应用的任务栈中，所以此时B应用并不会启动主Activity。 singleInstance 单实例模式，它会启用一个新的任务栈，将Activity放置于这个新的任务栈中，并保证不再有其他Activity实例进入。singleInstance所标识的Activity，当被启动时，系统会首先判断系统所有的任务栈中是否已经存在此Activity实例，有则直接使用，并且在其所在的Activity栈理论上只有它一个Activity。所以启动它的Activity与它并不在一个Task中，因此需要特别注意Back的问题，因为按下back ，singleInstance所创建的唯一实例就会销毁并且该栈中不存在其他Activity，自然回到了打开改Activity的Activity。 一般表示为：task1 A-&gt;task2 B。singleInstance与singleTask主要区别在于是系统范围内的唯一实例还是当前任务栈中唯一实例。 scheme跳转协议 Android中的自定义的URL Scheme是一种页面内跳转协议，就是通过类似打开网页的方式去通过路由打开一个Activity，而非直接通过显式Intent方式去进行跳转。通过scheme协议，服务器可以预先App跳转哪个页面。可以通过通知栏消息定制化跳转页面，可以动过H5页面跳转页面等。 优点 降低耦合度：不需要知道具体跳转哪个界面，只需要根据需求，按照预定好的URL路由协议发送Intent即可。 安全性更高：不显示Intent跳转，只要符合协议的Intent都会有对应Activity来匹配，避免跳转到不该出现的页面。 灵活：应用场景更加广泛。 服务器下发跳转路径，客户端根据服务器下发跳转路径跳转相应的页面 H5页面点击锚点，根据锚点具体跳转路径APP端跳转具体的页面 APP端收到服务器端下发的PUSH通知栏消息，根据消息的点击跳转路径跳转相关页面 APP根据URL跳转到另外一个APP指定页面 URL Scheme协议格式 完整的URL Scheme协议格式由scheme、host、port、path和query组成，其结构如下所示： ://:/? 自定义的协议的URI： xl://goods:8888/goodsDetail?goodsId=10011002 xl，即为Scheme，代表该Scheme 协议名称 goods，即为Host，代表Scheme作用于哪个地址域 8888，即为port，代表该路径的端口号 goodsDetail，即为path， 代表Scheme指定的页面 goodsId，即为query，代表传递的参数 URL Scheme的使用方法 在AndroidMainifest.xml中对标签增加设置Scheme 12345678910111213141516171819202122&lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;!--正常启动--&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;!--URL Scheme启动--&gt; &lt;!--必有项--&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt; &lt;!--如果希望该应用可以通过浏览器的连接启动，则添加该项--&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt; &lt;!--表示该页面可以被隐式调用，必须加上该项--&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;!--协议部分--&gt; &lt;data android:scheme=&quot;urlscheme&quot; android:host=&quot;auth_activity&quot;&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;emms.intent.action.check_authorization&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;category android:name=&quot;emms.intent.category.authorization&quot;/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; URL Scheme协议格式中，组成URI的这些属性在标签中都是可选的 ，但存在如下的依赖关系： 如果没有指定scheme，那么host参数会被忽略； 如果没有指定host，那么port参数会被忽略； 如果scheme和host都没有指定，path参数会被忽略； 当我们将intent对象中的Uri参数与intent-filter中的标签指定的URI格式进行对比时，我们只对比intent-filter的标签指定的部分，例如： 如果intent-filter中只指定了scheme，那么所有带有该sheme的URI都能匹配到该intent-filter。 如果intent-filter中只指定了scheme和authority（authority包括host和port两部分）而没有指定path，那么所有具有相同scheme和authority的URI都能匹配到该intent-filter，而不用考虑path为何值。 如果intent-filter中同时指定了scheme、authority和path，那么只有具有相同scheme、authority和path的URI才能匹配到该intent-filter。 使用URL启动Activity 12345678910Uri data = Uri.parse(&quot;urlschemel://auth_activity&quot;); Intent intent = new Intent(Intent.ACTION_VIEW,data); //保证新启动的APP有单独的堆栈，如果希望新启动的APP和原有APP使用同一个堆栈则去掉该项 intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); try &#123; startActivityForResult(intent, RESULT_OK); &#125; catch (Exception e) &#123; e.printStackTrace(); Toast.makeText(MainActivity.this, &quot;没有匹配的APP，请下载安装&quot;,Toast.LENGTH_SHORT).show(); &#125; 12&lt;!--网页中调用--&gt;&lt;a href=&quot;urlschemel://auth_activity&quot;&gt;打开新的应用&lt;/a&gt; 12// Js中调用window.location = &quot;urlschemel://auth_activity&quot;; 判断URL Scheme是否有效 12345boolean checkUrlScheme(Intent intent)&#123; PackageManager packageManager = getPackageManager(); List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(intent, 0); return !activities.isEmpty();&#125; 将子App在Home Launcher中隐藏 有时候需要把一些辅助性的、较为独立的APP在Home Launcher中隐藏起来，只允许一些特定的APP调用。这个时候，我们可以利用URL Scheme协议来做到这一点，设置AndroidManifest.xml中对标签如下 123456789101112&lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt; &lt;!--表示该页面可以被隐式调用，必须加上该项--&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;!--协议部分--&gt; &lt;data android:scheme=&quot;urlscheme&quot; android:host=&quot;auth_activity&quot;&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 因为Home Launcher列出的应用图标要求必须有Activity同时满足 上面的配置中有多余的category和data限制存在，所以并不匹配，不会在Home Launcher出现，但是可以使用URL Scheme来启动。这样就可以将一组APP设置一个统一的入口，然后根据实际需要在调用不同子APP，即所谓的APP业务组件化。 123Uri data = Uri.parse(&quot;urlschemel://auth_activity&quot;); Intent intent = new Intent(Intent.ACTION_MAIN,data); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binder机制]]></title>
    <url>%2F2018%2F09%2F05%2FBinder%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Linux内核的基础知识进程隔离、虚拟地址空间 进程隔离：是为保护操作系统中进程互不干扰而设计的一组不同硬件和软件的技术。这个技术是为了避免进程A写入进程B的情况发生。 进程的隔离实现，使用了虚拟地址空间。进程A的虚拟地址和进程B的虚拟地址不同，这样就防止进程A将数据信息写入进程B。 系统调用 计算机系统的各种硬件资源是有限的，在现代多任务操作系统上同时运行的多个进程都需要访问这些资源，为了更好的管理这些资源进程是不允许直接操作的，所有对这些资源的访问都必须有操作系统控制。也就是说操作系统是使用这些资源的唯一入口，而这个入口就是操作系统提供的系统调用（System Call）。在linux中系统调用是用户空间访问内核的唯一手段，除异常和陷入外，他们是内核唯一的合法入口。 Binder驱动 在Adroid系统中，Binder驱动运行在内核空间当中，负责各个用户进程通过Bindert通信内核进行交互一个模块。是系统和设备通信特殊程序，也是一种软件相当于硬件的接口，操作系统可以通过该软件控制硬件，这就是Binder驱动。 Binder通讯机制为什么使用Binder Android使用Linx内核拥有者许多跨进程通信。 性能，Binder更加高效。 安全，Binder对通信双方的身份严格的校验。 Binder通信模型 整个通信步骤如下： SM建立(建立通信录)；首先有一个进程向驱动提出申请为SM；驱动同意之后，SM进程负责管理Service（注意这里是Service而不是Server，因为如果通信过程反过来的话，那么原来的客户端Client也会成为服务端Server）不过这时候通信录还是空的，一个号码都没有。 各个Server向SM注册(完善通信录)；每个Server端进程启动之后，向SM报告，我是zhangsan, 要找我请返回0x1234(这个地址没有实际意义，类比)；其他Server进程依次如此；这样SM就建立了一张表，对应着各个Server的名字和地址；就好比B与A见面了，说存个我的号码吧，以后找我拨打10086； Client想要与Server通信，首先询问SM；请告诉我如何联系zhangsan，SM收到后给他一个号码0x1234；Client收到之后，开心滴用这个号码拨通了Server的电话，于是就开始通信了。 这里Client与SM的通信，以及Client与Server的通信，都会经过驱动，驱动在背后默默无闻，但是做着最重要的工作。驱动是整个通信过程的核心，因此完成跨进程通信的秘密全部隐藏在驱动里面。 Binder机制跨进程原理 Server进程要向SM注册；告诉自己是谁，自己有什么能力；在这个场景就是Server告诉SM，它叫zhangsan，它有一个object对象，可以执行add 操作；于是SM建立了一张表：zhangsan这个名字对应进程Server; 然后Client向SM查询：我需要联系一个名字叫做zhangsan的进程里面的object对象；这时候关键来了：进程之间通信的数据都会经过运行在内核空间里面的驱动，驱动在数据流过的时候做了一点手脚，它并不会给Client进程返回一个真正的object对象，而是返回一个看起来跟object一模一样的代理对象objectProxy，这个objectProxy也有一个add方法，但是这个add方法没有Server进程里面object对象的add方法那个能力；objectProxy的add只是一个傀儡，它唯一做的事情就是把参数包装然后交给驱动。 但是Client进程并不知道驱动返回给它的对象动过手脚，毕竟伪装的太像了，如假包换。Client开开心心地拿着objectProxy对象然后调用add方法；我们说过，这个add什么也不做，直接把参数做一些包装然后直接转发给Binder驱动。 驱动收到这个消息，发现是这个objectProxy，一查表就明白了：我之前用objectProxy替换了object发送给Client了，它真正应该要访问的是object对象的add方法；于是Binder驱动通知Server进程，调用你的object对象的add方法，然后把结果发给我，Sever进程收到这个消息，照做之后将结果返回驱动，驱动然后把结果返回给Client进程；于是整个过程就完成了。 由于驱动返回的objectProxy与Server进程里面原始的object是如此相似，给人感觉好像是直接把Server进程里面的对象object传递到了Client进程；因此，我们可以说Binder对象是可以进行跨进程传递的对象。 但事实上我们知道，Binder跨进程传输并不是真的把一个对象传输到了另外一个进程；传输过程好像是Binder跨进程穿越的时候，它在一个进程留下了一个真身，在另外一个进程幻化出一个影子（这个影子可以很多个）；Client进程的操作其实是对于影子的操作，影子利用Binder驱动最终让真身完成操作。 Binder是什么 Binder的设计采用了面向对象的思想，在Binder通信模型的四个角色里面；他们的代表都是“Binder”，这样，对于Binder通信的使用者而言，Server里面的Binder和Client里面的Binder没有什么不同，一个Binder对象就代表了所有，它不用关心实现的细节，甚至不用关心驱动以及SM的存在；这就是抽象。 通常意义下，Binder指的是一种通信机制；我们说AIDL使用Binder进行通信，指的就是Binder这种IPC机制。 对于Server进程来说，Binder指的是Binder本地对象 对于Client来说，Binder指的是Binder代理对象，它只是Binder本地对象的一个远程代理；对这个Binder代理对象的操作，会通过驱动最终转发到Binder本地对象上去完成；对于一个拥有Binder对象的使用者而言，它无须关心这是一个Binder代理对象还是Binder本地对象；对于代理对象的操作和对本地对象的操作对它来说没有区别。 对于传输过程而言，Binder是可以进行跨进程传递的对象；Binder驱动会对具有跨进程传递能力的对象做特殊处理：自动完成代理对象和本地对象的转换。 面向对象思想的引入将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体（本地对象）位于一个进程中，而它的引用（代理对象）却遍布于系统的各个进程之中。最诱人的是，这个引用和java里引用一样既可以是强类型，也可以是弱类型，而且可以从一个进程传给其它进程，让大家都能访问同一Server，就象将一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。形形色色的Binder对象以及星罗棋布的引用仿佛粘接各个应用程序的胶水，这也是Binder在英文里的原意。 AIDLBinder/IInterface/Binder/BinderProxy/Stub IBinder是一个接口，它代表了一种跨进程传输的能力；只要实现了这个接口，就能将这个对象进行跨进程传递；这是驱动底层支持的；在跨进程数据流经驱动的时候，驱动会识别IBinder类型的数据，从而自动完成不同进程Binder本地对象以及Binder代理对象的转换。 IBinder负责数据传输，那么client与server端的调用契约（这里不用接口避免混淆）呢？这里的IInterface代表的就是远程server对象具有什么能力。具体来说，就是aidl里面的接口。 Java层的Binder类，代表的其实就是Binder本地对象。BinderProxy类是Binder类的一个内部类，它代表远程进程的Binder对象的本地代理；这两个类都继承自IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder驱动会自动完成这两个对象的转换。 在使用AIDL的时候，编译工具会给我们生成一个Stub的静态内部类；这个类继承了Binder, 说明它是一个Binder本地对象，它实现了IInterface接口，表明它具有远程Server承诺给Client的能力；Stub是一个抽象类，具体的IInterface的相关实现需要我们手动完成，这里使用了策略模式。 AIDL过程分析现在我们通过一个AIDL的使用，分析一下整个通信过程中，各个角色到底做了什么，AIDL到底是如何完成通信的。（如果你连AIDL都不熟悉，请先查阅官方文档） 首先定一个一个简单的aidl接口： 12345// ICompute.aidlpackage com.example.test.app;interface ICompute &#123; int add(int a, int b);&#125; 然后用编译工具编译之后，可以得到对应的ICompute.java类，看看系统给我们生成的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package com.example.test.app;public interface ICompute extends android.os.IInterface &#123; /** * Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements com.example.test.app.ICompute &#123; private static final java.lang.String DESCRIPTOR = &quot;com.example.test.app.ICompute&quot;; /** * Construct the stub at attach it to the interface. */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * Cast an IBinder object into an com.example.test.app.ICompute interface, * generating a proxy if needed. */ public static com.example.test.app.ICompute asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.example.test.app.ICompute))) &#123; return ((com.example.test.app.ICompute) iin); &#125; return new com.example.test.app.ICompute.Stub.Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_add: &#123; data.enforceInterface(DESCRIPTOR); int _arg0; _arg0 = data.readInt(); int _arg1; _arg1 = data.readInt(); int _result = this.add(_arg0, _arg1); reply.writeNoException(); reply.writeInt(_result); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; private static class Proxy implements com.example.test.app.ICompute &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ @Override public int add(int a, int b) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); int _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeInt(a); _data.writeInt(b); mRemote.transact(Stub.TRANSACTION_add, _data, _reply, 0); _reply.readException(); _result = _reply.readInt(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; &#125; static final int TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); &#125; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ public int add(int a, int b) throws android.os.RemoteException;&#125; 系统帮我们生成了这个文件之后，我们只需要继承ICompute.Stub这个抽象类，实现它的方法，然后在Service 的onBind方法里面返回就实现了AIDL。这个Stub类非常重要，具体看看它做了什么。 Stub类继承自Binder，意味着这个Stub其实自己是一个Binder本地对象，然后实现了ICompute接口，ICompute本身是一个IInterface，因此他携带某种客户端需要的能力（这里是方法add)。此类有一个内部类Proxy，也就是Binder代理对象； 然后看看asInterface方法，我们在bind一个Service之后，在onServiceConnecttion的回调里面，就是通过这个方法拿到一个远程的service的，这个方法做了什么呢？ 1234567891011121314/** * Cast an IBinder object into an com.example.test.app.ICompute interface, * generating a proxy if needed. */public static com.example.test.app.ICompute asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.example.test.app.ICompute))) &#123; return ((com.example.test.app.ICompute) iin); &#125; return new com.example.test.app.ICompute.Stub.Proxy(obj);&#125; 首先看函数的参数IBinder类型的obj，这个对象是驱动给我们的，如果是Binder本地对象，那么它就是Binder类型，如果是Binder代理对象，那就是BinderProxy类型；然后，正如上面自动生成的文档所说，它会试着查找Binder本地对象，如果找到，说明Client和Server都在同一个进程，这个参数直接就是本地对象，直接强制类型转换然后返回，如果找不到，说明是远程对象（处于另外一个进程）那么就需要创建一个Binde代理对象，让这个Binder代理实现对于远程对象的访问。一般来说，如果是与一个远程Service对象进行通信，那么这里返回的一定是一个Binder代理对象，这个IBinder参数的实际上是BinderProxy; 再看看我们对于aidl的add 方法的实现；在Stub类里面，add是一个抽象方法，我们需要继承这个类并实现它；如果Client和Server在同一个进程，那么直接就是调用这个方法；那么，如果是远程调用，这中间发生了什么呢？Client是如何调用到Server的方法的？ 我们知道，对于远程方法的调用，是通过Binder代理完成的，在这个例子里面就是Proxy类；Proxy对于add方法的实现如下： 123456789101112131415161718Overridepublic int add(int a, int b) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); int _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeInt(a); _data.writeInt(b); mRemote.transact(Stub.TRANSACTION_add, _data, _reply, 0); _reply.readException(); _result = _reply.readInt(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result;&#125; 它首先用Parcel把数据序列化了，然后调用了transact方法；这个transact到底做了什么呢？这个Proxy类在asInterface方法里面被创建，前面提到过，如果是Binder代理那么说明驱动返回的IBinder实际是BinderProxy, 因此我们的Proxy类里面的mRemote实际类型应该是BinderProxy；我们看看BinderProxy的transact方法：(Binder.java的内部类) 12public native boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException; 这是一个本地方法；它的实现在native层，具体来说在frameworks/base/core/jni/android_util_Binder.cpp文件，里面进行了一系列的函数调用，调用链实在太长这里就不给出了；要知道的是它最终调用到了talkWithDriver函数；看这个函数的名字就知道，通信过程要交给驱动完成了；这个函数最后通过ioctl系统调用，Client进程陷入内核态，Client调用add方法的线程挂起等待返回；驱动完成一系列的操作之后唤醒Server进程，调用了Server进程本地对象的onTransact函数（实际上由Server端线程池完成）。我们再看Binder本地对象的onTransact方法（这里就是Stub类里面的此方法）： 123456789101112131415161718192021@Overridepublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_add: &#123; data.enforceInterface(DESCRIPTOR); int _arg0; _arg0 = data.readInt(); int _arg1; _arg1 = data.readInt(); int _result = this.add(_arg0, _arg1); reply.writeNoException(); reply.writeInt(_result); return true; &#125; &#125; return super.onTransact(code, data, reply, flags);&#125; 在Server进程里面，onTransact根据调用号（每个AIDL函数都有一个编号，在跨进程的时候，不会传递函数，而是传递编号指明调用哪个函数）调用相关函数；在这个例子里面，调用了Binder本地对象的add方法；这个方法将结果返回给驱动，驱动唤醒挂起的Client进程里面的线程并将结果返回。于是一次跨进程调用就完成了。 至此，你应该对AIDL这种通信方式里面的各个类以及各个角色有了一定的了解；它总是那么一种固定的模式：一个需要跨进程传递的对象一定继承自IBinder，如果是Binder本地对象，那么一定继承Binder实现IInterface，如果是代理对象，那么就实现了IInterface并持有了IBinder引用； Proxy与Stub不一样，虽然他们都既是Binder又是IInterface，不同的是Stub采用的是继承（is 关系），Proxy采用的是组合（has 关系）。他们均实现了所有的IInterface函数，不同的是，Stub又使用策略模式调用的是虚函数（待子类实现），而Proxy则使用组合模式。为什么Stub采用继承而Proxy采用组合？事实上，Stub本身is一个IBinder（Binder），它本身就是一个能跨越进程边界传输的对象，所以它得继承IBinder实现transact这个函数从而得到跨越进程的能力（这个能力由驱动赋予）。Proxy类使用组合，是因为他不关心自己是什么，它也不需要跨越进程传输，它只需要拥有这个能力即可，要拥有这个能力，只需要保留一个对IBinder的引用。如果把这个过程做一个类比，在封建社会，Stub好比皇帝，可以号令天下，他生而具有这个权利（不要说宣扬封建迷信。。）如果一个人也想号令天下，可以，“挟天子以令诸侯”。为什么不自己去当皇帝，其一，一般情况没必要，当了皇帝其实限制也蛮多的是不是？我现在既能掌管天下，又能不受约束（Java单继承）；其二，名不正言不顺啊，我本来特么就不是（Binder），你非要我是说不过去，搞不好还会造反。最后呢，如果想当皇帝也可以，那就是asBinder了。在Stub类里面，asBinder返回this，在Proxy里面返回的是持有的组合类IBinder的引用。 再去翻阅系统的ActivityManagerServer的源码，就知道哪一个类是什么角色了：IActivityManager是一个IInterface，它代表远程Service具有什么能力，ActivityManagerNative指的是Binder本地对象（类似AIDL工具生成的Stub类），这个类是抽象类，它的实现是ActivityManagerService；因此对于AMS的最终操作都会进入ActivityManagerService这个真正实现；同时如果仔细观察，ActivityManagerNative.java里面有一个非公开类ActivityManagerProxy, 它代表的就是Binder代理对象；是不是跟AIDL模型一模一样呢？那么ActivityManager是什么？他不过是一个管理类而已，可以看到真正的操作都是转发给ActivityManagerNative进而交给他的实现ActivityManagerService 完成的。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中的IPC机制]]></title>
    <url>%2F2018%2F09%2F05%2FAndroid%E4%B8%AD%E7%9A%84IPC%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[IPC机制 IPC机制是iInter-Process Communication的缩写，即是进程间通信。 Linux自身的IPC机制 Linux本身就包含进程间通信机制，包括管道 、信号、内存映射、消息队列、信号量、共享内存以及套接字Socket等。 管道 管道实际是用于进程间通信的一段共享内存，创建管道的进程称为管道服务器，连接到一个管道的进程为管道客户机。一个进程在向管道写入数据后，另一进程就可以从管道的另一端将其读取出来。 普通管道：有两种限制，一是半双工的通信，数据仅仅能单向流动，二是仅仅能在具有亲缘关系的进程间使用。进程的亲缘关系一般是指父子进程关系。 流管道：在普通管道的功能基础上增加了数据双向传输功能。 命名管道： 可用于具有亲缘关系进程间的通信，命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信； 缺点：速度慢，容量有限 ，普通管道只能进行父子进程通信。 信号Signal 信号是比较复杂的通信方式，用于通知接收进程有某种事情发生，除了用于进程间通信外，进程还可以发送信号给进程本身；Linux除了支持UNIX早期信号语义函数signal外，还支持语义符合POSIX.1标准的信号函数sigaction(实际上，该函数是基于BSD的，BSD即能实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数的功能); 内存影射Mapped memory 内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它； 缺点：能够非常easy控制容量，速度快，但要保持同步，比方一个进程在写的时候。还有一个进程要注意读写的问题，相当于线程中的线程安全。当然。共享内存区相同能够用作线程间通讯，只是没这个必要，线程间本来就已经共享了同一进程内的一块内存 消息队列 消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。 缺点：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题 信号量 信号量与其他进程间通信方式不大相同，它主要提供对进程间共享资源访问控制机制。相当于内存中的标志，进程可以根据它判定是否能够访问某些共享资源，同时，进程也可以修改该标志。除了用于访问控制外，还可用于进程同步。信号量有以下两种类型：二值信号量：最简单的信号量形式，信号灯的值只能取0或1，类似于互斥锁。计算信号量：信号量的值可以取任意非负值（当然受内核本身的约束）。 缺点：不能传递复杂消息，仅仅能用来同步 。 共享内存Shared memory 共享内存就是映射一段能被其它进程所訪问的内存。这段共享内存由一个进程创建。但多个进程都能够訪问。共享内存是最快的 IPC 方式，它是针对其它进程间通信方式执行效率低而专门设计的。它往往与其它通信机制。如信号量，配合使用。来实现进程间的同步和通信。使得多个进程能够訪问同一块内存空间。是最快的可用IPC形式。是针对其它通信机制执行效率较低而设计的。往往与其它通信机制，如信号量结合使用。来达到进程间的同步及相互排斥。 缺点：能够非常easy控制容量，速度快，但要保持同步，比方一个进程在写的时候。还有一个进程要注意读写的问题，相当于线程中的线程安全。当然。共享内存区相同能够用作线程间通讯，只是没这个必要，线程间本来就已经共享了同一进程内的一块内存 套接字Socket 套解口也是一种进程间通信机制，与其它通信机制不同的是。它可用于不同机器间的进程通信更为一般的进程间通信机制。可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但如今一般能够移植到其它类Unix系统上：Linux和System V的变种都支持套接字。 缺点：传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。 Linux传统IPC通信原理 概念：通常的做法是消息发送方将要发送的数据存放在内存缓存区中，通过系统调用进入内核态。然后内核程序在内核空间分配内存，开辟一块内核缓存区，调用 copyfromuser() 函数将数据从用户空间的内存缓存区拷贝到内核空间的内核缓存区中。同样的，接收方进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用 copytouser() 函数将数据从内核缓存区拷贝到接收进程的内存缓存区。这样数据发送方进程和数据接收方进程就完成了一次数据传输，我们称完成了一次进程间通信 内核空间与用户空间：现在操作系统都是采用的虚拟存储器，对于 32 位系统而言，它的寻址空间（虚拟存储空间）就是 2 的 32 次方，也就是 4GB。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也拥有访问底层硬件设备的权限。为了保护用户进程不能直接操作内核，并且保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间（User Space）和内核空间（Kernel Space）。针对 Linux 操作系统而言，将最高的 1GB 字节供内核使用，称为内核空间；较低的 3GB 字节供各进程使用，称为用户空间。 也可以说，内核空间（Kernel）是系统内核运行的空间，用户空间（User Space）是用户程序运行的空间。为了保证安全性，它们之间是隔离的。 用户态与内核态以及系统调用： 系统调用：是突破内核空间与进程空间的隔离访问内核空间的唯一方式。系统调用主要由两个函数实现，分别是将数据从用户空间拷贝到内核空间的copy_from_user()和将数据从内核空间拷贝到用户空间的copy_to_user()。 用户态：当进程在执行用户自己的代码的时候，我们称其处于用户运行态（用户态）。此时处理器在特权级最低的（3级）用户代码中运行。 内核态：当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。 图解： 问题： 性能低下，一次数据传递需要经历：内存缓存区 –&gt; 内核缓存区 –&gt; 内存缓存区，需要 2 次数据拷贝； 接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法不是浪费空间就是浪费时间。 Android的IPC机制BinderBindr相对于Linux自身IPC机制的优点 性能：只需进行一次数据拷贝，性能仅次于共享内存。并且Socket 作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。Binder 只需要一次数据拷贝，性能上仅次于共享内存。 安全性：传统的 IPC 没有任何安全措施，完全依赖上层协议来确保。首先传统的 IPC 接收方无法获得对方可靠的进程用户ID/进程ID（UID/PID），从而无法鉴别对方身份。Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。传统的 IPC 只能由用户在数据包中填入 UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标识只有由 IPC 机制在内核中添加。其次传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时 Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。 稳定性：Binder 基于 C/S 架构，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制负责，难以使用。从稳定性的角度讲，Binder 机制是优于内存共享的。 Binder跨进程通信原理 统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信。但是Binder并不是Linux系统内核的一部分，因此需要通过动态内核可加载模块机制来动态添加一个内核模块（Binder驱动）运行再内存空间，来实现用户进程间通信。 动态内核可加载模块（Loadable Kernel Module，LKM)：模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。它在运行时被链接到内核作为内核的一部分运行。 内存映射：内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间中的内存区域。 内存映射通过mmp()来实现。 Binder IPC实现原理： Binder IPC 是基于内存映射（mmap）来实现的，但是 mmap() 通常是用在有物理介质的文件系统上的。 比如进程中的用户区域是不能直接和物理设备打交道的，如果想要把磁盘上的数据读取到进程的用户区域，需要两次拷贝（磁盘–&gt;内核空间–&gt;用户空间）；通常在这种场景下 mmap() 就能发挥作用，通过在物理介质和用户空间之间建立映射，减少数据的拷贝次数，用内存读写取代I/O读写，提高文件读取效率。 而 Binder 并不存在物理介质，因此 Binder 驱动使用 mmap() 并不是为了在物理介质和用户空间之间建立映射，而是用来在内核空间创建数据接收的缓存空间。 完整的Binder IPC通信过程 首先 Binder 驱动在内核空间创建一个数据接收缓存区； 接着在内核空间开辟一块内核缓存区，建立内核缓存区和内核中数据接收缓存区之间的映射关系，以及内核中数据接收缓存区和接收进程用户空间地址的映射关系； 发送方进程通过系统调用 copyfromuser() 将数据 copy 到内核中的内核缓存区，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。 完整的Bidner IPC通信过程图 Binder通信模型 一次完整的进程间通信必然至少包含两个进程，通常我们称通信的双方分别为客户端进程（Client）和服务端进程（Server），由于进程隔离机制的存在，通信双方必然需要借助 Binder 来实现。 Binder 是基于 C/S 架构的。由一系列的组件组成，包括 Client、Server、ServiceManager、Binder 驱动。其中 Client、Server、Service Manager 运行在用户空间，Binder 驱动运行在内核空间。其中 Service Manager 和 Binder 驱动由系统提供，而 Client、Server 由应用程序来实现。Client、Server 和 ServiceManager 均是通过系统调用 open、mmap 和 ioctl 来访问设备文件 /dev/binder，从而实现与 Binder 驱动的交互来间接的实现跨进程通信。 Client、Server、ServiceManager、Binder驱动联系 这几 Client、Server、ServiceManager、Binder驱动间的联系就如同互联网中服务器（Server）、客户端（Client）、DNS域名服务器（ServiceManager）以及路由器（Binder 驱动）之前的关系。 Binder驱动 Binder 驱动就如同路由器一样，是整个通信的核心；驱动负责进程之间 Binder 通信的建立，Binder 在进程之间的传递，Binder 引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。 ServiceManager 与实名 Binder ServiceManager 与 DNS 类似，作用是将字符形式的 Binder 名字转化成 Client 中对该 Binder 的引用，使得 Client 能够通过 Binder 的名字获得对 Binder 实体的引用。 ServierManager 本身也是是一个进程，Server 是另一个进程，Server 向 ServiceManager 中注册 Binder 必然涉及到进程间通信，当前实现进程间通信时却又要用到进程间通信。 ServiceManager 和其他进程同样采用 Bidner 通信，ServiceManager 是 Server 端，有自己的 Binder 实体，其他进程都是 Client，需要通过这个 Binder 的引用来实现 Binder 的注册，查询和获取。 ServiceManager 提供的 Binder 比较特殊，它没有名字也不需要注册。当一个进程使用 BINDERSETCONTEXT_MGR 命令将自己注册成 ServiceManager 时 ，Binder 驱动会自动为它创建 Binder 实体。其次这个 Binder 实体的引用在所有 Client 中都固定为 0 而无需通过其它手段获得。也就是说，一个 Server 想要向 ServiceManager 注册自己的 Binder 就必须通过这个 0 号引用来和 ServiceManager 的 Binder 通信。类比互联网，0 号引用就好比是域名服务器的地址，你必须域名先动态或者手工配置好。这里说的 Client 是相对于 ServiceManager 而言的，一个进程或者应用程序可能是提供服务的 Server，但对于 ServiceManager 来说它仍然是个 Client。 实名Binder：注册了名字的 Binder 叫实名Binder，就像网站一样除了除了有 IP 地址以外还有自己的网址，相对于域名更加可读易记。 匿名Binder：Server端可以通过已经建立的Binder连接将新创建的Binder实体传给Client，当然这条已经建立的Binder连接必须是通过实名Binder实现。由于这个Binder没有向ServiceManage注册名字，所以是个匿名Binder。Client将会收到这个匿名Binder的引用，通过这个引用向位于Server中的实体发送请求。匿名Binder为通信双方建立一条私密通道，只要Server没有把匿名Binder发给别的进程，别的进程就无法通过穷举或猜测等任何方式获得该Binder的引用，向该Binder发送请求。 Service向ServiceManager注册Binder Server创建了Binder实体，为其取一个字符形式，可读易记的名字； Server将这个Binder连同名字以数据包的形式通过Binder驱动发送给ServiceManager，通知ServiceManager注册一个名叫张三的Binder，它位于某个Server中； 驱动为这个穿过进程边界的Binder创建位于内核中的实体节点以及ServiceManager对实体的引用，将名字及新建的引用打包传递给ServiceManager； ServiceManager收数据包后，从中取出名字和引用填入一张查找表中； Client 获得实名 Binder 的引用 Server 向 ServiceManager 中注册了 Binder 以后， Client 就能通过名字获得 Binder 的引用了。 Client 利用保留的 0 号引用向 ServiceManager 请求访问某个 Binder: 我申请访问名字叫张三的 Binder 引用。 ServiceManager 收到这个请求后从请求数据包中取出 Binder 名称，在查找表里找到对应的条目，取出对应的 Binder 引用作为回复发送给发起请求的 Client。 注意：从面向对象的角度看，Server 中的 Binder 实体现在有两个引用：一个位于 ServiceManager 中，一个位于发起请求的 Client 中。如果接下来有更多的 Client 请求该 Binder，系统中就会有更多的引用指向该 Binder ，就像 Java 中一个对象有多个引用一样。 Binder通信过程 通信过程步骤： 首先，一个进程使用 BINDERSETCONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager； Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。 Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。 通信过程图： Binder通信过程中的代理模式 跨进程通信的过程都有Binder驱动参与，在数据流经过Binder驱动的时候，驱动会对数据做一层转换。 当A进程想获取B进程中的object时，驱动不会真的把object返回给A，而是返回一个跟object看起来一模一样的代理对象objectProxy。这个 objectProxy 具有和 object 一摸一样的方法，但是这些方法并没有 B 进程中 object 对象那些方法的能力，这些方法只需要把把请求参数交给驱动即可。对于 A 进程来说和直接调用 object 中的方法是一样的。 当 Binder 驱动接收到 A 进程的消息后，发现这是个 objectProxy 就去查询自己维护的表单，一查发现这是 B 进程 object 的代理对象。于是就会去通知 B 进程调用 object 的方法，并要求 B 进程把返回结果发给自己。当驱动拿到 B 进程的返回结果后就会转发给 A 进程，一次通信就完成了。 Binder通信过程中代理模式实现图如下： Binder完整定义 从进程间通信的角度看，Binder 是一种进程间通信的机制； 从 Server 进程的角度看，Binder 指的是 Server 中的 Binder 实体对象； 从 Client 进程的角度看，Binder 指的是对 Binder 代理对象，是 Binder 实体对象的一个远程代理 从传输过程的角度看，Binder 是一个可以跨进程传输的对象；Binder 驱动会对这个跨越进程边界的对象对一点点特殊处理，自动完成代理对象和本地对象之间的转换。 手动编码实现跨进程调用各类的职责描述 IBinder : IBinder 是一个接口，代表了一种跨进程通信的能力。只要实现了这个借口，这个对象就能跨进程传输； IInterface : IInterface 代表的就是 Server 进程对象具备什么样的能力（能提供哪些方法，其实对应的就是 AIDL 文件中定义的接口）； Binder : Java 层的 Binder 类，代表的其实就是 Binder 本地对象。BinderProxy 类是 Binder 类的一个内部类，它代表远程进程的 Binder 对象的本地代理；这两个类都继承自 IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder 驱动会自动完成这两个对象的转换； Stub : AIDL 的时候，编译工具会给我们生成一个名为 Stub 的静态内部类；这个类继承了 Binder, 说明它是一个 Binder 本地对象，它实现了 IInterface 接口，表明它具有 Server 承诺给 Client 的能力；Stub 是一个抽象类，具体的 IInterface 的相关实现需要开发者自己实现。 实现过程 服务端： 定义一个 BookManager 接口，BookManager 继承自 IIterface，表明服务端需要实现的方法。 实现一个跨进程调用对象 Stub。Stub 继承 Binder, 说明它是一个 Binder 本地对象；实现 IInterface 接口，表明具有 Server 承诺给 Client 的能力；Stub 是一个抽象类，具体的 IInterface 的相关实现需要调用方自己实现。 Stub 类中的 asInterface 和 onTransact asInterface ：当 Client 端在创建和服务端的连接，调用 bindService 时需要创建一个 ServiceConnection 对象作为入参。在 ServiceConnection 的回调方法 onServiceConnected 中 会通过这个 asInterface(IBinder binder) 拿到 BookManager 对象，这个 IBinder 类型的入参 binder 是驱动传给我们的，正如代码中看到的一样，方法中会去调用 binder.queryLocalInterface() 去查找 Binder 本地对象，如果找到了就说明 Client 和 Server 在同一进程，那么这个 binder 本身就是 Binder 本地对象，可以直接使用。否则说明是 binder 是个远程对象，也就是 BinderProxy。因此需要我们创建一个代理对象 Proxy，通过这个代理对象来是实现远程访问。 onTransact：响应接收调用 Proxy代理类：代理类实现 BookManager 接口 ， Stub 类中，addBook(Book book) 是一个抽象方法，Server 端需要去实现它。 如果 Client 和 Server 在同一个进程，那么直接就是调用这个方法。 如果是远程调用，Client 想要调用 Server 的方法就需要通过 Binder 代理来完成，也就是上面的 Proxy。 在 Proxy 中的 addBook() 方法中首先通过 Parcel 将数据序列化，然后调用 remote.transact()。正如前文所述 Proxy 是在 Stub 的 asInterface 中创建，能走到创建 Proxy 这一步就说明 Proxy 构造函数的入参是 BinderProxy，即这里的 remote 是个 BinderProxy 对象。最终通过一系列的函数调用，Client 进程通过系统调用陷入内核态，Client 进程中执行 addBook() 的线程挂起等待返回；驱动完成一系列的操作之后唤醒 Server 进程，调用 Server 进程本地对象的 onTransact()。最终又走到了 Stub 中的 onTransact() 中，onTransact() 根据函数编号调用相关函数（在 Stub 类中为 BookManager 接口中的每个函数中定义了一个编号，只不过上面的源码中我们简化掉了；在跨进程调用的时候，不会传递函数而是传递编号来指明要调用哪个函数）；我们这个例子里面，调用了 Binder 本地对象的 addBook() 并将结果返回给驱动，驱动唤醒 Client 进程里刚刚挂起的线程并将结果返回。 12345678910111213141516171819202122232425262728293031public class Proxy implements BookManager &#123; ... public Proxy(IBinder remote) &#123; this.remote = remote; &#125; @Override public void addBook(Book book) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel replay = Parcel.obtain(); try &#123; data.writeInterfaceToken(DESCRIPTOR); if (book != null) &#123; data.writeInt(1); book.writeToParcel(data, 0); &#125; else &#123; data.writeInt(0); &#125; remote.transact(Stub.TRANSAVTION_addBook, data, replay, 0); replay.readException(); &#125; finally &#123; replay.recycle(); data.recycle(); &#125; &#125; ...&#125;]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[API-Guide之设备兼容性]]></title>
    <url>%2F2018%2F05%2F02%2FAPI-Guide%E4%B9%8BDevice%20compatibility%2F</url>
    <content type="text"><![CDATA[概述 Android系统运行在多种类型的设备上，包括手机、平板电脑以及电视机。作为开发者的我们应该尽量适配不同类型的设备，以挖掘潜在的用户。为了适配不同类型的设备，应用功能对于不同不用的设备或许有些不同存在一定的变化，并且对于不同的设备屏幕配置相应的界面。 为了帮助开发者适配不同的设备，Android提供了一个动态的应用程序框架。开发者可以在静态文件中提供特定于配置的应用资源，然后Android系统会根据当前的设备类型加载相应的资源。通过这种动态的框架开发者就可以仅发布单个应用程序包（APK）,便适配多种设备。 同时，开发者也可指定使用应用功能的要求，并限定那些类型的设备可以从Google Play上安装应用。 兼容性设备兼容性 只有设备能够正确运行为Android执行环境编写的应用程序，设备才能 “与Android兼容”。 Android执行环境的确切细节由Android兼容性程序定义，并且每个设备必须通过兼容性测试套件（CTS）才能被视为兼容。 应用程序兼容性 应用是否与每种潜在的设备配置兼容。由于Android在各种设备配置上运行，某些功能在所有设备上都不可用。例如，某些设备可能不包含指南针传感器。如果您的应用程序的核心功能需要使用指南针传感器，那么您的应用程序仅与包含指南针传感器的设备兼容。 应用对设备的可用性 Android系统支持调用API来获取使用系统的功能，一些功能是基于硬件的（如指南针传感器），一些是基于软件的（如应用程序小部件），另一些则依赖于系统版本。并非所有的设备都支持全部功能，因此应用需要根据所需要的功能来控制应用对设备的可用性。 为了使应用获取尽可能多的用户，开发者应该尽可能使单个APK支持所有设备配置。在大多数情况下，开发者可以通过运行时禁用可选功能并为应用程序资源提供不同配置的替代选项来实现此目的。但是在并要情况下也可根据设备特征，通过Google Play应用商店限制应用程序在设备上的可用性： 设备功能 平台版本 屏幕配置 设备功能 Android为任何可能无法在所有设备上使用的硬件或软件功能定义了功能ID，以便开发者根据功能管理应用的可用性。例如，指南针传感器的功能ID是FEATURE_SENSOR_COMPASS，应用程序小窗口功能ID是FEATURE_APP_WIDGETS如果游标，可以阻止用户在其设备未提供给定功能的情况下通过将其声明为的清单文件中的元素来安装应用。例如，如果应用在没有指南针传感器的设备上没有意义，则可根据以下清单标签声明指南针传感器：&lt;manifest ... &gt; &lt;uses-feature android：name = “android.hardware.sensor.compass” android：required = “true” /&gt; ... &lt;/ manifest&gt; Google Play商店会将您应用所需的功能与每个用户设备上提供的功能进行比较，以确定您的应用是否与每个设备兼容。如果设备未提供您的应用所需的全部功能，则用户无法安装您的应用。 但是，如果您的应用程序的主要功能不需要 设备功能，则应该将该required属性设置为&quot;false&quot;并在运行时检查设备功能。如果应用程序功能在当前设备上不可用，请适度降低相应的应用程序功能。例如，您可以通过如下方式调用来查询某个功能是否可用 hasSystemFeature()： 注意：某些系统权限隐式需要设备功能的可用性。例如，如果您的应用请求访问权限BLUETOOTH，则这隐含地要求FEATURE_BLUETOOTH设备功能。您可以禁用基于此功能的过滤功能，并通过将该required属性设置&quot;false&quot;为标签，使应用可供没有蓝牙的设备使用. 平台版本 不同的设备可能会运行不同版本的Android平台，例如Android 4.0或Android 4.4。每个连续的平台版本通常会添加新版本中不可用的新API。为了指示哪些API可用，每个平台版本指定一个API级别。例如，Android 1.0是API级别1，Android 4.4是API级别19。 API级别允许使用清单标记及其minSdkVersion属性来声明应用程序兼容的最低版本。例如，日历提供程序API已添加到Android 4.0（API级别14）中。如果应用无法在没有这些API的情况下运行，您应该将API级别14声明为应用的最低支持版本。 该minSdkVersion属性声明了您的应用程序兼容的最低版本，并且该targetSdkVersion属性声明了对应用程序进行了优化的最高版本。但是，请注意元素中的属性被build.gradle文件中的相应属性覆盖。因此，如果使用Android Studio，则必须在其中指定值minSdkVersion和 targetSdkVersion值： 123456789ndroid &#123; defaultConfig &#123; applicationId&apos;com.example.myapp &apos; //定义运行应用程序所需的最低API级别。 minSdkVersion 15 //指定用于测试应用程序的API级别。 targetSdkVersion 26 ... &#125;&#125; Android的每个后续版本都提供了使用以前平台版本的API构建的应用程序的兼容性，因此，在使用记录的Android API时，应用程序应始终与未来版本的Android兼容。 注意： 该targetSdkVersion属性不会阻止您的应用程序安装在高于指定值的平台版本上，但它很重要，因为它向系统指示您的应用程序是否应继承新版本中的行为更改。如果没有更新 targetSdkVersion到最新版本，则系统会假定您的应用在最新版本上运行时需要一些向后兼容的行为。例如，在Android 4.4的行为更改中，使用AlarmManagerAPI 创建的警报现在默认为不精确，因此系统可以批量应用警报并保留系统电源，但如果您的目标API级别保持系统以前的API行为低于“19”。 屏幕配置 Android可在各种尺寸的设备上运行，从手机到平板电脑和电视。为了按照屏幕类型对设备进行分类，Android为每个设备定义了两个特征：屏幕大小（屏幕的物理大小）和屏幕密度（屏幕上像素的物理密度，称为DPI）。为了简化不同的配置，Android将这些变体概括为多个组，使他们更容易定位： 四种广义尺寸：小，正常，大和xlarge。 还有几种广义密度：mdpi（中等），hdpi（高），xhdpi（超高），xxhdpi（超高）以及其他。 默认情况下，应用程序与所有屏幕尺寸和密度兼容，因为系统会根据每个屏幕的需要对UI布局和图像资源进行适当调整。但是，应该通过针对不同的屏幕尺寸添加专门的布局并优化通用屏幕密度的位图图像，优化每种屏幕配置的用户体验。 屏幕兼容性概述 Android应用可能会运行在不同屏幕尺寸和密度的设备上。Android系统对不同痛的设备提供了同意开发环境，可以处理大多数的适配，从而将应用的界面调整为适应其显示的屏幕。并且，系统提供的API可用于控制应用适用于特定的屏幕尺寸和密度，以针对不同屏幕配置优化UI设计。虽然系统会对应用根据屏幕进行缩放和大小的调整，但是开发者也需针对屏幕尺寸和密度进行优化。 屏幕支持概览术语和概念 屏幕尺寸：按照屏幕对角测量的实际物理尺寸，通常Android将所有屏幕尺寸分为四种通用尺寸：小、正常、大和超大。 屏幕密度：屏幕物理区域中的像素密度；通常称为dpi(每英寸点数)。通常Android 将所有屏幕密度分组为六种通用密度： 低、中、高、超高、超超高和超超超高。 方向：从用户视角看屏幕方向，即横屏还是竖屏，分把表示屏幕的丛横比是宽还是高。注意，不同的设备默认以不同的方向操作，而且方向在运行时还可能回随着用户旋转设备而改变。 分辨率：屏幕上物理像素的总和。添加对多种屏幕的支持时， 应用不会直接使用分辨率；而只应关注通用尺寸和密度组指定的屏幕 尺寸及密度。 密度无关像素（dp）：在定义UI布局时应使用的虚拟像素单位，用于以密度无关方式表示布局维度或位置。密度无关像素等于160dpi屏幕上的一个物理像素，这是系统为“中”密度屏幕假设的基线密度。在运行时，系统更加使用中屏幕的密度按需以透明方式处理dp单位的任何缩放。dp单位转为屏幕像素的公式为：px = dp * (dpi/160)。在定义应用的 UI 时应始终使用 dp 单位 ，以确保在不同密度的屏幕上正常显示 UI。 支持的屏幕范围 Android 将实际屏幕尺寸和密度的范围 分为： 尺寸：小、正常、大和超大。 密度： ldpi（低）~120dpi mdpi（中）~160dpi hdpi（高）~240dpi xhdpi（超高）~320dpi xxhddpi（超超高）~480dpi xxxhdpi（超超超高）~640dpi 每种通用的屏幕尺寸都关联了系统定义的最低 分辨率。这些最小尺寸以“dp”单位表示 — 在定义布局时应使用相同的单位 — 这样系统无需担心屏幕密度的变化。 超大屏幕至少为 960dp x 720dp 大屏幕至少为 640dp x 480dp 正常屏幕至少为 470dp x 320dp 小屏幕至少为 426dp x 320dp 要针对不同的屏幕尺寸和密度优化应用的 UI，可为任何通用的尺寸和密度提供 备用资源。 通常，应为某些不同的屏幕尺寸提供替代布局，为不同的屏幕密度提供替代位图图像。 在运行时，系统会根据当前设备屏幕的通用 尺寸或密度对应用使用适当的资源。 但是无需为所有屏幕尺寸和 密度的组合提供备用资源。 系统提供强大的兼容性功能，可处理在任何设备屏幕上 渲染应用的大多数工作，前提是您已经使用 可以适当调整大小的技术实现 UI。 密度独立性 应用显示在密度不同的屏幕上时，如果它保持用户界面元素的物理尺寸（从 用户的视角），便可实现“密度独立性” 。保持密度独立性很重要，因为如果没有此功能，UI 元素（例如 按钮）在低密度屏幕上看起来较大，在高密度屏幕上看起来较小。这些 密度相关的大小变化可能给应用布局和易用性带来问题。图 2 和 3 分别显示了应用不提供密度独立性和 提供密度独立性时的差异。 Android 系统可帮助您的应用以两种方式实现密度独立性： 系统根据当前屏幕密度扩展 dp 单位数 系统在必要时可根据当前屏幕 密度将可绘制对象资源扩展到适当的大小。 文本视图和位图可绘制对象具有以像素（px 单位）指定的尺寸，因此视图的物理尺寸在低密度屏幕上更大，在高密度 屏幕上更小。这是因为，虽然实际屏幕尺寸可能相同，但高密度屏幕 的每英寸像素更多（同样多的像素在一个更小的区域内）。布局 尺寸以密度独立的像素（dp 单位）指定。由于 密度独立像素的基线是中密度屏幕，因此具有中密度屏幕的设备看起来 与图低密度屏幕上一样。但对于低密度和高密度屏幕，系统 将分别增加和减少密度独立像素值，以适应 屏幕。 大多数情况下，确保应用中的屏幕独立性很简单，只需以适当的密度独立像素（dp 单位）或 &quot;wrap_content&quot; 指定所有 布局尺寸值。系统然后根据适用于当前屏幕密度的缩放比例适当地缩放位图可绘制对象，以 适当的大小显示。 但位图缩放可能导致模糊或像素化位图。为避免这些伪影，应为 不同的密度提供替代的位图资源。例如，应为高密度 屏幕提供分辨率较高的位图，然后系统对中密度 屏幕将使用这些位图，而无需调整位图大小。 支持多种密度概述 Android 支持多种屏幕的基础是它能够管理针对当前屏幕配置 以适当方式渲染应用的布局和位图 可绘制对象。系统可处理大多数工作，通过适当地 缩放布局以适应屏幕尺寸/密度和根据屏幕密度缩放位图可绘制对象 ，在每种屏幕配置中渲染您的应用。 但是为了更适当的处理不同屏幕配置，还应该： 在清单文件中显示声明你的应用支持哪些屏幕尺寸，要声明应用支持的屏幕尺寸，应在清单文件中包含元素。 为不同屏幕尺寸提供不同的布局，可用于提供尺寸特定资源的配置限定符包括 small、normal、large 和 xlarge。例如，超大屏幕的布局应使用 layout-xlarge/。 从 Android 3.2（API 级别 13）开始，以上尺寸组已弃用，您 应改为使用 sw&lt;N&gt;dp 配置限定符来定义布局资源 可用的最小宽度。例如，如果多窗格平板电脑布局 需要至少 600dp 的屏幕宽度，应将其放在 layout-sw600dp/ 中 。 为不同屏幕密度提供不同的位图可绘制对象 ，Android 会缩放位图可绘制对象（.png、.jpg 和 .gif 文件）和九宫格可绘制对象（.9.png 文件），使它们以适当的 物理尺寸显示在每部设备上。 例如，如果您的应用只为 基线中密度屏幕 (mdpi) 提供位图可绘制对象，则在高密度 屏幕上会增大位图，在低密度屏幕上会缩小位图。这种缩放可能在 位图中造成伪影。为确保位图的最佳显示效果，应针对 不同屏幕密度加入不同分辨率的替代版本。 注意：将您的所有启动器图标放在 res/mipmap-[density]/ 文件夹中，而非 res/drawable-[density]/ 文件夹中。无论安装应用的设备屏幕分辨率如何，Android 系统都会将资源保留在这些密度特定的文件夹中，例如 mipmap-xxxhdpi。此 行为可让启动器应用为您的应用选择要显示在主 屏幕上的最佳分辨率图标。 系统对应用适配的方法 系统使用适当的备用资源：根据当前屏幕的尺寸和密度，系统将使用您的应用中提供的任何尺寸和 密度特定资源。例如，如果设备有 高密度屏幕，并且应用请求可绘制对象资源，系统将查找 与设备配置最匹配的可绘制对象资源目录。根据可用的其他 备用资源，包含 hdpi 限定符（例如 drawable-hdpi/）的资源目录可能是最佳匹配项，因此系统将使用此 目录中的可绘制对象资源。 没有匹配的资源，系统将使用默认资源：并按需要向上 或向下扩展，以匹配当前的屏幕尺寸和密度。 “默认”资源是指未标记配置限定符的资源。例如，drawable/ 中的资源是默认可绘制资源。 系统假设默认资源设计用于基线屏幕尺寸和密度，即 正常屏幕尺寸和中密度。 因此，系统对于高密度屏幕向上扩展默认密度 资源，对于低密度屏幕向下扩展。当系统查找密度特定的资源但在 密度特定目录中未找到时，不一定会使用默认资源。系统在缩放时可能 改用其他密度特定资源提供更好的 效果。例如，查找低密度资源但该资源不可用时， 系统会缩小资源的高密度版本，因为 系统可轻松以 0.5 为系数将高密度资源缩小至低密度资源，与以 0.75 为系数 缩小中密度资源相比，伪影更少。 ####使用配置限定符 配置限定符使用方式 在项目的 res/目录中新建一个目录，并使用以下 格式命名： &lt;resources_name&gt;-&lt;qualifier&gt; &lt;resources_name&gt; 是标准资源名称（例如 drawable 或 layout）。 &lt;qualifier&gt; 是下表 1 中的配置限定符，用于指定 要使用这些资源的屏幕配置（例如 hdpi 或 xlarge）。可以一次使用多个 &lt;qualifier&gt; — 只需使用短划线分隔每个 限定符。 将适当的配置特定资源保存在此新目录下。这些资源 文件的名称必须与默认资源文件完全一样。 配置限定符表 | 限定符 | 说明 | || —————– | ———————————————————— | —- || small | 适用于小尺寸屏幕的资源。 | || normal | 适用于正常尺寸屏幕的资源。（这是基线尺寸。） | || large | 适用于大尺寸屏幕的资源。 | || xlarge | 适用于超大尺寸屏幕的资源。 | || ldpi | 适用于低密度 (ldpi) 屏幕 (~120dpi) 的资源。 | || mdpi | 适用于中密度 (mdpi) 屏幕 (~160dpi) 的资源。（这是基线 密度。） | || hdpi | 适用于高密度 (hdpi) 屏幕 (~240dpi) 的资源。 | || xhdpi | 适用于超高密度 (xhdpi) 屏幕 (~320dpi) 的资源。 | || xxhdpi | 适用于超超高密度 (xxhdpi) 屏幕 (~480dpi) 的资源。 | || xxxhdpi | 适用于超超超高密度 (xxxhdpi) 屏幕 (~640dpi) 的资源。此限定符仅适用于 启动器图标，请参阅上面的注。 | || nodpi | 适用于所有密度的资源。这些是密度独立的资源。不管当前屏幕的密度如何，系统都不会 缩放以此限定符标记的资源。 | || tvdpi | 适用于密度介于 mdpi 和 hdpi 之间屏幕（约为 213dpi）的资源。它并不是 “主要”密度组，主要用于电视，而大多数应用都不 需要它 — 对于大多数应用而言，提供 mdpi 和 hdpi 资源便已足够，系统将根据需要对其进行 缩放。如果发现必须提供 tvdpi 资源，应以 1.33*mdpi 的系数 调整其大小。例如，mdpi 屏幕的 100px x 100px 图像应该相当于 tvdpi 的 133px x 133px。 | || land | 适用于横屏（长宽比）的资源。 | || port | 适用于竖屏（高宽比）的资源。 | || long 纵横比 | 适用于纵横比明显高于或宽于（分别在竖屏 或横屏时）基线屏幕配置的屏幕的资源。 | || notlong | 适用于使用纵横比类似于基线屏幕 配置的屏幕的资源。 | | 设计替代布局和可绘制对象 替代布局 在小屏幕上测试时，可能会发现您的布局不太适合 屏幕。例如，小屏幕设备的屏幕宽度可能无法容纳一排 按钮。在此情况下，您应该为小屏幕提供调整 按钮大小或位置的替代布局。 在超大屏幕上测试时，可能会发现您的布局无法 有效地利用大屏幕，并且明显拉伸填满屏幕。 在此情况下，应该为超大屏幕提供替代布局，以提供 针对大屏幕（例如平板电脑）优化、重新设计的 UI。 虽然应用不使用替代布局也能在大屏幕上正常运行，但 必须让用户感觉您的应用看起来像是专为其设备而设计。如果 UI 明显拉伸，用户很可能对 应用体验不满意。 对比横屏测试和竖屏测试时 可能会发现，竖屏时置于底部的 UI 在横屏时应位于屏幕右侧。 应确保布局 适应小屏幕（让用户能实际使用您的应用） 已针对大屏幕优化，可以利用其他屏幕空间 已同时针对横屏和竖屏方向优化 替代可绘制对象 基本上每个应用都应该具有不同密度的替代可绘制对象 资源，因为基本上每个应用都有启动器图标，而且该图标应该在 所有屏幕密度中看起来都很好。同样，如果您的应用中包含其他位图可绘制对象（例如 应用中的菜单图标或其他图形），则应该为不同密度提供替代版本或 每种密度一个版本。 要为不同的密度创建替代位图可绘制对象，应遵循六种通用密度之间的 3:4:6:8:12:16 缩放]]></content>
      <categories>
        <category>guide</category>
      </categories>
      <tags>
        <tag>guide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[API Guide之App Resources]]></title>
    <url>%2F2018%2F03%2F20%2FAPI-Guide%E4%B9%8BApp-Resources%2F</url>
    <content type="text"><![CDATA[Providing Resources提供资源 App应该始终外部化应用资源，如图像和代码中的字符串资源，这样有利于单独维护这些资源。并且应该将资源分组到专门命名的资源目录中，以便为特定的设备提供备用资源。在运行时，Android 会根据当前配置使用适当的资源。例如，您可能需要根据屏幕尺寸提供不同的 UI 布局，或者根据语言设置提供不同的字符串。 资源类型目录 项目 res/ 目录内支持的资源目录（表1）。 目录 资源类型 animator/ 用于定义属性动画的 XML 文件。 anim/ 定义渐变动画的 XML 文件。（属性动画也可以保存在此目录中，但是为了区分这两种类型，属性动画首选 animator/ 目录。） color/ 用于定义颜色状态列表的 XML 文件。请参阅颜色状态列表资源 drawable/ 位图文件（.png、.9.png、.jpg、.gif）或编译为以下可绘制对象资源子类型的 XML 文件：位图文件九宫格（可调整大小的位图）状态列表形状动画可绘制对象其他可绘制对象请参阅 可绘制对象资源。 mipmap/ 适用于不同启动器图标密度的可绘制对象文件。如需了解有关使用 mipmap/ 文件夹管理启动器图标的详细信息，请参阅管理项目概览。 layout/ 用于定义用户界面布局的 XML 文件。 请参阅布局资源。 menu/ 用于定义应用菜单（如选项菜单、上下文菜单或子菜单）的 XML 文件。请参阅菜单资源。 raw/ 要以原始形式保存的任意文件。要使用原始 InputStream 打开这些资源，请使用资源 ID（即 R.raw.*filename*）调用 Resources.openRawResource()。但是，如需访问原始文件名和文件层次结构，则可以考虑将某些资源保存在 assets/ 目录下（而不是 res/raw/）。assets/ 中的文件没有资源 ID，因此您只能使用 AssetManager 读取这些文件。 values/ 包含字符串、整型数和颜色等简单值的 XML 文件。其他 res/ 子目录中的 XML 资源文件是根据 XML 文件名定义单个资源，而 values/ 目录中的文件可描述多个资源。对于此目录中的文件，&lt;resources&gt; 元素的每个子元素均定义一个资源。例如，&lt;string&gt; 元素创建 R.string 资源，&lt;color&gt; 元素创建 R.color 资源。由于每个资源均用其自己的 XML 元素定义，因此您可以根据自己的需要命名文件，并将不同的资源类型放在一个文件中。但是，为了清晰起见，您可能需要将独特的资源类型放在不同的文件中。 例如，对于可在此目录中创建的资源，下面给出了相应的文件名约定：arrays.xml，用于资源数组（类型化数组）。colors.xml：颜色值。dimens.xml：尺寸值。strings.xml：字符串值。styles.xml：样式。请参阅字符串资源、样式资源和更多资源类型。 xml/ 可以在运行时通过调用 Resources.getXML() 读取的任意 XML 文件。各种 XML 配置文件（如可搜索配置）都必须保存在此处。 提供备用资源 几乎每个应用都应提供备用资源以支持特定的设备配置。 为一组资源指定特定于配置的备用资源： 在res/中创建一个以&lt;resources_name&gt;-&lt;config_qualifier&gt;形式命名的新目录。 &lt;resources_name&gt; 是相应默认资源的目录名称（如表 1 中所定义）。 是指定要使用这些资源的各个配置的名称（如表 2 中所定义）。 您可以追加多个 。以短划线将其分隔。 注意：追加多个限定符时，必须按照表 2 中列出的相同顺序放置它们。如果限定符的顺序错误，则该资源将被忽略。 将相应的备用资源保存在此新目录下。这些资源文件的名称必须与默认资源文件完全一样。 例如，以下是一些默认资源和备用资源： 1234567res/ drawable/ icon.png background.png drawable-hdpi/ icon.png background.png hdpi 限定符表示该目录中的资源适用于屏幕密度较高的设备。其中每个可绘制对象目录中的图像已针对特定的屏幕密度调整大小，但是文件名完全相同。 这样一来，用于引用 icon.png 或 background.png 图像的资源 ID 始终相同，但是 Android 会通过将设备配置信息与资源目录名称中的限定符进行比较，选择最符合当前设备的各个资源版本。 Android 支持若干配置限定符，您可以通过使用短划线分隔每个限定符，向一个目录名称添加多个限定符。表 2 按优先顺序列出了有效的配置限定符；如果对资源目录使用多个限定符，则必须按照表中列出的顺序将它们添加到目录名称。 配置限定符名称(表2) 配置 限定符值 说明 MCC 和 MNC 示例：mcc310`mcc310-mnc004mcc208-mnc00`等等 移动国家代码 (MCC)，（可选）后跟设备 SIM 卡中的移动网络代码 (MNC)。例如，mcc310 是指美国的任一运营商，mcc310-mnc004 是指美国的 Verizon 公司，mcc208-mnc00 是指法国的 Orange 公司。如果设备使用无线电连接（GSM 手机），则 MCC 和 MNC 值来自 SIM 卡。也可以单独使用 MCC（例如，将国家/地区特定的合法资源包括在应用中）。如果只需根据语言指定，则改用“语言和区域”限定符（稍后进行介绍）。 如果决定使用 MCC 和 MNC 限定符，请谨慎执行此操作并测试限定符是否按预期工作。另请参阅配置字段 mcc 和 mnc，这两个字段分别表示当前的移动国家代码和移动网络代码。 语言和区域 示例：en`fren-rUS`等 语言通过由两个字母组成的 ISO 639-1 语言代码定义，可以选择后跟两个字母组成的 ISO 3166-1-alpha-2 区域码（前带小写字母“r”）。这些代码不区分大小写；r 前缀用于区分区域码。 不能单独指定区域。如果用户更改系统设置中的语言，它有可能在应用生命周期中发生改变。 如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。有关针对其他语言本地化应用的完整指南，请参阅本地化。另请参阅 locale 配置字段，该字段表示当前的语言区域。 布局方向 ldrtl`ldltr` 应用的布局方向。ldrtl 是指“布局方向从右到左”。ldltr 是指“布局方向从左到右”，这是默认的隐式值。它适用于布局、图片或值等任何资源。例如，若要针对阿拉伯语提供某种特定布局，并针对任何其他“从右到左”语言（如波斯语或希伯来语）提供某种通用布局，则可编码如下：res/ layout/ main.xml (Default layout) layout-ar/ main.xml (Specific layout for Arabic) layout-ldrtl/ main.xml (Any &quot;right-to-left&quot; language, except for Arabic, because the &quot;ar&quot; language qualifier has a higher precedence.)注：要为应用启用从右到左的布局功能，必须将 supportsRtl 设置为 &quot;true&quot;，并将 targetSdkVersion 设置为 17 或更高版本。此项为 API 级别 17 中新增配置。 smallestWidth sw&lt;N&gt;dp示例：sw320dp`sw600dpsw720dp`等等 屏幕的基本尺寸，由可用屏幕区域的最小尺寸指定。 具体来说，设备的 smallestWidth 是屏幕可用高度和宽度的最小尺寸（您也可以将其视为屏幕的“最小可能宽度”）。无论屏幕的当前方向如何，您均可使用此限定符确保应用 UI 的可用宽度至少为 &lt;N&gt;dp。例如，如果布局要求屏幕区域的最小尺寸始终至少为 600dp，则可使用此限定符创建布局资源 res/layout-sw600dp/。仅当可用屏幕的最小尺寸至少为 600dp 时，系统才会使用这些资源，而不考虑 600dp 所代表的边是用户所认为的高度还是宽度。smallestWidth 是设备的固定屏幕尺寸特性；设备的 smallestWidth 不会随屏幕方向的变化而改变。设备的 smallestWidth 将屏幕装饰元素和系统 UI 考虑在内。例如，如果设备的屏幕上有一些永久性 UI 元素占据沿 smallestWidth 轴的空间，则系统会声明 smallestWidth 小于实际屏幕尺寸，因为这些屏幕像素不适用于您的 UI。 因此，使用的值应该是布局所需要的实际最小尺寸（通常，无论屏幕的当前方向如何，此值都是布局支持的“最小宽度”）。以下是一些可用于普通屏幕尺寸的值：320，适用于屏幕配置如下的设备：240x320 ldpi（QVGA 手机）320x480 mdpi（手机）480x800 hdpi（高密度手机）480，适用于 480x800 mdpi 之类的屏幕（平板电脑/手机）。600，适用于 600x1024 mdpi 之类的屏幕（7 英寸平板电脑）。720，适用于 720x1280 mdpi 之类的屏幕（10 英寸平板电脑）。应用为多个资源目录提供不同的 smallestWidth 限定符值时，系统会使用最接近（但未超出）设备 smallestWidth 的值。此项为 API 级别 13 中新增配置。另请参阅 android:requiresSmallestWidthDp 属性和 smallestScreenWidthDp 配置字段，前者声明与应用兼容的最小 smallestWidth；后者存放设备的 smallestWidth 值。如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅支持多种屏幕开发者指南。 可用宽度 w&lt;N&gt;dp示例：w720dp等 指定资源应该使用的最小可用屏幕宽度，以 dp 为单位，由 &lt;N&gt; 值定义。在横向和纵向之间切换时，为了匹配当前实际宽度，此配置值也会随之发生变化。应用为多个资源目录提供不同的此配置值时，系统会使用最接近（但未超出）设备当前屏幕宽度的值。 此处的值考虑到了屏幕装饰元素，因此如果设备显示屏的左边缘或右边缘上有一些永久性 UI 元素，考虑到这些 UI 元素，它会使用小于实际屏幕尺寸的宽度值，这样会减少应用的可用空间。此项为 API 级别 13 中新增配置。另请参阅 screenWidthDp 配置字段，该字段存放当前屏幕宽度。如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅支持多种屏幕开发者指南。 可用高度 h&lt;N&gt;dp示例：h720dp等 指定资源应该使用的最小可用屏幕高度，以“dp”为单位，由 &lt;N&gt; 值定义。 在横向和纵向之间切换时，为了匹配当前实际高度，此配置值也会随之发生变化。应用为多个资源目录提供不同的此配置值时，系统会使用最接近（但未超出）设备当前屏幕高度的值。 此处的值考虑到了屏幕装饰元素，因此如果设备显示屏的上边缘或下边缘有一些永久性 UI 元素，考虑到这些 UI 元素，同时为减少应用的可用空间，它会使用小于实际屏幕尺寸的高度值。 非固定的屏幕装饰元素（例如，全屏时可隐藏的手机状态栏）并不在考虑范围内，标题栏或操作栏等窗口装饰也不在考虑范围内，因此应用必须准备好处理稍小于其所指定值的空间。此项为 API 级别 13 中新增配置。另请参阅 screenHeightDp 配置字段，该字段存放当前屏幕宽度。如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅支持多种屏幕开发者指南。 屏幕尺寸 small`normallargexlarge` small：尺寸类似于低密度 QVGA 屏幕的屏幕。小屏幕的最小布局尺寸约为 320x426 dp 单位。例如，QVGA 低密度屏幕和 VGA 高密度屏幕。normal：尺寸类似于中等密度 HVGA 屏幕的屏幕。标准屏幕的最小布局尺寸约为 320x470 dp 单位。例如，WQVGA 低密度屏幕、HVGA 中等密度屏幕、WVGA 高密度屏幕。large：尺寸类似于中等密度 VGA 屏幕的屏幕。 大屏幕的最小布局尺寸约为 480x640 dp 单位。 例如，VGA 和 WVGA 中等密度屏幕。xlarge：明显大于传统中等密度 HVGA 屏幕的屏幕。超大屏幕的最小布局尺寸约为 720x960 dp 单位。在大多数情况下，屏幕超大的设备体积过大，不能放进口袋，最常见的是平板式设备。 API 级别 9 中的新增配置。**注：使用尺寸限定符并不表示资源仅适用于该尺寸的屏幕。 如果没有为备用资源提供最符合当前设备配置的限定符，则系统可能使用其中最匹配的资源。注意：如果所有资源均使用大于当前屏幕的尺寸限定符，则系统不*会使用这些资源，并且应用在运行时将会崩溃（例如，如果所有布局资源均用 xlarge 限定符标记，但设备是标准尺寸的屏幕）。此项为 API 级别 4 中新增配置。*如需了解详细信息，请参阅支持多种屏幕。另请参阅 screenLayout 配置字段，该字段表示屏幕是小尺寸、标准尺寸还是大尺寸。 屏幕纵横比 long`notlong` long：宽屏，如 WQVGA、WVGA、FWVGAnotlong：非宽屏，如 QVGA、HVGA 和 VGA此项为 API 级别 4 中新增配置。它完全基于屏幕的纵横比（宽屏较宽），而与屏幕方向无关。另请参阅 screenLayout 配置字段，该字段指示屏幕是否为宽屏。 圆形屏幕 round`notround` round：圆形屏幕，例如圆形可穿戴式设备notround：方形屏幕，例如手机或平板电脑此项为 API 级别 23 中新增配置。另请参阅 isScreenRound() 配置方法，其指示屏幕是否为宽屏。 屏幕方向 port`land` port：设备处于纵向（垂直）land：设备处于横向（水平）如果用户旋转屏幕，它有可能在应用生命周期中发生改变。 如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。另请参阅 orientation 配置字段，该字段指示当前的设备方向。 UI 模式 car`desktelevisionappliancewatch ` car：设备正在车载手机座上显示desk：设备正在桌面手机座上显示television：设备正在电视上显示，为用户提供“十英尺”体验，其 UI 位于远离用户的大屏幕上，主要面向方向键或其他非指针式交互appliance：设备用作不带显示屏的装置watch：设备配有显示屏，戴在手腕上此项为 API 级别 8 中新增配置，API 13 中新增电视配置，API 20 中新增手表配置。如需了解应用在设备插入手机座或从中移除时的响应方式，请阅读确定并监控插接状态和类型。如果用户将设备放入手机座中，它有可能在应用生命周期中发生改变。 可以使用 UiModeManager 启用或禁用其中某些模式。如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。 夜间模式 night`notnight` night：夜间notnight：白天此项为 API 级别 8 中新增配置。如果夜间模式停留在自动模式（默认），它有可能在应用生命周期中发生改变。在这种情况下，该模式会根据当天的时间进行调整。 可以使用 UiModeManager 启用或禁用此模式。如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。 屏幕像素密度 (dpi) ldpi…nodpi`tvdpianydpi` ldpi：低密度屏幕；约为 120dpi。mdpi：中等密度（传统 HVGA）屏幕；约为 160dpi。hdpi：高密度屏幕；约为 240dpi。xhdpi：超高密度屏幕；约为 320dpi。此项为 API 级别 8 中新增配置xxhdpi：超超高密度屏幕；约为 480dpi。此项为 API 级别 16 中新增配置xxxhdpi：超超超高密度屏幕使用（仅限启动器图标，请参阅“支持多种屏幕”中的注释）；约为 640dpi。 此项为 API 级别 18 中新增配置nodpi：它可用于您不希望缩放以匹配设备密度的位图资源。tvdpi：密度介于 mdpi 和 hdpi 之间的屏幕；约为 213dpi。它并不是“主要”密度组， 主要用于电视，而大多数应用都不需要它。对于大多数应用而言，提供 mdpi 和 hdpi 资源便已足够，系统将根据需要对其进行缩放。此项为 API 级别 13 中新增配置anydpi：此限定符适合所有屏幕密度，其优先级高于其他限定符。 这对于矢量可绘制对象很有用。 此项为 API 级别 21 中新增配置六个主要密度之间的缩放比为 3:4:6:8:12:16（忽略 tvdpi 密度）。因此，9x9 (ldpi) 位图相当于 12x12 (mdpi)、18x18 (hdpi)、24x24 (xhdpi) 位图，依此类推。如果您认为图像资源在电视或其他某些设备上呈现的效果不够好，而想尝试使用 tvdpi 资源，则缩放比例为 1.33*mdpi。例如，mdpi 屏幕的 100px x 100px 图像应该相当于 tvdpi 的133px x 133px。注：使用密度限定符并不表示资源仅适用于该密度的屏幕。 如果没有为备用资源提供最符合当前设备配置的限定符，则系统可能使用其中最匹配的资源。如需了解有关如何处理不同屏幕密度以及 Android 如何缩放位图以适应当前密度的详细信息，请参阅支持多种屏幕。 notouch`finger` notouch：设备没有触摸屏。finger：设备有一个专供用户通过手指直接与其交互的触摸屏。另请参阅 touchscreen 配置字段，该字段指示设备上的触摸屏类型。 键盘可用性 keysexposed`keyshiddenkeyssoft` keysexposed：设备具有可用的键盘。如果设备启用了软键盘（不无可能），那么即使硬键盘没有展示给用户，哪怕设备没有硬键盘，也可以使用此限定符。 如果没有提供或已经禁用软键盘，则只有在显示硬键盘时才会使用此限定符。keyshidden：设备具有可用的硬键盘，但它处于隐藏状态，且设备没有启用软键盘。keyssoft：设备已经启用软键盘（无论是否可见）。如果提供了 keysexposed 资源，但未提供 keyssoft 资源，那么只要系统已经启用软键盘，就会使用keysexposed 资源，而不考虑键盘是否可见。如果用户打开硬键盘，它有可能在应用生命周期中发生改变。 如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。另请参阅配置字段 hardKeyboardHidden 和 keyboardHidden，这两个字段分别指示硬键盘的可见性和任何一种键盘（包括软键盘）的可见性。 主要文本输入法 nokeys`qwerty12key` nokeys：设备没有用于文本输入的硬按键。qwerty：设备具有标准硬键盘（无论是否对用户可见）。12key：设备具有 12 键硬键盘（无论是否对用户可见）。另请参阅 keyboard 配置字段，该字段指示可用的主要文本输入法。 导航键可用性 navexposed`navhidden` navexposed：导航键可供用户使用。navhidden：导航键不可用（例如，位于密封盖子后面）。如果用户显示导航键，它有可能在应用生命周期中发生改变。 如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。另请参阅 navigationHidden 配置字段，该字段指示导航键是否处于隐藏状态。 主要非触摸导航方法 nonav`dpadtrackballwheel` nonav：除了使用触摸屏以外，设备没有其他导航设施。dpad：设备具有用于导航的方向键。trackball：设备具有用于导航的轨迹球。wheel：设备具有用于导航的方向盘（不常见）。另请参阅 navigation 配置字段，该字段指示可用的导航方法类型。 平台版本（API 级别） 示例：v3`v4v7`等等 设备支持的 API 级别。例如，v1 对应于 API 级别 1（带有 Android 1.0 或更高版本系统的设备），v4 对应于 API 级别 4（带有 Android 1.6 或更高版本系统的设备）。如需了解有关这些值的详细信息，请参阅 Android API 级别文档。 限定符命名规则 用配置限定符名称的规则： 可以为单组资源指定多个限定符，并使用短划线分隔。例如，drawable-en-rUS-land 适用于横排美国英语设备。 这些限定符必须遵循表 2中列出的顺序。例如： 错误：drawable-hdpi-port/ 正确：drawable-port-hdpi/ 不能嵌套备用资源目录。例如，您不能拥有 res/drawable/drawable-en/。 值不区分大小写。在处理之前，资源编译器会将目录名称转换为小写，以避免不区分大小写的文件系统出现问题。 名称中使用的任何大写字母只是为了便于认读。 对于每种限定符类型，仅支持一个值。例如，若要对西班牙语和法语使用相同的可绘制对象文件，则您肯定不能拥有名为 drawable-rES-rFR/ 的目录，而是需要两个包含相应文件的资源目录，如 drawable-rES/ 和 drawable-rFR/。然而，实际上您无需将相同的文件都复制到这两个位置。相反，您可以创建指向资源的别名。 请参阅下面的创建别名资源。 创建别名资源 如果想将某一资源用于多种设备配置（但是不想作为默认资源提供），则无需将同一资源放入多个备用资源目录中。 而是可以（在某些情况下）创建备用资源，充当保存在默认资源目录下的资源的别名。（注：并非所有资源都会提供相应机制让您创建指向其他资源的别名。 特别是，xml/ 目录中的动画资源、菜单资源、原始资源以及其他未指定资源均不提供此功能。） 例如，假设您有一个应用图标 icon.png，并且需要不同语言区域的独特版本。 但是，加拿大英语和加拿大法语这两种语言区域需要使用同一版本。 您可能会认为需要将相同的图像复制到加拿大英语和加拿大法语对应的资源目录中，但事实并非如此。 相反，可以将用于二者的图像另存为 icon_ca.png（除 icon.png 以外的任何名称），并将其放入默认 res/drawable/ 目录中。然后，在 res/drawable-en-rCA/ 和 res/drawable-fr-rCA/ 中创建 icon.xml 文件，使用 &lt;bitmap&gt; 元素引用 icon_ca.png 资源。这样，您只需存储 PNG 文件的一个版本和两个指向该版本的小型 XML 文件。（XML 文件示例如下。） 可绘制对象 要创建指向现有可绘制对象的别名，请使用 元素。例如： 123&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;bitmap xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:src=&quot;@drawable/icon_ca&quot; /&gt; 如果将此文件另存为 icon.xml（例如，在备用资源目录中，另存为 res/drawable-en-rCA/），则会编译到可作为 R.drawable.icon 引用的资源中，但实际上它是 R.drawable.icon_ca 资源（保存在 res/drawable/ 中）的别名。 布局 要创建指向现有布局的别名，请使用包装在 &lt;merge&gt; 中的 &lt;include&gt; 元素。例如： 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;merge&gt; &lt;include layout=&quot;@layout/main_ltr&quot;/&gt;&lt;/merge&gt; 如果将此文件另存为 main.xml，则会编译到可作为 R.layout.main 引用的资源中，但实际上它是 R.layout.main_ltr 资源的别名。 字符串和其他简单值 要创建指向现有字符串的别名，只需将所需字符串的资源 ID 用作新字符串的值即可。例如： 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;string name=&quot;hello&quot;&gt;Hello&lt;/string&gt; &lt;string name=&quot;hi&quot;&gt;@string/hello&lt;/string&gt;&lt;/resources&gt; 其他简单值的原理相同。 例如，颜色： 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;color name=&quot;red&quot;&gt;#f00&lt;/color&gt; &lt;color name=&quot;highlight&quot;&gt;@color/red&lt;/color&gt;&lt;/resources&gt; 利用资源提供最佳设备兼容性 要使应用支持多种设备配置，则务必为应用使用的每种资源类型提供默认资源，这一点非常重要。\ 例如，如果应用支持多种语言，请始终包含不带语言和区域限定符的 values/ 目录（用于保存字符串）。相反，如果您将所有字符串放入带有语言和区域限定符的目录中，则在语言设置不支持您的字符串的设备上运行应用时，应用将会崩溃。 但是，只要提供默认 values/ 资源，应用就会正常运行（即使用户不理解该语言，这也总比崩溃要好）。 如果根据屏幕方向提供不同的布局资源，则应选择一个方向作为默认方向。 例如，不要在 layout-land/ 和 layout-port/ 中分别提供横向和纵向的布局资源，而是保留其中之一作为默认设置，例如：layout/ 用于横向，layout-port/ 用于纵向。 提供默认资源至关重要，这不仅仅因为应用可能在超出预期的配置上运行，也因为新版 Android 有时会添加旧版本不支持的配置限定符。若要使用新的资源限定符，又希望维持对旧版 Android 的代码兼容性，则当旧版 Android 运行应用时，如果不提供默认资源，应用将会崩溃，这是因为它无法使用以新限定符命名的资源。例如，如果将 minSdkVersion 设置为 4，并使用夜间模式（night 或 notnight，API 级别 8 中新增配置）限定所有可绘制对象资源，则 API 级别 4 设备无法访问可绘制对象资源，而且会崩溃。在这种情况下，您可能希望 notnight 成为默认资源，为此，您应排除该限定符，使可绘制对象资源位于 drawable/ 或 drawable-night/ 中。 因此，为了提供最佳设备兼容性，请始终为应用正确运行所必需的资源提供默认资源。 然后，使用配置限定符为特定的设备配置创建备用资源。 这条规则有一个例外：如果应用的 minSdkVersion 为 4 或更高版本，则在提供带屏幕密度限定符的备用可绘制对象资源时，不需要默认可绘制对象资源。 即使没有默认可绘制对象资源，Android 也可以从备用屏幕密度中找到最佳匹配项并根据需要缩放位图。 但是，为了在所有类型的设备上提供最佳体验，您应该为所有三种类型的密度提供备用可绘制对象。 Android 如何查找最佳匹配资源 当请求要为其提供备用资源的资源时，Android 会根据当前的设备配置选择要在运行时使用的备用资源。为演示 Android 如何选择备用资源，假设以下可绘制对象目录分别包含相同图像的不同版本： 1234567drawable/drawable-en/drawable-fr-rCA/drawable-en-port/drawable-en-notouch-12key/drawable-port-ldpi/drawable-port-notouch-12key/ 同时，通过将设备配置与可用的备用资源进行比较，Android 从 drawable-en-port 中选择可绘制对象。假设设备配置如下： 语言区域 = en-GB 屏幕方向 = port 屏幕像素密度 = hdpi 触摸屏类型 = notouch 主要文本输入法 = 12key 系统使用以下逻辑决定要使用的资源： 淘汰与设备配置冲突的资源文件。 选择列表中（下一个）优先级最高的限定符。（先从 MCC 开始，然后下移。） 是否有资源目录包括此限定符? 若无，请返回到第 2 步，看看下一个限定符。（在该示例中，除非达到语言限定符，否则答案始终为“否”。） 若有，请继续执行第 4 步。 淘汰不含此限定符的资源目录。在该示例中，系统会淘汰所有不含语言限定符的目录。(例外：如果涉及的限定符是屏幕像素密度，则 Android 会选择最接近设备屏幕密度的选项。通常，Android 倾向于缩小大型原始图像，而不是放大小型原始图像。请参阅支持多种屏幕)。 返回并重复第 2 步、第 3 步和第 4 步，直到只剩下一个目录为止。在此示例中，屏幕方向是下一个判断是否匹配的限定符。因此，未指定屏幕方向的资源被淘汰： 尽管对所请求的每个资源均执行此程序，但是系统仍会对某些方面做进一步优化。 例如，系统一旦知道设备配置，即会淘汰可能永远无法匹配的备用资源。 比如说，如果配置语言是英语（“en”），则系统绝不会将语言限定符设置为非英语的任何资源目录包含在选中的资源池中（不过，仍会将不带语言限定符的资源目录包含在该池中）。 根据屏幕尺寸限定符选择资源时，如果没有更好的匹配资源，则系统将使用专为小于当前屏幕的屏幕而设计的资源（例如，如有必要，大尺寸屏幕将使用标准尺寸的屏幕资源）。 但是，如果唯一可用的资源大于当前屏幕，则系统不会使用这些资源，并且如果没有其他资源与设备配置匹配，应用将会崩溃（例如，如果所有布局资源均用 xlarge 限定符标记，但设备是标准尺寸的屏幕）。 注：限定符的优先顺序（表 2 中）比与设备完全匹配的限定符数量更加重要。例如，在上面的第 4 步中，列表剩下的最后选项包括三个与设备完全匹配的限定符（方向、触摸屏类型和输入法），而 drawable-en 只有一个匹配参数（语言）。但是，语言的优先顺序高于其他两个限定符，因此drawable-port-notouch-12key 被淘汰。 Accessing Resources访问资源 在应用中提供资源后（提供资源中对此做了阐述），可通过引用其资源 ID 来应用该资源。 所有资源 ID 都在您项目的 R 类中定义，后者由 aapt 工具自动生成。 编译应用时，aapt 会生成 R 类，其中包含您的 res/ 目录中所有资源的资源 ID。 每个资源类型都有对应的 R子类（例如，R.drawable 对应于所有可绘制对象资源），而该类型的每个资源都有对应的静态整型数（例如，R.drawable.icon）。这个整型数就是可用来检索资源的资源 ID。 尽管资源 ID 是在 R 类中指定的，但应该永远都不需要在其中查找资源 ID。 资源 ID 始终由以下部分组成： 资源类型：每个资源都被分到一个“类型”组中，例如 string、drawable 和 layout。 资源名称，它是不包括扩展名的文件名；或是 XML android:name 属性中的值，如果资源是简单值的话（例如字符串）。 访问资源的方法有两种： 在代码中：使用来自 R 类的某个子类的静态整型数，如：R.string.hello 在 XML 中：使用同样与您 R 类中定义的资源 ID 对应的特殊 XML 语法，如@string/hello。 ##在代码中访问资源 语法：[&lt;package_name&gt;.]R.&lt;resource_type&gt;.&lt;resource_name&gt; &lt;package_name&gt; 是资源所在包的名称（如果引用的资源来自您自己的资源包，则不需要）。 &lt;resource_type&gt; 是资源类型的 R 子类。 &lt;resource_name&gt; 是不带扩展名的资源文件名，或 XML 元素中的 android:name 属性值（如果资源是简单值） 用例：getWindow().setBackgroundDrawableResource(R.drawable.my_background_image) ; 在 XML 中访问资源 利用对现有资源的引用为某些 XML 属性和元素定义值。 语法：@[&lt;package_name&gt;:]&lt;resource_type&gt;/&lt;resource_name&gt; &lt;package_name&gt; 是资源所在包的名称（如果引用的资源来自相同的包，则不需要） &lt;resource_type&gt; 是资源类型的 R 子类 &lt;resource_name&gt; 是不带扩展名的资源文件名，或 XML 元素中的 android:name 属性值（如果资源是简单值）。 用例：在某些情况下，您必须使用资源作为 XML 中的值（例如，对小部件应用可绘制图像），但您也可以在 XML 中任何接受简单值的地方使用资源。 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;color name=&quot;opaque_red&quot;&gt;#f00&lt;/color&gt; &lt;string name=&quot;hello&quot;&gt;Hello!&lt;/string&gt;&lt;/resources&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;EditText xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:textColor=&quot;@color/opaque_red&quot; android:text=&quot;@string/hello&quot; /&gt; 引用样式属性：通过样式属性资源在当前应用的风格主题中引用某个属性的值。 通过引用样式属性，可以不采用为 UI 元素提供硬编码值这种方式，而是通过为 UI 元素设置样式，使其匹配当前风格主题提供的标准变型来定制这些元素的外观。引用样式属性的实质作用是，“在当前风格主题中使用此属性定义的样式”。要引用样式属性，名称语法几乎与普通资源格式完全相同，只不过将 at 符号 (@) 改为问号 (?)，资源类型部分为可选项。 例如： ?&lt;package_name&gt;:/&lt;resource_name&gt; 访问平台资源 Android 包含许多标准资源，例如样式、风格主题和布局。要访问这些资源，可以通过 android 包名称限定您的资源引用。例如，将 Android 提供的布局资源用于 ListAdapter 中的列表项：setListAdapter(new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, myarray)); Handing Runtime Change处理运行时变更 有些设备配置可能会在运行时发生变化（例如屏幕方向、键盘可用性及语言）。发生这种变化时，Android 会重启正在运行的 Activity（先后调用 onDestroy() 和 onCreate()）。重启行为旨在通过利用与新设备配置匹配的备用资源自动重新加载您的应用，来帮助它适应新配置。 Activity必须通过常规的Activity生命周期恢复以前的状态，在Activity生命周期中，Android 会在销毁 Activity 之前调用 onSaveInstanceState()以保存有关应用的相关状态的数据。然后可以在 onCreate() 或 onRestoreInstanceState() 期间恢复 Activity 状态。 重启应用并恢复大量数据不仅成本高昂，而且用户体验并不好，所以可以选用以下方式进行配置变更： 在配置变更期间保留对象：允许 Activity 在配置变更时重启，但是要将有状态对象传递给 Activity 的新实例。 自行处理配置变更：阻止系统在某些配置变更期间重启 Activity，但要在配置确实发生变化时接收回调，这样，就能够根据需要手动更新 Activity。 在配置变更期保留对象 如果重启 Activity 需要恢复大量数据、重新建立网络连接或执行其他密集操作，那么因配置变更而引起的完全重启可能会给用户留下应用运行缓慢的体验。并且通过onSaveInstanceState() 回调为您保存的 Bundle，可能无法完全恢复 Activity 状态，因为它并非设计用于携带大型对象(例如位图等)，而且其中数据必须先序列化，在进行反序列化，这可能会消耗大量的内存使得配置变更时运行缓慢。 在这种情况下，如果 Activity 因配置变更而重启，则可通过保留 Fragment 来减轻重新初始化 Activity 的负担。此片段可能包含要保留的有状态对象的引用。 当 Android 系统因配置变更而关闭 Activity 时，不会销毁您已标记为要保留的 Activity 的片段。 可以将此类片段添加到 Activity 以保留有状态的对象。要在运行时配置变更期间将有状态的对象保留在片段中，请执行以下操作： 扩展 Fragment 类并声明对有状态对象的引用。 在创建片段后调用 setRetainInstance(boolean)。 将片段添加到 Activity。 重启 Activity 后，使用 FragmentManager 检索片段。 代码示例 123456789101112131415161718192021public class RetainedFragment extends Fragment &#123; // data object we want to retain private MyDataObject data; // this method is only called once for this fragment @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // retain this fragment setRetainInstance(true); &#125; public void setData(MyDataObject data) &#123; this.data = data; &#125; public MyDataObject getData() &#123; return data; &#125;&#125; 然后，使用 FragmentManager 将片段添加到 Activity。在运行时配置变更期间再次启动 Activity 时，可以获得片段中的数据对象。 例如，按如下方式定义 Activity： 1234567891011121314151617181920212223242526272829303132333435public class MyActivity extends Activity &#123; private RetainedFragment dataFragment; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); // find the retained fragment on activity restarts FragmentManager fm = getFragmentManager(); dataFragment = (DataFragment) fm.findFragmentByTag(“data”); // create the fragment and data the first time if (dataFragment == null) &#123; // add the fragment dataFragment = new DataFragment(); fm.beginTransaction().add(dataFragment, “data”).commit(); // load the data from the web dataFragment.setData(loadMyData()); &#125; // the data is available in dataFragment.getData() ... &#125;// onCreate() 添加了一个片段或恢复了对它的引用。onCreate() 还将有状态的对象存储在片段实例内部。// onDestroy() 对所保留的片段实例内的有状态对象进行更新 @Override public void onDestroy() &#123; super.onDestroy(); // store the data in the fragment dataFragment.setData(collectMyLoadedData()); &#125;&#125; ​ 注意：**尽管您可以存储任何对象，但是切勿传递与 Activity 绑定的对象，例如，Drawable、Adapter、View 或其他任何与 Context 关联的对象。否则，它将泄漏原始 Activity 实例的所有视图和资源。 （泄漏资源意味着应用将继续持有这些资源，但是无法对其进行垃圾回收，因此可能会丢失大量内存。） 自行变更配置 自行处理配置变更可能导致备用资源的使用更为困难，因为系统不会为您自动应用这些资源。 只能在必须避免 Activity 因配置变更而重启这一万般无奈的情况下，才考虑采用自行处理配置变更这种方法，而且对于大多数应用并不建议使用此方法。 要声明由 Activity 处理配置变更，请在清单文件中编辑相应的元素，以包含 android:configChanges 属性以及代表要处理的配置的值。android:configChanges 属性的文档中列出了该属性的可能值（最常用的值包括 &quot;orientation&quot; 和 &quot;keyboardHidden&quot;，分别用于避免因屏幕方向和可用键盘改变而导致重启）。可以在该属性中声明多个配置值，方法是用管道 | 字符分隔这些配置值。例如： 123&lt;activity android:name=&quot;.MyActivity&quot; android:configChanges=&quot;orientation|keyboardHidden&quot; android:label=&quot;@string/app_name&quot;&gt; 当其中一个配置发生变化时，MyActivity 不会重启。相反，MyActivity 会收到对 onConfigurationChanged() 的调用。向此方法传递Configuration 对象指定新设备配置。可以通过读取 Configuration 中的字段，确定新配置，然后通过更新界面中使用的资源进行适当的更改。调用此方法时，Activity 的 Resources 对象会相应地进行更新，以根据新配置返回资源，就能够在系统不重启 Activity 的情况下轻松重置 UI 的元素。 注意：从 Android 3.2（API 级别 13）开始，当设备在纵向和横向之间切换时，“屏幕尺寸”也会发生变化。因此，在开发针对 API 级别 13 或更高版本（正如 minSdkVersion 和 targetSdkVersion 属性中所声明）的应用时，若要避免由于设备方向改变而导致运行时重启，则除了 &quot;orientation&quot; 值以外，还必须添加 &quot;screenSize&quot; 值。 即必须声明 android:configChanges=&quot;orientation|screenSize&quot;。 Configuration 对象代表所有当前配置，而不仅仅是已经变更的配置。不用关注配置具体发生了哪些变更，就可以轻松地重新分配所有资源，为正在处理的配置提供备用资源。 例如，由于 Resources 对象现已更新，因此您可以通过 setImageResource() 重置任何 ImageView，并且使用适合于新配置的资源。 注意：在声明由 Activity 处理配置变更时，应重置要为其提供备用资源的所有元素。 如果声明由 Activity 处理方向变更，而且有些图像应该在横向和纵向之间切换，则必须在 onConfigurationChanged() 期间将每个资源重新分配给每个元素。 #App Manifest File应用清单 每个应用的根目录中都必须包含一个 AndroidManifest.xml 文件（且文件名精确无误）。 清单文件向 Android 系统提供应用的必要信息，系统必须具有这些信息方可运行应用的任何代码。 清单文件作用： 为应用的 Java 软件包命名。软件包名称充当应用的唯一标识符。 描述应用的各个组件，包括构成应用的 Activity、服务、广播接收器和内容提供程序。它还为实现每个组件的类命名并发布其功能，例如它们可以处理的 Intent 消息。这些声明向 Android 系统告知有关组件以及可以启动这些组件的条件的信息。 确定托管应用组件的进程。 声明应用必须具备哪些权限才能访问 API 中受保护的部分并与其他应用交互。还声明其他应用与该应用组件交互所需具备的权限 列出 Instrumentation 类，这些类可在应用运行时提供分析和其他信息。这些声明只会在应用处于开发阶段时出现在清单中，在应用发布之前将移除。 声明应用所需的最低 Android API 级别 列出应用必须链接到的库 清单文件结构 &lt;action&gt; &lt;activity&gt; &lt;activity-alias&gt; &lt;application&gt; &lt;category&gt; &lt;data&gt; &lt;grant-uri-permission&gt; &lt;instrumentation&gt; &lt;intent-filter&gt; &lt;manifest&gt; &lt;meta-data&gt; &lt;permission&gt; &lt;permission-group&gt; &lt;permission-tree&gt; &lt;provider&gt; &lt;receiver&gt; &lt;service&gt; &lt;supports-screens&gt; &lt;uses-configuration&gt; &lt;uses-feature&gt; &lt;uses-library&gt; &lt;uses-permission&gt; &lt;uses-sdk&gt; ##文件约定 元素： 只有 &lt;manifest&gt; 和 &lt;application&gt; 元素是必需的，它们都必须存在并且只能出现一次。其他大部分元素可以出现多次或者根本不出现。但清单文件中必须至少存在其中某些元素才有用。 如果一个元素包含某些内容，也就包含其他元素。所有值均通过属性进行设置，而不是通过元素内的字符数据设置。 同一级别的元素通常不分先后顺序。例如，&lt;activity&gt;、&lt;provider&gt; 和 &lt;service&gt; 元素可以按任何顺序混合在一起。这条规则有两个主要例外： &lt;activity-alias&gt; 元素必须跟在别名所指的 &lt;activity&gt; 之后。 &lt;application&gt; 元素必须是 &lt;manifest&gt; 元素内最后一个元素。换言之，&lt;/manifest&gt; 结束标记必须紧接在 &lt;/application&gt; 结束标记后。 属性： 从某种意义上说，所有属性都是可选的。但是，必须指定某些属性，元素才可实现其目的。请使用本文档作为参考。对于真正可选的属性，它将指定默认值或声明缺乏规范时将执行何种操作。 除了根 &lt;manifest&gt; 元素的一些属性外，所有属性名称均以 android: 前缀开头。例如，android:alwaysRetainTaskState。由于该前缀是通用的，因此在按名称引用属性时，本文档通常会将其忽略。 声明类名： 许多元素对应于 Java 对象，包括应用本身的元素（&lt;application&gt; 元素）及其主要组件：Activity (&lt;activity&gt;)、服务 (&lt;service&gt;)、广播接收器 (&lt;receiver&gt;) 以及内容提供程序 (&lt;provider&gt;)。 若针对组件类（Activity、Service 和 BroadcastReceiver`ContentProvider）几乎一直采用的方式来定义子类，则该子类需通过name属性来声明。该名称必须包含完整的软件包名称。例如，Service` 子类可能会声明如下： 12345678&lt;manifest . . . &gt; &lt;application . . . &gt; &lt;service android:name=&quot;com.example.project.SecretService&quot; . . . &gt; . . . &lt;/service&gt; . . . &lt;/application&gt;&lt;/manifest&gt; 如果字符串的第一个字符是句点，则应用的软件包名称（如 &lt;manifest&gt; 元素的 package 属性所指定）将附加到该字符串。以下赋值与上述方法相同： 12345678&lt;manifest package=&quot;com.example.project&quot; . . . &gt; &lt;application . . . &gt; &lt;service android:name=&quot;.SecretService&quot; . . . &gt; . . . &lt;/service&gt; . . . &lt;/application&gt;&lt;/manifest&gt; 当启动组件时，Android 系统会创建已命名子类的实例。如果未指定子类，则会创建基类的实例。 多个值：如果可以指定多个值，则几乎总是在重复此元素，而不是列出单个元素内的多个值。 资源值：某些属性的值可以显示给用户，例如，Activity 的标签和图标。这些属性的值应该本地化，并通过资源或主题进行设置。资源值用以下格式表示：@[&lt;i&gt;package&lt;/i&gt;:]&lt;i&gt;type&lt;/i&gt;/&lt;i&gt;name&lt;/i&gt;。如果资源与应用在同一个软件包中，可以省略软件包名称。 字符串值：如果属性值为字符串，则必须使用双反斜杠 (\) 转义字符，例如，使用 \n 表示换行符或使用 \uxxxx 表示 Unicode 字符。 文件功能 Intent过滤器 应用核心组件（例如其 Activity、服务和广播接收器）由 intent 激活。Intent 是一系列用于描述所需操作的信息（Intent 对象），其中包括要执行操作的数据、应执行操作的组件类别以及其他相关说明。Android 系统会查找合适的组件来响应 intent，根据需要启动组件的新实例，并将其传递到 Intent 对象。 组件将通过 intent 过滤器公布它们可响应的 intent 类型。由于Android 系统在启动某组件之前必须了解该组件可以处理的 intent，因此 intent 过滤器在清单中被指定为 &lt;intent-filter&gt; 元素。一个组件可有任意数量的过滤器，其中每个过滤器描述一种不同的功能。 显式命名目标组件的 intent 将激活该组件，因此过滤器不起作用。不按名称指定目标的 intent 只有在能够通过组件的一个过滤器时才可激活该组件。 图标和标签 对于可以显示给用户的小图标和文本标签，大量元素具有 icon 和 label 属性。此外，对于同样可以显示在屏幕上的较长说明文本，某些元素还具有 description 属性。例如，&lt;permission&gt; 元素具有所有这三个属性。因此，当系统询问用户是否授权给请求获得权限的应用时，权限图标、权限名称以及所需信息的说明均会呈现给用户。 无论何种情况下，在包含元素中设置的图标和标签都将成为所有容器子元素的默认 icon 和 label 设置。因此，在 &lt;application&gt; 元素中设置的图标和标签是每个应用组件的默认图标和标签。同样，为组件（例如 &lt;activity&gt; 元素）设置的图标和标签是组件每个 &lt;intent-filter&gt; 元素的默认设置。如果 &lt;application&gt; 元素设置标签，但是 Activity 及其 intent 过滤器不执行此操作，则应用标签将被视为 Activity 和 intent 过滤器的标签。 在实现过滤器公布的功能时，只要向用户呈现组件，系统便会使用为 intent 过滤器设置的图标和标签表示该组件。例如，具有 android.intent.action.MAIN 和 android.intent.category.LAUNCHER 设置的过滤器将 Activity 公布为可启动应用的功能，即，公布为应显示在应用启动器中的功能。在过滤器中设置的图标和标签显示在启动器中。 权限 权限是一种限制，用于限制对部分代码或设备上数据的访问。施加限制是为了保护可能被误用以致破坏或损害用户体验的关键数据和代码。每种权限均由一个唯一的标签标识。标签通常指示受限制的操作。以下是 Android 定义的一些权限： android.permission.CALL_EMERGENCY_NUMBERS android.permission.READ_OWNER_DATA android.permission.SET_WALLPAPER android.permission.DEVICE_POWER 如果应用需要访问受权限保护的功能，则必须在清单中使用 &lt;uses-permission&gt; 元素声明应用需要该权限。将应用安装到设备上之后，安装程序会通过检查签署应用证书的颁发机构并（在某些情况下）询问用户，确定是否授予请求的权限。如果授予权限，则应用能够使用受保护的功能。否则，其访问这些功能的尝试将会失败，并且不会向用户发送任何通知。 应用也可以使用权限保护自己的组件。它可以采用由 Android 定义（如 android.Manifest.permission 中所列）或由其他应用声明的任何权限。它也可以定义自己的权限。 ​ 库 每个应用均链接到默认的 Android 库，该库中包括用于开发应用（以及通用类，如 Activity、服务、intent、视图、按钮、应用、ContentProvider）的基本软件包。 某些软件包驻留在自己的库中。如果应用使用来自其中任一软件包的代码，则必须明确要求其链接到这些软件包。清单必须包含单独的 &lt;uses-library&gt; 元素来命名其中每个库。库名称可在软件包的文档中找到。 App Permissions应用权限 为了维护系统和用户的安全，Android需要应用程序在使用特定系统数据和功能之前声明所需的权限。根据区域的敏感程度，系统可能会自动授予权限，或者可能会要求用户批准该请求。 权限概述 权限需要许可的目的是保护Android用户的隐私。 Android应用程序必须请求访问敏感用户数据（如联系人和短信）以及某些系统功能（如相机和互联网）的权限。根据功能的不同，系统可能会自动授予权限，或者可能会提示用户批准请求。这里介绍的内容包括：如何向用户显示权限，安装时间和运行时权限请求之间的区别，权限的执行方式以及权限和权限组的权限类型。 权限许可 应用必须在清单文件中使用&lt;uses-prmission&gt;标签声明所需要的权限，若应用在其清单中列出了正常权限（即，对用户的隐私或设备操作不构成风险的权限），系统会自动将这些权限授予给应用。但是若应用在其清单中列出了危险权限（即可能影响用户隐私或设备正常运行的权限），如SEND_SMS权限，则用户必须明确同意授予这些权限。 危险权限获取 运行时请求授予危险权限（Android6.0及以上）： 如果设备运行的是Android 6.0（API级别23）或更高版本，并且该应用的targetSdkVersion为23或更高，则安装时用户不会收到任何应用权限的通知。应用程序必须要求用户在运行时授予危险权限。当应用程序请求权限时，用户会看到一个系统对话框，告诉用户您的应用尝试访问哪个权限组。该对话框包含拒绝和允许按钮。 如果用户拒绝权限请求，则在应用下次请求权限时，该对话框将包含一个复选框，该复选框在选中后表示用户不会再次被要求提供权限。如果用户选中永不再问框并点击拒绝，如果稍后尝试请求相同的权限，则系统将不再提示用户。 即使用户向应用程序授予您所请求的权限，但是用户还可以选择在系统设置中逐个启用和禁用权限，因此还是应该始终在运行时检查并请求权限以防止运行时错误（SecurityException）。 安装时获取权限（Android5.1.1及以下） 如果设备运行Android 5.1.1（API级别22）或更低，或者应用程序的targetSdkVersion为22或更低，则系统会自动要求用户在安装时为应用授予所有危险权限。 在安装时用户如果拒绝授予这些危险权限那么将无法安装应用，如果应用程序更新包含对额外权限的需求，则会在更新应用程序之前提示用户接受这些新权限。 硬件权限 访问某些硬件功能（例如蓝牙或相机）需要应用程序许可。但并非所有的Android设备都具备这些硬件功能。因此，如果应用请求CAMERA权限，则还必须在清单中包含标记以声明该功能是否实际需要。 1&lt;uses-feature android:name=&quot;android.hardware.camera&quot; android:required=&quot;false&quot; /&gt; 如果您为该功能声明了android：required =“false”，则Google Play允许应用安装在没有此功能的设备上。然后，必须通过调用PackageManager.hasSystemFeature（）来检查当前设备是否在运行时具有该功能，并在不可用时正常禁用该功能。 如果您提供标记，那么当Google Play发现应用请求相应的权限时，它会假定应用需要此功能。因此，它会在没有此功能的设备上过滤您的应用，就像您在标记中声明了android：required =“true”一样。 声明权限 权限不仅用于请求系统功能。应用程序提供的服务可以执行自定义权限，以限定可使用它们的对象。 Activity权限声明：在应用清单文件标签中使用android：permission权限属性，限定可以启动该Activity的Activity。在Context.startActivity()和Activity.startActivityForResult()中检查权限。如果调用者没有所需的权限，则会在调用时调抛出SecurityException； Service权限声明：在应用清单文件标签中使用android：permission权限属性，限定可以启动或绑定到关联的Service的对象。在Context.startService()，Context.stopService()和Context.bindService()中检查权限。如果调用者没有所需的权限，则会在调用时调抛出SecurityException； Braodcast权限声明： 在应用清单文件标签中使用android：permission权限属性，限定可以将广播发送到关联的BroadcastReceiver的对象。在Context.sendBroadcast()返回后检查权限，因为系统试图将提交的广播传送给指定的接收者。因此，权限不足导致的调用失败不会导致异常并抛回给调用者。 以同样的方式，可以向Context.registerReceiver()提供权限，以限制向以代码注册的接收者进行广播的广播。换句话说，当调用Context.sendBroadcast（）可以使用权限来限制哪些广播接收器可以接收广播。在接收者和广播者都需要获得权限时，必须通过权限检查才能将意图传递到关联的目标。 Content Provider权限声明： 在应用清单文件标签中使用android：permission权限属性，限定可以访问ContentProvider中的数据的对象（内容提供者有一个重要的额外的安全机制也就是URI权限）。与其他组件不同，应用可以设置两个单独的权限属性：android:readPermission限制谁可以从提供者读取，而android: writePermission限制谁可以写入它。如果提供者受到读写权限的保护，只保留写权限并不意味着可以从提供者读取。 当首次检索提供程序时（如果没有任何权限，会引发SecurityException）并在对提供程序执行时检查权限。使用ContentResolver.query()需要保持读取权限;使用ContentResolver.insert()，ContentResolver.update()，ContentResolver.delete()需要写入权限。在所有这些情况下，不保留所需的权限会导致SecurityException从。 URI权限 ： 目前权限机制并不能完全满足Content Provider的需求。内容提供者希望通过读写权限来保护自己，而客户端也需要将特定的URI传递给其他应用程序供他们操作。例如电子邮件程序中的附件，因为设计到敏感的用户数据，访问电子邮件受到权限保护。但是，如果将图像附件的URI提供给图像查看器，则该图像查看器不再具有打开附件的权限，因为它没有理由持有访问所有电子邮件的权限。 此问题的解决方案是每个URI权限：在启动活动或将结果返回给活动时，调用者可以设置Intent.FLAG_GRANT_READ_URI_PERMISSION和/或Intent.FLAG_GRANT_WRITE_URI_PERMISSION。这允许接收活动权限访问意图中的特定数据URI，而不管其是否具有访问与意图相对应的内容提供者中的数据的任何权限。 这种机制允许一种通用的能力风格模型，在这种模型中，用户交互（例如打开附件或从列表中选择联系人）驱动临时授予细化权限。这可能是将应用程序所需的权限仅限于与其行为直接相关的权限的关键工具。要构建使其他应用程序对您的应用程序负责的最安全的实现，应该以这种方式使用细化的权限，并使用android:grantUriPermissions属性或标签声明您的应用程序的支持。 其他权限声明： 任何调用服务时都可以强制任意细化权限。这是通过Context.checkCallingPermission()方法完成的。使用所需的权限字符串进行调用，并返回一个整数，指示该权限是否已授予当前经常调用。请注意，只有当您执行从另一个进程调用的调用时（通常是通过从服务发布的IDL接口或以其他方式向另一个进程发送的调用），才可以使用它。 还有许多其他有用的方法来检查权限。如果应用拥有另一个进程的进程ID（PID），则可以使用Context.checkPermission()方法检查针对该PID的权限。如果拥有其他应用的软件包名称，则可以使用PackageManager.checkPermission()方法来确定该特定软件包是否已被授予特定权限。 权限自动调整 随着Android的更新，系统可能会某些API增加的限制，因此应用可能需要获取之前不需要的权限。由于应用之前对这些API的访问是不需要相应权限直接访问的，因此Android会将新的权限直接添加到清单文件，以避免在新版本的Android系统中应用的崩溃。Android会根据targetSdkVersion属性的值来确定应用是否需要添加权限。 如果应用自动添加了权限，那么即使您的应用实际上不需要它们，Google Play上的应用列表也会列出这些附加权限。为了避免这种情况并移除不需要的权限，请始终将targetSdkVersion更新为尽可能高。可在Build.VERSION_CODES文档中看到每个版本添加了哪些权限。 权限保护级别 权限分为几个保护级别。保护级别影响是否需要运行时权限请求。有三个保护级别会影响第三方应用程序：正常，签名和危险权限。 普通权限 普通权限包括应用程序需要访问应用程序沙箱外的数据或资源，该访问操作对用户的隐私或其他应用程序的风险很小。例如，设置时区的权限是普通权限。 如果应用程序在其清单中声明它需要正常许可，系统会在安装时自动授予应用程序该许可权。系统不会提示用户授予正常权限，并且用户无法撤消这些权限。 从Android8.1开始一下权限为普通权限： ACCESS_LOCATION_EXTRA_COMMANDS ACCESS_NETWORK_STATE ACCESS_NOTIFICATION_POLICY ACCESS_WIFI_STATE BLUETOOTH BLUETOOTH_ADMIN BROADCAST_STICKY CHANGE_NETWORK_STATE CHANGE_WIFI_MULTICAST_STATE CHANGE_WIFI_STATE DISABLE_KEYGUARD EXPAND_STATUS_BAR GET_PACKAGE_SIZE INSTALL_SHORTCUT INTERNET KILL_BACKGROUND_PROCESSES MANAGE_OWN_CALLS MODIFY_AUDIO_SETTINGS NFC READ_SYNC_SETTINGS READ_SYNC_STATS RECEIVE_BOOT_COMPLETED REORDER_TASKS REQUEST_COMPANION_RUN_IN_BACKGROUND REQUEST_COMPANION_USE_DATA_IN_BACKGROUND REQUEST_DELETE_PACKAGES REQUEST_IGNORE_BATTERY_OPTIMIZATIONS REQUEST_INSTALL_PACKAGES SET_ALARM SET_WALLPAPER SET_WALLPAPER_HINTS TRANSMIT_IR USE_FINGERPRINT VIBRATE WAKE_LOCK WRITE_SYNC_SETTINGS 签名权限 系统在安装时授予这些应用的权限，但仅当试图使用权限的应用程序由与定义权限的应用程序相同的证书签名时。 从Android 8.1（API级别27）开始，第三方应用程序可以使用的以下权限分类为PROTECTION_SIGNATURE： BIND_ACCESSIBILITY_SERVICE BIND_AUTOFILL_SERVICE BIND_CARRIER_SERVICES BIND_CHOOSER_TARGET_SERVICE BIND_CONDITION_PROVIDER_SERVICE BIND_DEVICE_ADMIN BIND_DREAM_SERVICE BIND_INCALL_SERVICE BIND_INPUT_METHOD BIND_MIDI_DEVICE_SERVICE BIND_NFC_SERVICE BIND_NOTIFICATION_LISTENER_SERVICE BIND_PRINT_SERVICE BIND_SCREENING_SERVICE BIND_TELECOM_CONNECTION_SERVICE BIND_TEXT_SERVICE BIND_TV_INPUT BIND_VISUAL_VOICEMAIL_SERVICE BIND_VOICE_INTERACTION BIND_VPN_SERVICE BIND_VR_LISTENER_SERVICE BIND_WALLPAPER CLEAR_APP_CACHE MANAGE_DOCUMENTS READ_VOICEMAIL REQUEST_INSTALL_PACKAGES SYSTEM_ALERT_WINDOW WRITE_SETTINGS WRITE_VOICEMAIL 危险权限 危险权限涵盖应用程序需要涉及用户私人信息的数据或资源的区域，或者可能会影响用户的存储数据或其他应用程序的操作。例如，阅读用户联系人的权限是危险的权限。如果一个应用程序声明它需要一个危险的权限，用户必须明确授予该应用程序的权限。在用户批准权限之前，应用无法提供取决于该权限的功能。要使用危险权限，应用必须提示用户在运行时授予权限。 特殊权限 有几个权限不具有正常和危险的权限。 SYSTEM_ALERT_WINDOW和WRITE_SETTINGS特别敏感，所以大多数应用程序不应该使用它们。如果应用程序需要这些权限之一，则必须在清单中声明权限，并发送请求用户授权的意图。系统通过向用户显示详细的管理屏幕来响应意图。 权限组 根据权限与之相关的功能权限被组织到权限组中。在此系统下，权限请求在组级别处理，并且单个权限组对应于应用清单中的多个权限声明。例如，SMS组包含READ_SMS和RECEIVE_SMS声明。以这种方式分组权限使用户能够做出更有意义和更明智的选择。 所有危险的Android权限都属于权限组。不管保护级别如何，任何权限都可以属于权限组。但是，如果权限是危险的，权限组只会影响用户体验。 如果设备运行的是Android 6.0（API级别23），并且该应用的targetSdkVersion为23或更高，则当您的应用请求危险权限时，以下系统行为适用： 如果应用程序当前没有权限组的权限，系统会向描述该应用程序想要访问的权限组的用户显示权限请求对话框。该对话框没有描述该组内的特定权限。例如，如果某个应用程序请求READ_CONTACTS权限，则系统对话框只是表示应用程序需要访问该设备的联系人。如果用户同意，系统只给予应用程序许可。 如果应用程序已被授予同一权限组中的另一个危险权限，系统会立即授予权限，而不会与用户进行任何交互。例如，如果一个应用程序先前已经请求并被授予了READ_CONTACTS权限，并且它然后请求了WRITE_CONTACTS，则系统立即授予该权限而不向用户显示权限对话框。 警告：未来版本的Android SDK可能会将特定权限从一个组移到另一个组。因此，不要将您的应用的逻辑基于这些权限组的结构。例如，从Android 8.1（API级别27）开始，READ_CONTACTS与WRITE_CONTACTS处于相同的权限组。如果应用程序请求READ_CONTACTS权限，然后请求WRITE_CONTACTS权限，请不要假定系统可以自动授予WRITE_CONTACTS权限。 如果设备运行Android 5.1（API级别22）或更低，或者应用程序的targetSdkVersion为22或更低，则系统会要求用户在安装时授予权限。系统再一次告诉用户应用程序需要什么权限组，而不是个人权限。例如，当应用程序请求READ_CONTACTS时，安装对话框会列出联系人组。当用户接受时，只有READ_CONTACTS权限被授予应用程序。 危险的权限和权限组 | Permission Group | Permissions || —————- | :———————————————————– || CALENDAR | READ_CALENDAR WRITE_CALENDAR || CAMERA | CAMERA || CONTACTS | READ_CONTACTS WRITE_CONTACTS GET_ACCOUNTS || LOCATION | ACCESS_FINE_LOCATION ACCESS_COARSE_LOCATION || MICROPHONE | RECORD_AUDIO || PHONE | READ_PHONE_STATE READ_PHONE_NUMBERS CALL_PHONE ANSWER_PHONE_CALLS (must request at runtime) READ_CALL_LOG WRITE_CALL_LOG ADD_VOICEMAIL USE_SIP PROCESS_OUTGOING_CALLS ANSWER_PHONE_CALLS || SENSORS | BODY_SENSORS || SMS | SEND_SMS RECEIVE_SMS READ_SMS RECEIVE_WAP_PUSH RECEIVE_MMS || STORAGE | READ_EXTERNAL_STORAGE`WRITE_EXTERNAL_STORAGE` | 查看应用程序的权限 可以使用Settings应用程序和shell命令adb shell pm列表权限查看系统中当前定义的所有权限。要使用设置应用，请转到设置&gt;应用。选择一个应用并向下滚动以查看该应用使用的权限。对于开发人员，adb’-s’选项以类似于用户看到它们的方式显示权限： 123456789101112$ adb shell pm list permissions -sAll Permissions:Network communication: view Wi-Fi state, create Bluetooth connections, fullinternet access, view network stateYour location: access extra location provider commands, fine (GPS) location,mock location sources for testing, coarse (network-based) locationServices that cost you money: send SMS messages, directly call phone numbers... 也可以使用adb -g选项在模拟器或测试设备上安装应用程序时自动授予所有权限： 1$ adb shell install -g MyApp.apk 在运行时请求权限 从 Android 6.0（API 级别 23）开始，用户开始在应用运行时向其授予权限，而不是在应用安装时授予。此方法可以简化应用安装过程，因为用户在安装或更新应用时不需要授予权限。它还让用户可以对应用的功能进行更多控制；例如，用户可以选择为相机应用提供相机访问权限，而不提供设备位置的访问权限。用户可以随时进入应用的“Settings”屏幕调用权限。 系统权限分为两类：正常权限和危险权限 正常权限不会直接给用户隐私权带来风险。如果应用在其清单中列出了正常权限，系统将自动授予该权限。 危险权限会授予应用访问用户机密数据的权限。如果列出了危险权限，则用户必须明确批准您的应用使用这些权限。 在所有版本的 Android 中，您应用都需要在其应用清单中同时声明它需要的正常权限和危险权限，如声明权限中所述。不过，该声明的影响因系统版本和应用的目标 SDK 级别的不同而有所差异： 如果设备运行的是 Android 5.1 或更低版本，或者应用的目标 SDK 为 22 或更低：如果您在清单中列出了危险权限，则用户必须在安装应用时授予此权限；如果他们不授予此权限，系统根本不会安装应用。 如果设备运行的是 Android 6.0 或更高版本，或者应用的目标 SDK 为 23 或更高：应用必须在清单中列出权限，并且它必须在运行时请求其需要的每项危险权限。用户可以授予或拒绝每项权限，且即使用户拒绝权限请求，应用仍可以继续运行有限的功能。 如果设备运行的是 Android 5.1 或更低版本，或者应用的目标 SDK 为 22 或更低：如果您清单中列出了危险权限，则用户必须在安装应用时授予此权限；如果他们不授予此权限，系统根本不会安装应用。 如果设备运行的是 Android 6.0 或更高版本，或者应用的目标 SDK 为 23 或更高：应用必须在清单中列出权限，并且它必须在运行时请求其需要的每项危险权限。用户可以授予或拒绝每项权限，且即使用户拒绝权限请求，应用仍可以继续运行有限的功能。 检查权限 如果应用需要危险权限，则每次执行需要这一权限的操作时您都必须检查自己是否具有该权限。用户始终可以自由调用此权限。 要检查您是否具有某项权限，请调用 ContextCompat.checkSelfPermission() 方法。例如，以下代码段显示了如何检查 Activity 是否具有在日历中进行写入的权限： int permissionCheck =ContextCompat.checkSelfPermission(thisActivity,Manifest.permission.WRITE_CALENDAR); 如果应用具有此权限，方法将返回 PackageManager.PERMISSION_GRANTED，并且应用可以继续操作。如果应用不具有此权限，方法将返回 PERMISSION_DENIED，且应用必须明确向用户要求权限 请求权限 如果应用需要应用清单中列出的危险权限，那么，它必须要求用户授予该权限。Android 为您提供了多种权限请求方式。调用这些方法将显示一个标准的 Android 对话框，不过，能对它们进行自定义。 向用户解释需要权限的原因 在某些情况下，可能需要让用户了解您的应用为什么需要某项权限。例如，如果用户启动一个摄影应用，用户对应用要求使用相机的权限可能不会感到吃惊，但用户可能无法理解为什么此应用想要访问用户的位置或联系人。在请求权限之前，不妨为用户提供一个解释。请记住，不需要通过解释来说服用户；如果提供太多解释，用户可能发现应用令人失望并将其移除。 可以采用的一个方法是仅在用户已拒绝某项权限请求时提供解释。如果用户继续尝试使用需要某项权限的功能，但继续拒绝权限请求，则可能表明用户不理解应用为什么需要此权限才能提供相关功能。对于这种情况，比较好的做法是显示解释。 为了帮助查找用户可能需要解释的情形，Android 提供了一个实用程序方法，即 shouldShowRequestPermissionRationale()。如果应用之前请求过此权限但用户拒绝了请求，此方法将返回 true。如果用户在过去拒绝了权限请求，并在权限请求系统对话框中选择了 Don’t ask again 选项，此方法将返回 false。如果设备规范禁止应用具有该权限，此方法也会返回 false。 请求需要的权限 如果应用尚无所需的权限，则应用必须调用一个 requestPermissions() 方法，以请求权限。应用将传递其所需的权限，以及指定用于识别此权限请求的整型请求代码。此方法异步运行：它会立即返回，并且在用户响应对话框之后，系统会使用结果调用应用的回调方法，将应用传递的相同请求代码传递到 requestPermissions()。 例如，以下代码可以检查应用是否具备读取用户联系人的权限，并根据需要请求该权限： 1234567891011121314151617181920212223242526// Here, thisActivity is the current activityif (ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) &#123; // Should we show an explanation? if (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity, Manifest.permission.READ_CONTACTS)) &#123; // Show an expanation to the user *asynchronously* -- don&apos;t block // this thread waiting for the user&apos;s response! After the user // sees the explanation, try again to request the permission. &#125; else &#123; // No explanation needed, we can request the permission. ActivityCompat.requestPermissions(thisActivity, new String[]&#123;Manifest.permission.READ_CONTACTS&#125;, MY_PERMISSIONS_REQUEST_READ_CONTACTS); // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an // app-defined int constant. The callback method gets the // result of the request. &#125;&#125; 注：当您的应用调用 requestPermissions() 时，系统将向用户显示一个标准对话框。应用无法配置或更改此对话框。如果需要为用户提供任何信息或解释，您应在调用 requestPermissions() 之前进行，如解释应用为什么需要权限中所述。 处理权限请求响应 当应用请求权限时，系统将向用户显示一个对话框。当用户响应时，系统将调用应用的 onRequestPermissionsResult() 方法，向其传递用户响应。应用必须重写改方法，以了解是否已获得相应权限。回调会将您传递的相同请求代码传递给 requestPermissions()。例如，如果应用请求 READ_CONTACTS 访问权限，则它可能采用以下回调方法： 123456789101112131415161718192021222324@Overridepublic void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) &#123; switch (requestCode) &#123; case MY_PERMISSIONS_REQUEST_READ_CONTACTS: &#123; // If request is cancelled, the result arrays are empty. if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; // permission was granted, yay! Do the // contacts-related task you need to do. &#125; else &#123; // permission denied, boo! Disable the // functionality that depends on this permission. &#125; return; &#125; // other &apos;case&apos; lines to check for other // permissions this app might request &#125;&#125; ​ 系统显示的对话框说明了您的应用需要访问的权限组；它不会列出具体权限。例如，如果请求 READ_CONTACTS 权限，系统对话框只显示应用需要访问设备的联系人。用户只需要为每个权限组授予一次权限。如果应用请求该组中的任何其他权限（已在您的应用清单中列出），系统将自动授予应用这些权限。当请求此权限时，系统会调用 onRequestPermissionsResult() 回调方法，并传递 PERMISSION_GRANTED，如果用户已通过系统对话框明确同意您的权限请求，系统将采用相同方式操作。 注：应用仍需要明确请求其需要的每项权限，即使用户已向应用授予该权限组中的其他权限。此外，权限分组在将来的 Android 版本中可能会发生变化。您的代码不应依赖特定权限属于或不属于相同组这种假设。 例如，假设应用清单中列出了 READ_CONTACTS 和 WRITE_CONTACTS。如果请求 READ_CONTACTS 且用户授予了此权限，那么，当请求 WRITE_CONTACTS 时，系统将立即授予您该权限，不会与用户交互。如果用户拒绝了某项权限请求，应用应采取适当的操作。例如，应用可能显示一个对话框，解释它为什么无法执行用户已经请求但需要该权限的操作。当系统要求用户授予权限时，用户可以选择指示系统不再要求提供该权限。这种情况下，无论应用在什么时候使用 requestPermissions() 再次要求该权限，系统都会立即拒绝此请求。系统会调用onRequestPermissionsResult() 回调方法，并传递 PERMISSION_DENIED，如果用户再次明确拒绝了应用的请求，系统将采用相同方式操作。这意味着当您调用 requestPermissions() 时，应用不能假设已经发生与用户的任何直接交互。 权限请求示例 权限请求保护设备中可用的敏感信息，并且只能在访问信息对于您的应用的运行是必需的时才使用。权限请求示例提供了有关如何在不需要访问此类信息的情况下实现相同（或更好）功能的提示; 使用Android权限的原则 只使用应用程序工作所需的权限：因为可能有另一种方法可以满足您的需求（系统意图，标识符，电话背景），而无需依赖敏感信息。 注意jar包所需要的权限：当你使用一个库时，应该清楚它所需要的权限以及权限的用途然后获取它所需要的权限。 权限透明原则：进行权限请求时，应当告知用户获取权限的原因。使此信息与权限请求一起提供，包括安装，运行时或更新权限对话。 确保系统访问清晰：当访问敏感功能（例如相机或麦克风）时，应在收集数据时提供连续请求以便清楚地向用户显示。 Android6.0的权限变更 Android 6.0 引入了一个新的权限策略，它允许应用程序在运行时向用户请求权限，而不是在安装之前。当应用程序实际需要受服务保护的服务或数据时，应用程序支持使用新的策略进行权限请求。虽然这不会（必然）改变整体应用程序行为，但它确实会引起敏感用户数据处理方式相关的一些更改。 权限请求增加提示：在运行时，会在应用程序对话框中提示用户所使用的功能会涵盖那些权限以及权限组组。用户对请求权限的对话框中的提示很敏感，更重要的是，如果要求的权限与应用的目的不匹配，应该向用户提供详细的解释，说明为什么要求获取该权限;只要有可能，应该在请求时提供请求的解释，并在用户拒绝请求时在后续对话框中提供解释。 授予权限的灵活性更大：用户可以在请求和设置时拒绝权限的授权，但当用户的操作或使用的功能因此而中断时。应用可以监控有多少用户拒绝权限，以便在重构时避免使用该权限，或者对为什么应用需要获得改权限才能正常工作提供更好的解释。还应该确保应用处理在用户拒绝权限请求或关闭设置中的权限时创建的异常。 增加了操作负担：要求用户单独授予权限的访问权限，而不是一组权限。这对于最小化请求的权限数量非常重要，因为它增加了用户授予权限的操作负担，并增加了至少拒绝一个请求的可能性。 避免请求不必要的权限 每当您要求获得权限时，都会强制用户做出决定。应用应该尽量减少请求获取权限。如果用户运行的是Android 6.0（API级别23）或更高版本，则每次用户尝试一些需要权限的程序功能时，应用程序都必须使用权限请求中断用户的工作。如果用户正在运行早期版本的Android，则用户必须在安装应用程序时授予每个应用程序的权限;如果列表太长或看起来不合适，用户可能决定根本不安装您的应用程序。出于这些原因，应该尽量减少应用程序需要的权限数量。 优先使用Intent 在很多情况下，应用可以选择两种方式执行任务。应用程序可以获取权限自己执行任务，也可以使用意图让另一个应用程序执行任务，这样就不必获取权限。 例如，假设应用需要能够使用设备相机拍照。应用可以请求CAMERA权限，该权限允许应用直接访问摄像头。然后，应用将使用相机API来控制相机并拍摄照片。这种方法中应用完全控制摄影过程，并让摄像头UI整合到应用中。 但是，如果应用对访问用户数据的需求不频繁 ， 换句话说，每次需要访问数据时，用户都都会看到一个请求权限的对话框，这会严重影响用户的体验。应用可以使用基于意图的请求。 Android提供了一些应用程序可以在不需要权限的情况下使用的系统意图，因为用户选择在发出基于意图的请求时与应用程序共享什么（如果有的话）。例如，MediaStore.ACTION_IMAGE_CAPTURE或MediaStore.ACTION_VIDEO_CAPTURE的intent操作类型可用于获取图像或视频，而无需直接使用Camera对象（需要权限）。在这种情况下，每次捕获图像时，系统意图都会代表应用请求用户的许可。 直接使用权限和使用Intent的优缺点： 使用权限： 执行操作时，应用可全面控制用户体验。但是，如此广泛的控制会增加代码的复杂性，因为需要设计合适的UI。 系统会在运行时或安装时提示用户授予一次权限（具体取决于用户的Android版本）。之后，应用可以执行操作，而无需用户进行额外的交互。但是，如果用户未授予权限（或稍后撤销权限），则应用程序将失去执行操作的能力。 使用Intent： 应用不必为操作设计UI。处理意图的应用程序提供UI。 用户可以使用他们的首选应用程序来完成任务。例如，用户可以选择最喜欢的照片应用拍照。 如果用户没有该操作的默认应用程序，系统会提示用户选择一个应用程序。如果用户没有指定默认处理程序，则每次执行操作时可能需要经过额外的对话框。 不要让用户陷于频繁的请求处理 如果用户运行Android 6.0（API级别23）或更高版本，则用户必须在运行应用程序时授予您的应用程序权限。如果您一次性向用户提出大量权限请求，您可能会压倒用户并导致他们退出应用。 开发者应该根据需求去请求权限。在某些情况下，一个或多个权限可能对应用程序绝对是必不可少的。应用程序启动后立即要求提供所有这些权限可能很有意义。例如，如果制作摄影应用程序，该应用程序需要访问设备摄像头。当用户第一次启动应用程序时，用户会被要求获得使用相机的权限并不感到惊讶。但是，如果同一个应用程序还具有与用户的联系人共享照片的功能，那么在首次启动时，可能不应要求提供READ_CONTACTS权限。相反，请等到用户尝试使用“共享”功能并要求获得许可。 如果应用程序提供了教程，那么在教程序列结尾处请求应用程序的基本权限也是很容易让用户接受的。 多媒体应用失去焦点进入后台是暂停播放 应用程序在用户接到电话时进入后台并且失去焦点，并且只有在呼叫停止后才能重新调整焦点。在这些情况下的常见方法（例如媒体播放器在通话期间静音或暂停）是使用PhoneStateListener监听呼叫状态的更改或监听android.intent.action.PHONE_STATE的广播。该解决方案的问题在于它需要READ_PHONE_STATE权限，这会强制用户授予对各种敏感数据的访问权限，例如设备和SIM硬件ID以及来电的电话号码。 应用可以通过请求AudioFocus来避免此问题，因为它不需要明确权限（因为它不访问敏感信息）。只需将代码置于onAudioFocusChange()事件处理程序中所需的代码，并在操作系统移动其音频焦点时自动运行。 确定应用运行的设备标识 应用程序可能具有对特定设备的偏好或消息传递（例如，在服务器为用户保存设备特定的播放列表，以便用户可以为他们的汽车和家中有不同的播放列表）。一种常见的解决方案是利用设备标识符，例如设备IMEI，但这需要设备ID和呼叫信息权限组（M +中的PHONE）。它还使用无法重置并在所有应用程序之间共享的标识符。 使用这些类型的标识符有两种选择： 使用com.google.android.gms.iid InstanceID API。 getInstance（上下文上下文）.getID()将为应用程序实例返回唯一的设备标识符。结果是一个应用程序实例作用域标识符，可以在存储有关应用程序的信息时用作键，并在用户重新安装应用程序时重置。 使用基本系统函数（如randomUUID()）创建属于应用程序存储空间的自己的标识符。 为广告和用户分析功能创建唯一标识符 对于广告和用户分析功能，需要一个唯一标识符来为未登录应用的用户构建配置文件（例如，针对广告的用户定位定位或计算广告转化率）。 为广告和用户分析构建配置文件有时需要和其他应用程序共享的标识符。常见的解决方案涉及利用设备标识符，如设备IMEI，它需要设备ID和呼叫信息权限组（API级别23+中的PHONE），并且不能由用户重置。在任何这些情况下，除了使用不可重置的标识符并要求用户特殊的权限外，还将违反Play开发者计划政策。不幸的是，在这些情况下，使用com.google.android.gms.iid InstanceID API或系统函数来创建应用程序范围ID不是合适的解决方案，因为ID可能需要跨应用程序共享。另一种解决方案是通过getId()方法使用AdvertisingIdClient.Info类中的广告标识符。应用可以使用getAdvertisingIdInfo(Context)方法创建AdvertisingIdClient.Info对象，并调用getId()方法以使用标识符。注意这个方法是阻塞的，所以你不应该从主线程调用它;这个方法的详细解释可以在这里找到 了解应用使用的第三方库 应用中使用的库也需要权限。例如，广告和分析库可能需要访问位置或身份权限组才能实现所需的功能。但从用户的角度来看，权限请求来自你的应用程序，而不是库。 正如用户选择相同功能使用较少权限的应用程序一样，开发人员应该查看其库并选择未使用不必要权限的第三方SDK。例如，尝试避免需要身份权限组的库，除非存在明确的面向用户的原因，为什么应用程序需要这些权限。特别是，对于提供位置功能的库，请确保您不需要请求FINE_LOCATION权限，除非使用基于位置的定位功能。 解释为什么需要权限 调用requestPermissions()时系统显示的权限对话框表示应用需要什么权限，但没有说明原因。在某些情况下，用户可能会觉得令人费解的。因此在调用requestPermissions()之前需要向用户解释为什么你的应用程序需要权限。 如果仅使用属于某个权限组的API调用的一小部分，则有助于明确列出正在使用哪些权限以及原因。例如： 如果只使用粗略位置，请让用户在应用说明中或在有关应用的帮助文章中了解这一点。 如果需要访问短信以接收验证码，以保护用户免遭欺诈，请让用户在应用说明中和/或第一次访问数据时了解相关信息。 注意：如果应用程序的适配版本是Android 8.0（API级别26）或更高，请不要请求READ_SMS权限作为验证用户凭据的一部分。相反，请使用createAppSpecificSmsToken()生成特定于应用程序的令牌，然后将此令牌传递给可发送验证SMS消息的其他应用程序或服务。 让用户实时了解敏感数据访问也是有利的也是有利的。例如，如果应用正在访问摄像头或麦克风，最好让用户知道应用程序中某处的通知图标或通知托盘中的通知图标（如果应用程序在后台运行），这表示应用不是在偷偷手机用户数据。 如果需要申请在应用中制作某些内容的权限，但其原因尚不清楚，请找到让用户知道为什么需要最敏感的权限。 测试两种权限模式 从 Android 6.0 开始，用户在应用运行时允许或者拒绝权限而不是在应用安装时，这导致你需要测试各种条件下app 的表现。在 Android 6.0之前，你可以合理假定你的 app 一直可运行，它拥有所有在 app manifest中声明的权限。在新的权限模式下，你不能这么认为了。 以下提示将帮助你验证 Android 6.0及以上系统的权限相关代码问题。 验证 app 当前权限以及相关代码路径。 测试用户通过权限保护服务和数据。 测试多种权限分别被允许、拒绝的组合情况。比如，相机 app 可能在 manifest 文件中声明了CAMERA 、 READ_CONTACTS 和 ACCESS_FINE_LOCATION 权限。你应该测试每个权限打开和关闭的情况来确保 app 可以优雅地处理所有权限配置情况。记住，从 Android 6.0开始用户可以打开或关闭任意一个app的权限，即便是 targets API 在 22及以下的。 使用 adb 工具通过命令行管理权限： 以组的形式列出权限和状态： $ adb shell pm list permissions -d -g 允许或拒绝一个或多个权限： $ adb shell pm [grant|revoke] 为使用权限的服务分析 app ##自定义应用权限 通过定义自定义权限，应用程序可以与其他应用程序共享其资源和功能。 背景 Android是一个权限隔离的操作系统，每个应用程序都以不同的系统标识（Linux用户标识和组标识）运行，Linux将应用程序与系统隔离开来。应用可以通过定义权限(其他应用可以请求)来将自身功能展示给其他应用。并且还可以定义自动提供给任何其他使用相同证书签名的应用程序的权限。 应用签名：所有APK必须使用其开发人员拥有私钥的证书进行签名。此证书标识应用的作者。证书不需要由证书颁发机构签名;对于Android应用程序来说，使用自签名证书是完全可以允许并常用的。 Android中证书的用途是区分应用作者。这允许系统授予或拒绝应用程序访问签名级别的权限，并授予或拒绝应用程序的请求获得与另一个应用程序相同的Linux身份。 用户ID和文件访问权限：在安装时，Android系统为每个应用提供独有的Linux用户ID。应用在该设备的使用寿命中，应用身份保持不变（UID不变）。同一个软件包在不同的设备上，可能有不同的UID;重要的是每个软件包在给定设备上具有不同的UID。由于安全实施发生在流程级别，因此任何两个软件包的代码通常无法在同一进程中运行，因为它们需要以不同的Linux用户身份运行。您可以使用每个软件包的AndroidManifest.xml清单标记中的sharedUserId属性为它们分配相同的用户ID。通过这样做，这两个包将被视为同一个应用程序，并具有相同的用户标识和文件权限。请注意，为了保持安全性，只有两个使用相同签名签名（并请求相同sharedUserId）的应用将被赋予相同的用户ID。应用程序存储的任何数据都将被分配该应用程序的用户ID，而其他软件包通常无法访问该ID。 定义和执行权限 要执行权限，首先必须在AndroidManifest.xml中使用一个或多个元素声明。 123456789101112&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.myapp&quot; &gt; &lt;permission android:name=&quot;com.example.myapp.permission.DEADLY_ACTIVITY&quot; android:label=&quot;@string/permlab_deadlyActivity&quot; android:description=&quot;@string/permdesc_deadlyActivity&quot; android:permissionGroup=&quot;android.permission-group.COST_MONEY&quot; android:protectionLevel=&quot;dangerous&quot; /&gt; ...&lt;/manifest&gt; ​ 注意：除非所有应用都使用相同的签名证书，否则系统不允许多个应用声明具有相同名称的权限。如果应用声明了权限，则系统不允许用户安装具有相同权限名的其它应用，除非应用的签名证书相同。为避免命名冲突，建议为自定义权限使用反向域名式命名，如com.example.myapp.ENGAGE_HYPERSPACE。 必需的使用protectionLevel属性，来告诉系统如何向用户通知需要许可的应用程序，或者允许谁拥有该许可权。 可选择使用android:permissionGroup属性，来帮助系统向用户显示权限。在大多数情况下，应用应该将其设置为标准系统权限组（在android.Manifest.permission_group中列出），尽管可以自己定义一个组。最好使用现有组，因为这简化了向用户显示的权限UI。 应用需要提供标签和描述权限。这些是用户在查看权限列表（android:label）或单个权限（android:description）上的详细信息时可以看到的字符串资源。标签应该是简短的，用几句话来描述权限所保护的关键功能。描述应该是几个句子，描述应用获取权限做什么。我们的约定是一个两个句子的描述：第一个句子描述权限，第二个句子警告用户在应用程序被授予权限时可能出错的类型。以下CALL_PHONE权限的标签和说明示例： 12345&lt;string name=&quot;permlab_callPhone&quot;&gt;directly call phone numbers&lt;/string&gt;&lt;string name=&quot;permdesc_callPhone&quot;&gt;Allows the app to call phone numbers without your intervention. Malicious apps may cause unexpected calls on your phone bill. Note that this does not allow the app to call emergency numbers.&lt;/string&gt; 创建一个权限组 应用可以使用android:permissionGroup属性来帮助系统向用户描述权限。在大多数情况下，会希望将其设置为标准系统组（在android.Manifest.permission_group中列出），但也可以使用定义自己的组。 元素为一组权限定义了一个标签 - 这两个标签都在清单中用元素声明并在别处声明。这仅影响将权限分配给用户时的分组方式。 元素不指定属于该组的权限，但是它给该组一个名称。应用可以通过将组名分配给元素的permissionGroup属性来在组中放置权限。 自定义权限的建议 如果正在设计一系列向其它应用公开功能的应用程序，在设计应用程序时请尽量保证每个权限仅定义一次。如果应用程序未使用相同的证书签名，每个权限只能定义一次。即使这些应用程序都使用相同的证书进行签名，最好只定义一次权限。 如果该功能仅适用于使用于提供应用程序签名相同的签名的应用程序，则可以通过使用签名检查来避免定义自定义权限。当其中一个应用程序向另一个应用程序发出请求时，第二个应用程序可以验证这两个应用程序是否已使用相同的证书进行签名，然后再执行该请求。 如果您正在开发仅在自己的设备上安装的应用程序，则应开发并安装管理套件中所有应用程序权限的程序包。这个包不需要自己提供任何服务。它只是声明所有权限，而套件中的其他应用程序则使用元素请求这些权限。]]></content>
      <categories>
        <category>guide</category>
      </categories>
      <tags>
        <tag>guide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[API Guide之应用基础知识]]></title>
    <url>%2F2018%2F03%2F14%2FAPI%20Guide%E4%B9%8B%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Android应用的沙箱机制最小权限原则 Android操作系统是一个多用户的Linux系统，其中每个应用都是不同的用户，并且系统会为每个应用分配一个唯一的Linux用户ID（用户ID仅系统使用，应用并不知晓）。系统为应用中的所有文件设置权限，并且只可用分配给该应用的用户ID才能访问这些文件； 默认情况下，每个应用都运行在自己的Linux进程内，并且每个进程都有自己的虚拟机（VM），应用代码是在与其它应用隔离的环境中运行的。Android会在需要执行任何应用组建时启动该组件所在的进程，然后在不再需要该进程或者系统必须为其它应用提供内存时关闭该进程； 默认情况下，每个应用只能访问或执行其工作所需的组建，而并不能访问其他组件，并且应用无法访问系统中其未获取权限的部分。 共享数据和访问系统服务 两个应用共享同一Linux用户ID时，它们可以相互访问彼此的文件，同时为了节省系统资源，可以安排具有相同用户ID的应用在同一Linux进程中运行，共享同一VM（签名证书相同）。 在获取相应权限的条件下，应用可以请求访问设备中的数据（如用户的联系人、短信、可装载存储装置 [SD 卡]、相机、蓝牙等）。 应用组件 应用组件是Android应用构建的基块。每个组件都是一个不同的点，系统可以通过组件进入应用。并非所有组件都是用户的实际入口，有些组件互相依赖，但每个组件都以独立实体的形式存在，并发挥特定作用 — 每个组件都是唯一的构建基块，有助于定义应用的总体行为。共有四种类型的组件分别是：Activity、服务、内容提供者、广播接收器。 Activity Activity表示具有用户界面的单一屏幕。 服务 服务是一种在后台运行的组件，用于执行长时间运行的操作或为远程进程执行作业。 服务不提供用户界面。 例如，当用户位于其他应用中时，服务可能在后台播放音乐或者通过网络获取数据，但不会阻断用户与 Activity 的交互。 诸如 Activity 等其他组件可以启动服务，让其运行或与其绑定以便与其进行交互。 内容提供程序 内容提供程序管理一组共享的应用数据。可以将数据存储在文件系统、SQLite 数据库、网络上或者应用可以访问的任何其他永久性存储位置。 其他应用可以通过内容提供程序查询数据，甚至修改数据（如果内容提供程序允许）。 例如，Android 系统可提供管理用户联系人信息的内容提供程序。 因此，任何具有适当权限的应用都可以查询内容提供程序的某一部分（如 ContactsContract.Data），以读取和写入有关特定人员的信息。内容提供程序也适用于读取和写入应用不共享的私有数据。 例如，记事本示例应用使用内容提供程序来保存笔记。 广播接收器 广播接收器是一种用于响应系统范围广播通知的组件。 许多广播都是由系统发起的，应用自身也可以发起广播 — 例如。 尽管广播接收器不会显示用户界面，但它们可以创建状态栏通知在发生广播事件时提醒用户。 但广播接收器更常见的用途只是作为通向其他组件的“通道”，设计用于执行极少量的工作。 启动组件在 Android 系统启动应用组件之前，系统必须通过读取应用的 AndroidManifest.xml 文件（“清单”文件）确认组件存在。 应用必须在此文件中声明其所有组件，该文件必须位于应用项目目录的根目录中。 除了声明应用的组件外，清单文件还有许多其他作用，如： 确定应用需要的任何用户权限，如互联网访问权限或对用户联系人的读取权限 根据应用使用的 API，声明应用所需的最低 API 级别 声明应用使用或需要的硬件和软件功能，如相机、蓝牙服务或多点触摸屏幕 应用需要链接的 API 库（Android 框架 API 除外），如 Google 地图库 其他功能 声明组件内容 清单文件的主要任务是告知系统有关应用组件的信息。例如，清单文件可以像下面这样声明 Activity： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest ... &gt; &lt;application android:icon=&quot;@drawable/app_icon.png&quot; ... &gt; &lt;activity android:name=&quot;com.example.project.ExampleActivity&quot; android:label=&quot;@string/example_label&quot; ... &gt; &lt;/activity&gt; ... &lt;/application&gt;&lt;/manifest&gt; 在 &lt;application&gt; 元素中，android:icon 属性指向标识应用的图标所对应的资源。 在 &lt;activity&gt; 元素中，android:name 属性指定 Activity 子类的完全限定类名，android:label 属性指定用作 Activity 的用户可见标签的字符串。 必须通过以下方式声明所有应用组件： Activity 的 &lt;activity&gt; 元素 服务的 &lt;service&gt; 元素 广播接收器的 &lt;receiver&gt; 元素 内容提供程序的 &lt;provider&gt; 元素 未在清单文件中声明的 Activity、服务和内容提供程序对系统不可见，因此也永远不会运行。 不过，广播接收器可以在清单文件中声明或在代码中动态创建（如 BroadcastReceiver 对象）并通过调用 registerReceiver() 在系统中注册。 功能 可以使用 Intent 来启动 Activity、服务和广播接收器。 可以通过在 Intent 中显式命名目标组件（使用组件类名）来执行此操作。 不过，Intent 的真正强大之处在于隐式 Intent 概念。 隐式 Intent 的作用无非是描述要执行的操作类型（还可选择描述您想执行的操作所针对的数据），让系统能够在设备上找到可执行该操作的组件，并启动该组件。 如果有多个组件可以执行 Intent 所描述的操作，则由用户选择使用哪一个组件。 系统通过将接收到的 Intent 与设备上的其他应用的清单文件中提供的 Intent 过滤器进行比较来确定可以响应 Intent 的组件。 当应用在清单文件中声明 Activity 时，可以选择性地加入声明 Activity 功能的 Intent 过滤器，以便响应来自其他应用的 Intent。 您可以通过将 元素作为组件声明元素的子项进行添加来为您的组件声明 Intent 过滤器。 例如，如果您开发的电子邮件应用包含一个用于撰写新电子邮件的 Activity，则可以像下面这样声明一个 Intent 过滤器来响应“send” Intent（以发送新电子邮件），然后，如果另一个应用创建了一个包含ACTION_SEND 操作的 Intent，并将其传递到 startActivity()，则系统可能会启动您的 Activity，以便用户能够草拟并发送电子邮件。 123456789101112&lt;manifest ... &gt; ... &lt;application ... &gt; &lt;activity android:name=&quot;com.example.project.ComposeEmailActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.SEND&quot; /&gt; &lt;data android:type=&quot;*/*&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; ​ 声明应用要求 基于 Android 系统的设备多种多样，并非所有设备都提供相同的特性和功能。 为防止将您的应用安装在缺少应用所需特性的设备上，您必须通过在清单文件中声明设备和软件要求，为您的应用支持的设备类型明确定义一个配置文件。 其中的大多数声明只是为了提供信息，系统不会读取它们，但 Google Play 等外部服务会读取它们，以便当用户在其设备中搜索应用时为用户提供过滤功能。 应用资源 Android 应用并非只包含代码 — 它还需要与源代码分离的资源，如图像、音频文件以及任何与应用的视觉呈现有关的内容。 例如，您应该通过 XML 文件定义 Activity 用户界面的动画、菜单、样式、颜色和布局。 使用应用资源能够在不修改代码的情况下轻松地更新应用的各种特性，并可通过提供备用资源集让您能够针对各种设备配置（如不同的语言和屏幕尺寸）优化您的应用。 对于 Android 项目中包括的每一项资源，SDK 构建工具都会定义一个唯一的整型 ID，您可以利用它来引用应用代码或 XML 中定义的其他资源中的资源。 例如，如果您的应用包含一个名为 logo.png 的图像文件（保存在 res/drawable/ 目录中），则 SDK 工具会生成一个名为 R.drawable.logo 的资源 ID，您可以利用它来引用该图像并将其插入您的用户界面。 提供与源代码分离的资源的其中一个最重要优点在于，您可以提供针对不同设备配置的备用资源。 例如，通过在 XML 中定义 UI 字符串，您可以将字符串翻译为其他语言，并将这些字符串保存在单独的文件中。 然后，Android 系统会根据向资源目录名称追加的语言限定符（如为法语字符串值追加 res/values-fr/）和用户的语言设置，对您的 UI 应用相应的语言字符串。 Android 支持许多不同的备用资源限定符。限定符是一种加入到资源目录名称中，用来定义这些资源适用的设备配置的简短字符串。 再举一例，您应该经常会根据设备的屏幕方向和尺寸为 Activity 创建不同的布局。 例如，当设备屏幕为纵向（长型）时，您可能想要一种垂直排列按钮的布局；但当屏幕为横向（宽型）时，应按水平方向排列按钮。 要想根据方向更改布局，您可以定义两种不同的布局，然后对每个布局的目录名称应用相应的限定符。 然后，系统会根据当前设备方向自动应用相应的布局。]]></content>
      <categories>
        <category>guide</category>
      </categories>
      <tags>
        <tag>guide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity的窗口管理机制]]></title>
    <url>%2F2018%2F02%2F25%2FActivity%E7%9A%84%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[上图为Activity的窗口结构图，每一个Activity都包含了一个Window对象，而Window对象通常由PhoneWindow实现。DecorView是一个应用窗口的根容器，它本质上是一个FrameLayout。DecorView有唯一一个子View也就是LinearLayout，包含两个子元素FrameLayout，一个是装载了TitleView（ActionBar的容器），另一个是ContentView（窗口内容的容器）。我们平常用的setContentView就是设置ContentView的子View,内部实现为PhoneWindow中的setContentView()中初始化DecorView后的LayoutInflater.inflate(layoutResID, mContentParent);方法。上图还表达了每个Activity都与一个Window（具体来说是PhoneWindow）相关联，用户界面则由Window所承载。 Activity：与用户交互的可视化组件。 Window：是Activity中的顶级窗口查看和行为的一个抽象基类。该类的实例作为一个顶级View添加到WindowManager。提供了一套标准的UI方法。可以将之理解为一个载体，各种View在这个载体上显示。 PhoneWindow： WIndow的唯一实现类，可以通过该类具体去绘制窗口。 并且，该类内部包含了一个DecorView对象，DectorView对象是所有应用窗口(Activity界面)的根View。 PhoneWindow类是把DecorView对象进行一定的包装，将它作为应用窗口的根View，并提供一组通用的窗口操作接口。 DecorView： DecorView是FrameLayout的子类，它可以被认为是Android视图树的根节点视图。 DecorView作为顶级View，一般情况下它内部包含一个竖直方向的LinearLayout，在这个LinearLayout里面有上下两个部分（具体情况和Android版本及主体有关），上面的是标题栏，下面的是内容栏。 ViewRoot以及ViewRootImpl： ViewRoot对应ViewRootImpl类，它是连接WindowManagerService和DecorView的纽带，View的三大流程（测量measure，布局layout，绘制draw）均通过ViewRoot来完成。 ViewRoot与ViewRootImpl的功能是一样的，只不过是Android不同版本的不同称呼，ViewRoot在Android2.2之后就被ViewRootImpl替换了。 ViewRoot是WindowManagerGlobal工作的实际实现者，它还需要负责与WMS交互通信以调整窗口的位置大小，以及对来自WMS的事件（如窗口尺寸改变等）作出相应的处理。 WindowManager：一个继承自ViewManager的接口。ViewManager定义了三个函数，分别用于添加/删除一个控件，以及更新控件的布局。 ViewManager：该接口的另一个实现者是ViewGroup，它是容器类控件的基类，用于将一组控件容纳到自身的区域中，这一组控件被称为子控件。ViewGroup可以根据子控件的布局参数（LayoutParams）在其自身的区域中对子控件进行布局。 PhoneWindow和DecorView的关系 Activity的setContentView()方法 123456789public void setContentView(@LayoutRes int layoutResID) &#123; /* * 获取Activity中的Window,这里获取到的是在Activity中的attach方法里面吗，通过 * mWindow = new PhoneWindow(this, window, activityConfigCallback);获取需要的Window对象 */ getWindow().setContentView(layoutResID); // 在ActionBarView中创建并初始化Actionbar initWindowDecorActionBar();&#125; PhoneWindow的setContentView()方法 12345678910111213141516171819202122232425262728293031@Overridepublic void setContentView(int layoutResID) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; // 创建DecorView，并添加到mContentParent上 installDecor(); // FEATURE_CONTENT_TRANSITIONS:标记当前内容加载有没有使用过度动画(转场动画)。 // 如果内容已经加载过，并且不需要动画，则会调用removeAllViews。 // 添加完Content后如有设置了FEATURE_CONTENT_TRANSITIONS则添加Scene来过度启动。 // 否则mLayoutInflater.inflate(layoutResID, mContentParent); // 将我们的资源文件通过LayoutInflater对象转换为View树，并且添加至mContentParent视图中。 &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; // Content后如有设置了FEATURE_CONTENT_TRANSITIONS则添加Scene来过度启动 if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,getContext()); transitionTo(newScene); &#125; else &#123; // 将资源文件通过LayoutInflater对象转换为View树,并添加到mContentParent上 mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125; installDecor()创建DecorView 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139private void installDecor() &#123; mForceDecorInstall = false; if (mDecor == null) &#123; // 创建DecorView mDecor = generateDecor(-1); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) &#123; mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); &#125; &#125; else &#123; mDecor.setWindow(this); &#125; // 开始DecorView未加载到mContentParent，所以此时mContentParent=null if (mContentParent == null) &#123; // 将mDecorView添加到Window上绑定布局 mContentParent = generateLayout(mDecor); // Set up decor part of UI to ignore fitsSystemWindows if appropriate. mDecor.makeOptionalFitsSystemWindows(); final DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById( R.id.decor_content_parent); if (decorContentParent != null) &#123; mDecorContentParent = decorContentParent; mDecorContentParent.setWindowCallback(getCallback()); if (mDecorContentParent.getTitle() == null) &#123; mDecorContentParent.setWindowTitle(mTitle); &#125; final int localFeatures = getLocalFeatures(); for (int i = 0; i &lt; FEATURE_MAX; i++) &#123; if ((localFeatures &amp; (1 &lt;&lt; i)) != 0) &#123; mDecorContentParent.initFeature(i); &#125; &#125; mDecorContentParent.setUiOptions(mUiOptions); if ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_ICON) != 0 || (mIconRes != 0 &amp;&amp; !mDecorContentParent.hasIcon())) &#123; mDecorContentParent.setIcon(mIconRes); &#125; else if ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_ICON) == 0 &amp;&amp; mIconRes == 0 &amp;&amp; !mDecorContentParent.hasIcon()) &#123; mDecorContentParent.setIcon( getContext().getPackageManager().getDefaultActivityIcon()); mResourcesSetFlags |= FLAG_RESOURCE_SET_ICON_FALLBACK; &#125; if ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_LOGO) != 0 || (mLogoRes != 0 &amp;&amp; !mDecorContentParent.hasLogo())) &#123; mDecorContentParent.setLogo(mLogoRes); &#125; // Invalidate if the panel menu hasn&apos;t been created before this. // Panel menu invalidation is deferred avoiding application onCreateOptionsMenu // being called in the middle of onCreate or similar. // A pending invalidation will typically be resolved before the posted message // would run normally in order to satisfy instance state restoration. PanelFeatureState st = getPanelState(FEATURE_OPTIONS_PANEL, false); if (!isDestroyed() &amp;&amp; (st == null || st.menu == null) &amp;&amp; !mIsStartingWindow) &#123; invalidatePanelMenu(FEATURE_ACTION_BAR); &#125; &#125; else &#123; mTitleView = findViewById(R.id.title); if (mTitleView != null) &#123; if ((getLocalFeatures() &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) != 0) &#123; final View titleContainer = findViewById(R.id.title_container); if (titleContainer != null) &#123; titleContainer.setVisibility(View.GONE); &#125; else &#123; mTitleView.setVisibility(View.GONE); &#125; mContentParent.setForeground(null); &#125; else &#123; mTitleView.setText(mTitle); &#125; &#125; &#125; if (mDecor.getBackground() == null &amp;&amp; mBackgroundFallbackResource != 0) &#123; mDecor.setBackgroundFallback(mBackgroundFallbackResource); &#125; // Only inflate or create a new TransitionManager if the caller hasn&apos;t // already set a custom one. // 设置转场动画 if (hasFeature(FEATURE_ACTIVITY_TRANSITIONS)) &#123; if (mTransitionManager == null) &#123; final int transitionRes = getWindowStyle().getResourceId( R.styleable.Window_windowContentTransitionManager, 0); if (transitionRes != 0) &#123; final TransitionInflater inflater = TransitionInflater.from(getContext()); mTransitionManager = inflater.inflateTransitionManager(transitionRes, mContentParent); &#125; else &#123; mTransitionManager = new TransitionManager(); &#125; &#125; mEnterTransition = getTransition(mEnterTransition, null, R.styleable.Window_windowEnterTransition); mReturnTransition = getTransition(mReturnTransition, USE_DEFAULT_TRANSITION, R.styleable.Window_windowReturnTransition); mExitTransition = getTransition(mExitTransition, null, R.styleable.Window_windowExitTransition); mReenterTransition = getTransition(mReenterTransition, USE_DEFAULT_TRANSITION, R.styleable.Window_windowReenterTransition); mSharedElementEnterTransition = getTransition(mSharedElementEnterTransition, null, R.styleable.Window_windowSharedElementEnterTransition); mSharedElementReturnTransition = getTransition(mSharedElementReturnTransition, USE_DEFAULT_TRANSITION, R.styleable.Window_windowSharedElementReturnTransition); mSharedElementExitTransition = getTransition(mSharedElementExitTransition, null, R.styleable.Window_windowSharedElementExitTransition); mSharedElementReenterTransition = getTransition(mSharedElementReenterTransition, USE_DEFAULT_TRANSITION, R.styleable.Window_windowSharedElementReenterTransition); if (mAllowEnterTransitionOverlap == null) &#123; mAllowEnterTransitionOverlap = getWindowStyle().getBoolean( R.styleable.Window_windowAllowEnterTransitionOverlap, true); &#125; if (mAllowReturnTransitionOverlap == null) &#123; mAllowReturnTransitionOverlap = getWindowStyle().getBoolean( R.styleable.Window_windowAllowReturnTransitionOverlap, true); &#125; if (mBackgroundFadeDurationMillis &lt; 0) &#123; mBackgroundFadeDurationMillis = getWindowStyle().getInteger( R.styleable.Window_windowTransitionBackgroundFadeDuration, DEFAULT_BACKGROUND_FADE_DURATION_MS); &#125; if (mSharedElementsUseOverlay == null) &#123; mSharedElementsUseOverlay = getWindowStyle().getBoolean( R.styleable.Window_windowSharedElementsUseOverlay, true); &#125; &#125; &#125;&#125; 创建DecorView 123protected DecorView generateDecor() &#123; return new DecorView(getContext(), -1);&#125; 将setContentView的内容赋值到mContentParent generateLayout会根据当前用户设置的主题去设置对应的Feature 根据对应的Feature来选择加载对应的布局文件，(Window.FEATURE_NO_TITLE)接下来通过getLocalFeatures来获取你设置的feature，进而选择加载对应的布局，因此需要在setContentView之前调用requesetFeature 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748protected ViewGroup generateLayout(DecorView decor) &#123; // Apply data from current theme. // 根据当前设置的主题来加载默认布局 TypedArray a = getWindowStyle(); // 如果你在theme中设置了window_windowNoTitle，则这里会调用到，其他方法同理， // 这里是根据你在theme中的设置去设置的 if (a.getBoolean(R.styleable.Window_windowNoTitle, false)) &#123; requestFeature(FEATURE_NO_TITLE); &#125; else if (a.getBoolean(R.styleable.Window_windowActionBar, false)) &#123; // Don&apos;t allow an action bar if there is no title. requestFeature(FEATURE_ACTION_BAR); &#125; // 是否有设置全屏 if (a.getBoolean(R.styleable.Window_windowFullscreen, false)) &#123; setFlags(FLAG_FULLSCREEN, FLAG_FULLSCREEN &amp; (~getForcedWindowFlags())); &#125; ...//省略其他加载资源 /* * 添加布局到DecorView，前面说到，DecorView是继承与FrameLayout，它本身也是一个 * ViewGroup，而我们前面创建它的时候，只是调用了new DecorView，此时里面并无什么东西。而下 * 面的步奏则是根据用户设置的Feature来创建相应的默认布局主题。举个例子，如果我在 * setContentView之前调用了 requestWindowFeature(Window.FEATURE_NO_TITLE)，这里则会通 * 过getLocalFeatures来获取你设置的feature，进而选择加载对应的布局，此时是加载没有标题栏 * 的主题，对应的就是R.layout.screen_simple */ int layoutResource; int features = getLocalFeatures(); // System.out.println(&quot;Features: 0x&quot; + Integer.toHexString(features)); if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) &#123; layoutResource = R.layout.screen_swipe_dismiss; &#125; ... //省略其他判断方法 &#125; else &#123; // Embedded, so no decoration is needed. layoutResource = R.layout.screen_simple; // System.out.println(&quot;Simple!&quot;); &#125; mDecor.startChanging(); // 选择对应布局创建添加到DecorView中 View in = mLayoutInflater.inflate(layoutResource, null); decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); mContentRoot = (ViewGroup) in; ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); ... return contentParent; &#125; 通知界面改变 调用Callback来通知界面发生改变。Callback是Window里面的一个接口，里面声明了当界面更改触摸时调用的各种方法。 而通知改变的回掉方法就是onContentChanged，在PhoneWindow里面并没有看到onContentChanged的实现类，而我们又知道Activity本身又是加载在Window上的，所以如下： 12345public class Activity extends ContextThemeWrapper implements LayoutInflater.Factory2, Window.Callback, KeyEvent.Callback, OnCreateContextMenuListener, ComponentCallbacks2, Window.OnWindowDismissedCallback &#123; ... &#125; Activity里面实现了Window.Callback接口而里面onContentChanged则是空的，因此可以重写改方法来监听布局的改变 12public void onContentChanged() &#123;&#125; DecorView的添加 在Activity的启动过程中会执行ActivityThread#performLaunchActivity方法，其中调用Activity#attach。在attach()方法中实例化Activity持有的mWindow属性为Window的唯一实现类PhoneWindow。 在ActivityThread#handleResumeActivity中，通过wm.addView(decor, l);往 Window 添加 View。 123456789final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123; ... if (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123; a.mWindowAdded = true; wm.addView(decor, l);//往 Window 添加 View。vm为该Activity的WindowManager &#125; ...&#125; WindowManager 是一个接口，因此 addView 的操作是有其子类去实现的，而 WindowManager 的实现类就是 WindowManagerImpl。然而WindowManagerImpl又将其交由WindowManagerGlobal实现。 123456@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); // private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance(); mGlobal.addView(view, params, mDisplay, mParentWindow);&#125; WindowManagerGlobal.addView 的过程 创建ViewRootImpl实例; 在 addView 中创建 Window 对应的 ViewRootImpl 对象。并且往mViews、mRootsmParams、mDyingViews 中保存当前 View 的信息。最后调用 root.setView(view, wparams, panelParentView); 12345678910111213141516171819202122232425262728293031public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; //校验操作 final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; int index = findViewLocked(view, false); if (index &gt;= 0) &#123; if (mDyingViews.contains(view)) &#123; // Don&apos;t wait for MSG_DIE to make it&apos;s way through root&apos;s queue. mRoots.get(index).doDie(); &#125; else &#123; throw new IllegalStateException(&quot;View &quot; + view + &quot; has already been added to the window manager.&quot;); &#125; // The previous removeView() had not completed executing. Now it has. &#125; //创建 ViewRootImpl 对象。 root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); //保存到集合中 mViews.add(view); mRoots.add(root); mParams.add(wparams); &#125; // 调用 View 的绘制代码 root.setView(view, wparams, panelParentView);&#125; DecorView的真正显示 现在 Window 对应的视图已经准备好了，但是仍为不可见的，在ActivityThread#handleResumeActivity 代码。这时会去调用 Activity#makeVisible()方法。ActivityThread#handleResumeActivity中 DecorView 被设置为 invisible 因此在这时Decor 会被设置为 View.VISIBLE。至此 View 就真正的显示出来了。 123456789101112131415// ActivityThread#handleResumeActivityr.activity.mVisibleFromServer = true;if (r.activity.mVisibleFromClient) &#123; r.activity.makeVisible();&#125;// Activity#makeVisible()void makeVisible() &#123; if (!mWindowAdded) &#123;//判断 DecorView 是否被添加到 Window 中 ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; &#125; mDecor.setVisibility(View.VISIBLE);//让 View 设置为可见&#125; View的绘制 View的绘制流程从ViewRoot或ViewRootImpl开始的，经过measure、layout和draw三个过程才能最终绘制一个View。 measure 测量视图的大小的。View系统的绘制流程会从ViewRoot的performTraversals()方法中开始，在其内部调用View的measure()方法。 measure()方法接收两个参数，widthMeasureSpec和heightMeasureSpec，这两个值分别用于确定视图的宽度和高度的规格和大小。widthMeasureSpec和heightMeasureSpec由getRootMeasureSpec(windowSize, rootDimension)方法获得。注意方法中传入的参数，其中lp.width和lp.height在创建ViewGroup实例的时候就被赋值了，它们都等于MATCH_PARENT。 12childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width); childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height); 1234567891011121314151617181920212223242526272829303132/** * Figures out the measure spec for the root view in a window based on it&apos;s * layout params. * * @param windowSize * The available width or height of the window * * @param rootDimension * The layout params for one dimension (width or height) of the * window. * * @return The measure spec to use to measure the root view. */private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123; int measureSpec; switch (rootDimension) &#123; case ViewGroup.LayoutParams.MATCH_PARENT: // Window can&apos;t resize. Force root view to be windowSize. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT: // Window can resize. Set max size for root view. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default: // Window wants to be an exact size. Force root view to be that size. measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; &#125; return measureSpec;&#125; MeasureSpec：由specSize和specMode共同组成的，其中specSize记录的是大小，specMode记录的是规格。specMode一共有三种类型： EXACTLY：表示父视图希望子视图的大小应该是由specSize的值来决定的，系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。 AT_MOST：表父容器指定了一个可用大小即 SpecSize ,子视图最多只能是 specSize 中指定的大小，开发人员应该尽可能小得去设置这个视图，并且保证不会超过specSize。系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。 UNSPECIFIED：表示开发人员可以将视图按照自己的意愿设置成任意的大小，没有任何限制。这种情况比较少见，不太会用到。 measure从父容器传递到子元素中所以 View 的 measure 是由ViewGroup的measureChildWithMargins() 方法传递而来，在该方法中measure子元素之前会通过 getChildMeasureSpec方法来得到子元素的MeasureSpec 。 measureChildWithMargins()： 12345678910111213protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; getChildMeasureSpec()：根据父容器的 MeasureSpec 同时结合 View 本身的 LayoutParams 来确定子元素的 MeasureSpec ，参数中的 padding 是指父容器中已占空间的大小，因此子元素的可用大小位父容器的的尺寸减去 padding。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can&apos;t be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) &#123; // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can&apos;t be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; //noinspection ResourceType return MeasureSpec.makeMeasureSpec(resultSize, resultMode); &#125;]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View之measure源码分析]]></title>
    <url>%2F2018%2F02%2F23%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8Bmeasure%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[measure方法概述 若该view与其父view对于是否使用视觉布局边界的策略不一致，那么将对widthMeasureSpec和heightMeasureSpec进行偏移量校正。 通过widthMeasureSpec和heightMeasureSpec计算出存储在mMeasureCache对象中量算值所需要的key。 判断缓存对象mMeasureCache是否存在，若不存在则创建缓存对象。 判断是否强制测量、与旧值是否相同、是否给定了精确大小、之前测量的到底。宽高与穿进来的宽高是否相同、是否需要重新布局。 在需要强制测量或者需要重新布局情况下，如果缓存中没有值或忽略缓存结果情况下传入值 onMeasure(widthMeasureSpec, heightMeasureSpec)进行测量，测量结束后 重置View的状态mPrivateFlags将其标记为在layout之前不必再进行量算的状态。如果缓存中有值或不忽略缓存结果情况下，获取缓存中的值并 调用setMeasuredDimensionRaw方法将当前量算的结果到成员变量中。 如果自定义的View重写了onMeasure方法，但是没 有调用setMeasuredDimension()方法,那么就会抛出异常。 在量算完成后将这次新传入的MeasureSpec赋值给它们。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** * &lt;p&gt; * This is called to find out how big a view should be. The parent * supplies constraint information in the width and height parameters. * &lt;/p&gt; * * &lt;p&gt; * The actual measurement work of a view is performed in * &#123;@link #onMeasure(int, int)&#125;, called by this method. Therefore, only * &#123;@link #onMeasure(int, int)&#125; can and must be overridden by subclasses. * &lt;/p&gt; * * * @param widthMeasureSpec Horizontal space requirements as imposed by the * parent * @param heightMeasureSpec Vertical space requirements as imposed by the * parent * * @see #onMeasure(int, int) */public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; // 判断是否使用视觉布局边界 boolean optical = isLayoutModeOptical(this); // 如果该view与其父view对于是否使用视觉布局边界的策略不一致 if (optical != isLayoutModeOptical(mParent)) &#123; // Insets实例包含四个整数偏移量，这些偏移量描述了对矩形四个边的更改。 /* * getOpticalInsets()获取偏移量insets，如果该View存在background则调用该background的 * getOpticalInsets()方法获取偏移量，若不存在background则偏移量为Insets.None即为0. */ Insets insets = getOpticalInsets(); int oWidth = insets.left + insets.right; int oHeight = insets.top + insets.bottom; // 该View使用视觉布局边界的话widthMeasureSpec、heightMeasureSpec中的宽和高数值size需减去偏移量 widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth); heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight); &#125; // Suppress sign extension for the low bytes // 计算key值 long key = (long) widthMeasureSpec &lt;&lt; 32 | (long) heightMeasureSpec &amp; 0xffffffffL; // mMeasureCache中缓存着View在不同widthMeasureSpec、heightMeasureSpec下量算过的结果 if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2); // 是否强制测量 final boolean forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT; // Optimize layout by avoiding an extra EXACTLY pass when the view is // already measured as the correct size. In API 23 and below, this // extra pass is required to make LinearLayout re-distribute weight. // 判断是否与旧值是否相同 final boolean specChanged = widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec; // 判断是否给定了精确的大小 final boolean isSpecExactly = MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY &amp;&amp; MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY; // 判断之前设置的measuredWidth、measuredHeight与现在传过来的数值是否相同 final boolean matchesSpecSize = getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec) &amp;&amp; getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec); // 若是需要重新测量、未给定精确度大小、measuredWidth、measuredHeight与现在数值不同则需要重新布局 final boolean needsLayout = specChanged &amp;&amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize); // 如果需要强制测量或者需要重新布局 if (forceLayout || needsLayout) &#123; // first clears the measured dimension flag // 通过按位操作，重置View的状态mPrivateFlags，将其标记为未量算状态 mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET; // 对阿拉伯语、希伯来语等从右到左书写、布局的语言进行特殊处理 resolveRtlPropertiesIfNeeded(); /* 在View真正进行量算之前，View进一步确认能否从已有的缓存mMeasureCache中读取缓存过的量算结果 * 若是强制layout导致的量算，那么将cacheIndex设置为-1，即不从缓存中读取量算结果 * 若不是强制layout导致的量算，那就用上面根据measureSpec计算出来的key值作为缓存索引cacheIndex。 ＊／ int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key); // 是否能找到缓存过的量算结果或者是否忽略缓存结果 if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123; // measure ourselves, this should set the measured dimension flag back // 调用onMeasure方法，并把尺寸限制条件widthMeasureSpec和heightMeasureSpec传入进去 // onMeasure方法中将会进行实际的量算工作，并把量算的结果保存到成员变量中 onMeasure(widthMeasureSpec, heightMeasureSpec); // onMeasure执行完后通过位操作， // 重置View的状态mPrivateFlags将其标记为在layout之前不必再进行量算的状态 mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; else &#123; // 获取缓存中的值 long value = mMeasureCache.valueAt(cacheIndex); // Casting a long to int drops the high 32 bits, no mask needed // 调用setMeasuredDimensionRaw方法将当前量算的结果到成员变量中 setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value); mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; // flag not set, setMeasuredDimension() was not invoked, we raise // an exception to warn the developer /* * 此处检查mPrivateFlags是否含有PFLAG_MEASURED_DIMENSION_SET状态即可判断setMeasuredDimension * 是否被调用，因为setMeasuredDimension()方法中会将mPrivateFlags设置为 * PFLAG_MEASURED_DIMENSION_SET状态，即已量算状态，如果自定义的View重写了onMeasure方法，但是没 * 有调用setMeasuredDimension()方法,那么就会抛出异常 */ if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123; throw new IllegalStateException(&quot;View with id &quot; + getId() + &quot;: &quot; + getClass().getName() + &quot;#onMeasure() did not set the&quot; + &quot; measured dimension by calling&quot; + &quot; setMeasuredDimension()&quot;); &#125; mPrivateFlags |= PFLAG_LAYOUT_REQUIRED; &#125; // mOldWidthMeasureSpec和mOldHeightMeasureSpec保存着最近一次量算时的MeasureSpec， // 在量算完成后将这次新传入的MeasureSpec赋值给它们 mOldWidthMeasureSpec = widthMeasureSpec; mOldHeightMeasureSpec = heightMeasureSpec; // 缓存本次量算的结果，以key作为键，量算结果作为值缓存在变量mMeasureCache中 mMeasureCache.put(key, ((long) mMeasuredWidth) &lt;&lt; 32 | (long) mMeasuredHeight &amp; 0xffffffffL); // suppress sign extension&#125; onMesure方法概述###onMeasure方法 1234protected void onMeasure( int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension( getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; getDefaultSize获取默认宽高123456789101112131415public static int getDefaultSize (int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec. getMode(measureSpec); int specSize = MeasureSpec. getSize(measureSpec); switch (specMode) &#123; case MeasureSpec. UNSPECIFIED: result = size; break; case MeasureSpec. AT_MOST: case MeasureSpec. EXACTLY: result = specSize; break; &#125; return result;&#125; ###为宽度获取建议最小值 12345678protected int getSuggestedMinimumWidth () &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth , mBackground.getMinimumWidth());&#125;public int getMinimumWidth()&#123; final int intrinsicWhidth = getIntrinsicWidtth(); retrun intrinsicWhidth &gt; 0 ? intrinsicWhidth : 0 ;&#125;]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View之布局]]></title>
    <url>%2F2018%2F02%2F10%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8B%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[布局过程 布局过程，就是程序在运行时利用布局文件的代码来计算出实际尺寸的过程。 测量阶段measure()测量的过程 从上到下递归地调用每个 View 或者 ViewGroup 的 measure() 方法，测量他们的尺寸并计算它们的位置； measure() 方法被父 View 调用，在 measure() 中做一些准备和优化工作后，调用 onMeasure() 来进行实际的自我测量。 onMeasure() 在View 和 ViewGroup所进行的操作并不相同： View：View 在 onMeasure() 中会计算出自己的尺寸然后保存； ViewGroup：ViewGroup 在 onMeasure() 中会调用所有子 View 的 measure() 让它们进行自我测量，并根据子 View 计算出的期望尺寸来计算出它们的实际尺寸和位置然后保存。同时，它也会根据子 View 的尺寸和位置来计算出自己的尺寸然后保存； 布局阶段layout() 从上到下递归地调用每个 View 或者 ViewGroup 的 layout() 方法，把测得的它们的尺寸和位置赋值给它们。 layout() 方法被父 View 调用，在 layout() 中它会保存父 View 传进来的自己的位置和尺寸，并且调用 onLayout() 来进行实际的内部布局。onLayout() 在 View 和 ViewGroup所进行的操作并不相同： View：由于没有子 View，所以 View 的 onLayout() 什么也不做。 ViewGroup：ViewGroup 在 onLayout() 中会调用自己的所有子 View 的 layout() 方法，把它们的尺寸和位置传给它们，让它们完成自我的内部布局。 自定义布局的方式重写 onMeasure() 来修改已有的 View 的尺寸 重写 onMeasure() 方法，并在里面调用 super.onMeasure()，触发原有的自我测量； 在 super.onMeasure() 的下面用 getMeasuredWidth() 和 getMeasuredHeight() 来获取到之前的测量结果，并使用自己的算法，根据测量结果计算出新的结果； 调用 setMeasuredDimension() 来保存新的结果。 重写 onMeasure() 来全新定制自定义 View 的尺寸父 View 的尺寸限制 由来：开发者的要求（布局文件中 layout_ 打头的属性）经过父 View 处理计算后的更精确的要求； 限制的分类： UNSPECIFIED：不限制 AT_MOST：限制上限 EXACTLY：限制固定值 自定义方式 重新 onMeasure()，并计算出 View 的尺寸； 使用 resolveSize() 来让子 View 的计算结果符合父 View 的限制（如果想用自己的方式来满足父 View 的限制也行）。 重写 onMeasure() 和 onLayout() 来全新定制自定义 ViewGroup 的内部布局定制 Layout 内部布局的方式 重写 onMeasure() 来计算内部布局 重写 onLayout() 来摆放子 View 重写 onMeasure() 的三个步骤 调用每个子 View 的 measure() 来计算子 View 的尺寸 计算子 View 的位置并保存子 View 的位置和尺寸 计算自己的尺寸并用 setMeasuredDimension() 保存 计算子 View 尺寸的关键计算子 View 的尺寸，关键在于 measure() 方法的两个参数——也就是子 View 的两个 MeasureSpec 的计算。 子 View 的 MeasureSpec 的计算方式： 结合开发者的要求（xml 中 layout_ 打头的属性）和自己的可用空间（自己的尺寸上限 - 已用尺寸） 尺寸上限根据自己的 MeasureSpec 中的 mode 而定 EXACTLY / AT_MOST：尺寸上限为 MeasureSpec 中的 size UNSPECIFIED：尺寸无上限 重写 onLayout() 的方式在 onLayout() 里调用每个子 View 的 layout() ，让它们保存自己的位置和尺寸。]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View之硬件加速]]></title>
    <url>%2F2018%2F02%2F09%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8B%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%2F</url>
    <content type="text"><![CDATA[本质和原理概念 所谓硬件加速，指的是把某些计算工作交给专门的硬件来做，而不是和普通的计算工作一样交给 CPU 来处理。这样不仅减轻了 CPU 的压力，而且由于有了「专人」的处理，这份计算工作的速度也被加快了。这就是「硬件加速」。 对于 Android 来说，硬件加速有它专属的意思：在 Android 里，硬件加速专指把 View 中绘制的计算工作交给 GPU 来处理。进一步地再明确一下，这个「绘制的计算工作」指的就是把绘制方法中的那些 Canvas.drawXXX() 变成实际的像素这件事。 原理 未开启硬件加速：Canvas 绘制的工作方式是：把要绘制的内容写进一个 Bitmap，然后在之后的渲染过程中，这个 Bitmap 的像素内容被直接用于渲染到屏幕。这种绘制方式的主要计算工作在于把绘制操作转换为像素的过程（例如由一句 Canvas.drawCircle() 来获得一个具体的圆的像素信息），这个过程的计算是由 CPU 来完成的，过程如下图： 开启硬件加速：只是把绘制的内容转换为 GPU 的操作保存了下来，然后就把它交给 GPU，最终由 GPU 来完成实际的显示工作。过程如下图： Android中的应用 硬件加速开启后，绘制的计算工作由 CPU 转交给了 GPU。那么硬件加速能够让绘制变快，主要有三个原因： 本来由 CPU 自己来做的事，分摊给了 GPU 一部分，自然可以提高效率； 相对于 CPU 来说，GPU 自身的设计本来就对于很多常见类型内容的计算（例如简单的圆形、简单的方形）具有优势； 由于绘制流程的不同，硬件加速在界面内容发生重绘的时候绘制流程可以得到优化，避免了一些重复操作，从而大幅提升绘制效率。 硬件加速绘制变快的机制： 在硬件加速关闭时，绘制内容会被 CPU 转换成实际的像素，然后直接渲染到屏幕。具体来说，这个「实际的像素」，它是由 Bitmap 来承载的。在界面中的某个 View 由于内容发生改变而调用 invalidate() 方法时，如果没有开启硬件加速，那么为了正确计算 Bitmap 的像素，这个 View 的父 View、父 View 的父 View 乃至一直向上直到最顶级 View，以及所有和它相交的兄弟 View，都需要被调用 invalidate()来重绘。一个 View 的改变使得大半个界面甚至整个界面都重绘一遍，这个工作量是非常大的。 而在硬件加速开启时，绘制的内容会被转换成 GPU 的操作保存下来（承载的形式称为 display list，对应的类也叫做 DisplayList），再转交给 GPU。由于所有的绘制内容都没有变成最终的像素，所以它们之间是相互独立的，那么在界面内容发生改变的时候，只要把发生了改变的 View 调用 invalidate()方法以更新它所对应的 GPU 操作就好，至于它的父 View 和兄弟 View，只需要保持原样。那么这个工作量就很小了。 限制 受到 GPU 绘制方式的限制，Canvas 的有些方法在硬件加速开启式会失效或无法正常工作。比如，在硬件加速开启时， clipPath() 在 API 18 及以上的系统中才有效。具体的 API 限制和 API 版本的关系如下图： View Layer 关闭硬件加速：view.setLayerType(LAYER_TYPE_SOFTWARE, null); setLayerType() 方法本来作用并不是用来开关硬件加速的，只是当它的参数为 LAYER_TYPE_SOFTWARE 的时候，可以「顺便」把硬件加速关掉而已；并且除了这个方法之外，Android 并没有提供专门的 View 级别的硬件加速开关，所以它就「顺便」成了一个开关硬件加速的方法。 View Layer，又称为离屏缓冲（Off-screen Buffer），它的作用是单独启用一块地方来绘制这个 View ，而不是使用软件绘制的 Bitmap 或者通过硬件加速的 GPU。这块「地方」可能是一块单独的 Bitmap，也可能是一块 OpenGL 的纹理（texture，OpenGL 的纹理可以简单理解为图像的意思），具体取决于硬件加速是否开启。采用什么来绘制 View 不是关键，关键在于当设置了 View Layer 的时候，它的绘制会被缓存下来，而且缓存的是最终的绘制结果，而不是像硬件加速那样只是把 GPU 的操作保存下来再交给 GPU 去计算。通过这样更进一步的缓存方式，View 的重绘效率进一步提高了：只要绘制的内容没有变，那么不论是 CPU 绘制还是 GPU 绘制，它们都不用重新计算，而只要只用之前缓存的绘制结果就可以了。基于这样的原理，在进行移动、旋转等（无需调用 invalidate()）的属性动画的时候开启 Hardware Layer 将会极大地提升动画的效率，因为在动画过程中 View 本身并没有发生改变，只是它的位置或角度改变了，而这种改变是可以由 GPU 通过简单计算就完成的，并不需要重绘整个 View。所以在这种动画的过程中开启 Hardware Layer，可以让本来就依靠硬件加速而变流畅了的动画变得更加流畅。实现方式大概是这样： 123456789101112131415view.setLayerType(LAYER_TYPE_HARDWARE, null); ObjectAnimator animator = ObjectAnimator.ofFloat(view, &quot;rotationY&quot;, 180);animator.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; view.setLayerType(LAYER_TYPE_NONE, null); &#125;&#125;);animator.start(); // 或者如果是使用 ViewPropertyAnimator，那么更简单：view.animate() .rotationY(90) .withLayer(); // withLayer() 可以自动完成上面这段代码的复杂操作 注意： 这种方式不适用于基于自定义属性绘制的动画 除了用于关闭硬件加速和辅助属性动画这两项功能外，Layer 还可以用于给 View 增加一些绘制效果，例如设置一个 ColorMatrixColorFilter 来让 View 变成黑白的： 1234567ColorMatrix colorMatrix = new ColorMatrix(); colorMatrix.setSaturation(0);Paint paint = new Paint(); paint.setColorFilter(new ColorMatrixColorFilter(colorMatrix));view.setLayerType(LAYER_TYPE_HARDWARE, paint); 由于设置了 View Layer 后，View 在初次绘制时以及每次 invalidate() 后重绘时，需要进行两次的绘制工作（一次绘制到 Layer，一次从 Layer 绘制到显示屏），所以其实它的每次绘制的效率是被降低了的。所以一定要慎重使用 View Layer，在需要用到它的时候再去使用。 总结 硬件加速指的是使用 GPU 来完成绘制的计算工作，代替 CPU。它从工作分摊和绘制机制优化这两个角度提升了绘制的速度。 硬件加速可以使用 setLayerType() 来关闭硬件加速，但这个方法其实是用来设置 View Layer 的： 参数为 LAYER_TYPE_SOFTWARE 时，使用软件来绘制 View Layer，绘制到一个 Bitmap，并顺便关闭硬件加速； 参数为 LAYER_TYPE_HARDWARE 时，使用 GPU 来绘制 View Layer，绘制到一个 OpenGL texture（如果硬件加速关闭，那么行为和 VIEW_TYPE_SOFTWARE 一致）； 参数为 LAYER_TYPE_NONE 时，关闭 View Layer。 View Layer 可以加速无 invalidate() 时的刷新效率，但对于需要调用 invalidate() 的刷新无法加速。 View Layer 绘制所消耗的实际时间是比不使用 View Layer 时要高的，所以要慎重使用。]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定View之属性动画]]></title>
    <url>%2F2018%2F02%2F07%2F%E8%87%AA%E5%AE%9AView%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[ViewPropertyAnimator View 的每个方法都对应了 ViewPropertyAnimator 的两个方法，其中一个是带有 -By 后缀的，例如，View.setTranslationX() 对应了 ViewPropertyAnimator.translationX() 和 ViewPropertyAnimator.translationXBy() 这两个方法。其中带有 -By() 后缀的是增量版本的方法，例如，translationX(100) 表示用动画把 View 的 translationX 值渐变为 100，而 translationXBy(100) 则表示用动画把 View 的 translationX 值渐变地增加 100 ViewPropertyAnimator介绍 专门针对View对象动画而操作的类。 支持链式操作，提供了更简洁调用设置多个属性动画方式，这些动画可以同时进行的。 拥有更好的性能，多个属性动画是一次同时变化，只执行一次UI刷新（也就是只调用一次invalidate,而n个ObjectAnimator就会进行n次属性变化，就有n次invalidate）。 每个属性提供两种类型方法设置。 该类只能通过View的animate()获取其实例对象的引用 ViewPropertyAnimator使用方式1234view.animate() .scaleX(1) .scaleY(1) .alpha(1); View.animate()之后配合下图种的translationX()、translationY()、rotation()、alpha()等方法。 ObjectAnimator使用方法： 如果是自定义控件，需要添加 setter / getter 方法，setter方法中需要在修改属性的值之后主动的通知界面重绘，也就是使用invalidate()方法，它会把之前绘制的内容标记位失效，在下一帧到来时View不会延用上一帧的内容，而是会自动调用draw()方法来重新绘制内容，这样才会刷新内容； 用 ObjectAnimator.ofXXX(目标对象,属性名,目标值 ) 创建 ObjectAnimator 对象，它会根据填写的属性名拼接成相应的setxx方法； 用 start() 方法执行动画。 1public class ProgressView extends View &#123; float progress = 0; Paint paint = new Paint(); RectF acres = new RectF(); public void setProgress(float progress){ this.progress = progress; invalidate(); } public float getProgress() { return progress; } public ProgressView(Context context) { super(context); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); paint.setColor(Color.parseColor(&quot;#FFFFFFF&quot;)); canvas.drawArc(acres, 135, progress * 2.7f, false, paint); } /** * ObjectAnimator mObjectAnimator = ObjectAnimator.ofFloat(this,&quot;progress&quot;,0,65); * mObjectAnimator.start(); */ } 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768### 通用功能：- setDuration(int duration) 设置动画时长- setInterpolator(Interpolator interpolator) 设置 Interpolator（设置插值器）### 插值器Interpolator：&gt; 根据时动画的时间完成度计算所对应的动画完成程度，可以说是一个速度设置器- **匀速**：LinearInterpolator；- **持续加速**：AccelerateInterpolator，主要用在离场效果中，比如某个物体从界面中飞离，就可以用这种效果。它给人的感觉就会是「从零起步，加速飞走了」。到了最后动画骤停的时候，物体已经飞出用户视野，看不到了，所以并不会察觉到这个骤停的；- **持续减速直到 0**：DecelerateInterpolator，主要用于入场效果，比如某个物体从界面的外部飞入界面后停在某处；- **蓄力**：AnticipateInterpolator先回拉一下再进行正常动画轨迹。效果看起来有点像投掷物体或跳跃等动作前的蓄力。平移动画，那么就是位置上的回拉；如果是放大动画，那么就是先缩小一下再放大；其他类型的动画同理；- **回弹**：OvershootInterpolator，动画会超过目标值一些，然后再弹回来；- **蓄力+回弹**：AnticipateOvershootInterpolator；- **正/余弦曲线**：CycleInterpolator可以自定义曲线的周期，所以动画可以不到终点就结束，也可以到达终点后回弹，回弹的次数由曲线的周期决定，曲线的周期由 `CycleInterpolator()` 构造方法的参数决定；- **自定义动画完成度 / 时间完成度曲线**：PathInterpolator，定制的方式是使用一个 `Path` 对象来绘制出你要的动画完成度 / 时间完成度曲线；- **贝塞尔加速**：FastOutLinearInInterpolator，和`AccelerateInterpolator` 一样，都是一个持续加速的运动路线。只不过 `FastOutLinearInInterpolator` 的曲线公式是用的贝塞尔曲线，而 `AccelerateInterpolator` 用的是指数曲线。具体来说，它俩最主要的区别是 `FastOutLinearInInterpolator` 的初始阶段加速度比 `AccelerateInterpolator` 要快一些； ![加速的AccelerateInterpolator与FastOutLinearInInterpolator的速度模型图](http://ouv36g1sw.bkt.clouddn.com/%E5%8A%A0%E9%80%9F%E7%9A%84AccelerateInterpolator%E4%B8%8EFastOutLinearInInterpolator%E7%9A%84%E9%80%9F%E5%BA%A6%E6%A8%A1%E5%9E%8B%E5%9B%BE)- **贝塞尔先加速再减速**：FastOutSlowInInterpolator，同样也是先加速再减速的还有前面说过的 `AccelerateDecelerateInterpolator`，不过它们的效果是明显不一样的。`FastOutSlowInInterpolator` 用的是贝塞尔曲线，`AccelerateDecelerateInterpolator` 用的是正弦 / 余弦曲线。具体来讲， `FastOutSlowInInterpolator` 的前期加速度要**快得多**。 ![先加速在减速的AccelerateDecelerateInterpolator与FastOutSlowInInterpolator速度模型图](http://ouv36g1sw.bkt.clouddn.com/%E5%85%88%E5%8A%A0%E9%80%9F%E5%9C%A8%E5%87%8F%E9%80%9F%E7%9A%84AccelerateDecelerateInterpolator%E4%B8%8EFastOutSlowInInterpolator%E9%80%9F%E5%BA%A6%E6%A8%A1%E5%9E%8B%E5%9B%BE)- **贝塞尔持续减速**：LinearOutSlowInInterpolator，和 `DecelerateInterpolator` 比起来，同为减速曲线，主要区别在于 `LinearOutSlowInInterpolator` 的初始速度更高。对于人眼的实际感觉，区别其实也不大，不过还是能看出来一些的。 ![持续减速的DecelerateInterpolator与LinearOutSlowInInterpolator的速度模型图](http://ouv36g1sw.bkt.clouddn.com/%E6%8C%81%E7%BB%AD%E5%87%8F%E9%80%9F%E7%9A%84DecelerateInterpolator%E4%B8%8ELinearOutSlowInInterpolator%E7%9A%84%E9%80%9F%E5%BA%A6%E6%A8%A1%E5%9E%8B%E5%9B%BE)### 设置监听器&gt; 给动画设置监听器，可以在关键时刻得到反馈，从而做出适合的操作- ViewPropertyAnimator.setListener() / ObjectAnimator.addListener() - 动画开始时回掉：` onAnimationStart(Animator animation)` - 动画结束时回掉：` onAnimationEnd(Animator animation)` - 动画取消时回掉：` onAnimationCancel(Animator animation)` - 动画重复执行是回掉：`onAnimationRepeat(Animator animation)`当动画通过 `setRepeatMode()` / `setRepeatCount()` 或 `repeat()` 方法重复执行时，这个方法被调用。由于 `ViewPropertyAnimator` 不支持重复，所以这个方法对 `ViewPropertyAnimator` 相当于无效。- ViewPropertyAnimator.setUpdateListener() / ObjectAnimator.addUpdateListener() - 和 上面的两个方法一样，这两个方法虽然名称和可设置的监听器数量不一样，但本质其实都一样的，它们的参数都是 `AnimatorUpdateListener`。但是它只有一个回调方法：`onAnimationUpdate(ValueAnimator animation)` - 当动画的属性更新时回掉：`onAnimationUpdate(ValueAnimator animation)`，方法的参数是一个 `ValueAnimator`，`ValueAnimator` 是 `ObjectAnimator` 的父类，也是 `ViewPropertyAnimator` 的内部实现，所以这个参数其实就是 `ViewPropertyAnimator` 内部的那个 `ValueAnimator`，或者对于 `ObjectAnimator` 来说就是它自己本身。- ObjectAnimator.addPauseListener()- ViewPropertyAnimator.withStartAction/EndAction() 这两个方法是 `ViewPropertyAnimator` 的独有方法。它们和 `set/addListener()` 中回调的 `onAnimationStart()` / `onAnimationEnd()` 相比起来的不同主要有两点： - `withStartAction()` / `withEndAction()` 是一次性的，在动画执行结束后就自动弃掉了，就算之后再重用 `ViewPropertyAnimator` 来做别的动画，用它们设置的回调也不会再被调用。而 `set/addListener()` 所设置的 `AnimatorListener` 是持续有效的，当动画重复执行时，回调总会被调用。 - `withEndAction()` 设置的回调只有在动画正常结束时才会被调用，而在动画被取消时不会被执行。这点和 `AnimatorListener.onAnimationEnd()` 的行为是不一致的。### 估值器TypeEvaluator&gt; 对指定的某个类型的参数设定一个算法来计算动画完成度与参数的关系&gt;&gt; 估值器用来确定在动画过程中每时每刻动画的执行程度值，从动画完成度转变为实际属性值。 public interface TypeEvaluator { /** * @param fraction The fraction from the starting to the ending values * 表示当前这段数值变化值得比例 * @param startValue The start value. 表示当前这段数值变化的开始值 * @param endValue The end value. 表示当前这段数据变化的结束值 * @return A linear interpolation between the start and end values, given the * &lt;code&gt;fraction&lt;/code&gt; parameter. 返回插值器 */ public T evaluate(float fraction, T startValue, T endValue); } 123456789101112#### 类型- ArgbEvaluator：可用于执行表示ARGB颜色的整数值之间的类型插值- FloatArrayEvaluator- FloatEvaluator- IntArrayEvaluator- IntEvaluator- PointFEvaluator- RectEvaluator#### 自定义 Evaluator // 自定义 HslEvaluatorprivate class HsvEvaluator implements TypeEvaluator { float[] startHsv = new float[3]; float[] endHsv = new float[3]; float[] outHsv = new float[3]; @Override public Integer evaluate(float fraction, Integer startValue, Integer endValue) { // 把 ARGB 转换成 HSV Color.colorToHSV(startValue, startHsv); Color.colorToHSV(endValue, endHsv); // 计算当前动画完成度（fraction）所对应的颜色值 if (endHsv[0] - startHsv[0] &gt; 180) { endHsv[0] -= 360; } else if (endHsv[0] - startHsv[0] &lt; -180) { endHsv[0] += 360; } outHsv[0] = startHsv[0] + (endHsv[0] - startHsv[0]) * fraction; if (outHsv[0] &gt; 360) { outHsv[0] -= 360; } else if (outHsv[0] &lt; 0) { outHsv[0] += 360; } outHsv[1] = startHsv[1] + (endHsv[1] - startHsv[1]) * fraction; outHsv[2] = startHsv[2] + (endHsv[2] - startHsv[2]) * fraction; // 计算当前动画完成度（fraction）所对应的透明度 int alpha = startValue &gt;&gt; 24 + (int) ((endValue &gt;&gt; 24 - startValue &gt;&gt; 24) * fraction); // 把 HSV 转换回 ARGB 返回 return Color.HSVToColor(alpha, outHsv); }} ObjectAnimator animator = ObjectAnimator.ofInt(view, “color”, 0xff00ff00);// 使用自定义的 HslEvaluatoranimator.setEvaluator(new HsvEvaluator());animator.start();1234567### PropertyValuesHolder 同一个动画中改变多个属性- PropertyValuesHolder：它是一个属性值的批量存放地，如果有多个属性需要修改，可以把它们放在不同的 `PropertyValuesHolder` 中，然后使用 `ofPropertyValuesHolder()` 统一放进 `Animator`。这样你就不用为每个属性单独创建一个 `Animator` 分别执行了。- 可能同一个动画中会需要改变多个属性，例如在改变透明度的同时改变尺寸。如果使用 `ViewPropertyAnimator`，可以直接用连写的方式来在一个动画中同时改变多个属性，但是对于ObjectAnimator无法这么使用，但是可以依靠 `PropertyValuesHolder` 来同时在一个动画中改变多个属性。这些属性如果放在同一个动画中，需要共享动画的开始时间、结束时间、Interpolator 等等一系列的设定。 PropertyValuesHolder holder1 = PropertyValuesHolder.ofFloat(“scaleX”, 1);PropertyValuesHolder holder2 = PropertyValuesHolder.ofFloat(“scaleY”, 1);PropertyValuesHolder holder3 = PropertyValuesHolder.ofFloat(“alpha”, 1); ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(view, holder1, holder2, holder3)animator.start();1234### AnimatorSet多个动画配合执行- 有时候需要在一个动画中改变多个属性，还会需要多个动画配合工作，比如，在内容的大小从 0 放大到 100% 大小后开始移动。 ObjectAnimator animator1 = ObjectAnimator.ofFloat(…);animator1.setInterpolator(new LinearInterpolator());ObjectAnimator animator2 = ObjectAnimator.ofInt(…);animator2.setInterpolator(new DecelerateInterpolator());AnimatorSet animatorSet = new AnimatorSet();// 两个动画依次执行animatorSet.playSequentially(animator1, animator2);animatorSet.start(); // 或者// 使用 AnimatorSet.play(animatorA).with/before/after(animatorB)// 的方式来精确配置各个 Animator 之间的关系animatorSet.play(animator1).with(animator2);animatorSet.play(animator1).before(animator2);animatorSet.play(animator1).after(animator2);animatorSet.start();1234### PropertyValuesHolders.ofKeyframe() 把同一个属性拆分- 除了合并多个属性和调配多个动画，还可以在 `PropertyValuesHolder` 的基础上更进一步，通过设置 `Keyframe` （关键帧），把同一个动画属性拆分成多个阶段。例如，你可以让一个进度增加到 100% 后再「反弹」回来。 // 在 0% 处开始Keyframe keyframe1 = Keyframe.ofFloat(0, 0);// 时间经过 50% 的时候，动画完成度 100%Keyframe keyframe2 = Keyframe.ofFloat(0.5f, 100);// 时间见过 100% 的时候，动画完成度倒退到 80%，即反弹 20%Keyframe keyframe3 = Keyframe.ofFloat(1, 80);PropertyValuesHolder holder = PropertyValuesHolder.ofKeyframe(“progress”, keyframe1, keyframe2, keyframe3); ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(view, holder);animator.start();123456## ValueAnimator&gt; 除了 ViewPropertyAnimator 和 ObjectAnimator，还有第三个选择是 ValueAnimator。ValueAnimator 并不常用，因为它的功能太基础了。ValueAnimator 是 ObjectAnimator 的父类，实际上，ValueAnimator 就是一个不能指定目标对象版本的 ObjectAnimator。ObjectAnimator 是自动调用目标对象的 setter 方法来更新目标属性的值，以及很多的时候还会以此来改变目标对象的 UI，而 ValueAnimator 只是通过渐变的方式来改变一个独立的数据，这个数据不是属于某个对象的，至于在数据更新后要做什么事，全都由你来定，你可以依然是去调用某个对象的 setter 方法（别这么为难自己），也可以做其他的事，不管要做什么，都是要你自己来写的，ValueAnimator 不会帮你做。功能最少、最不方便，但有时也是束缚最少、最灵活。比如有的时候，你要给一个第三方控件做动画，你需要更新的那个属性没有 setter 方法，只能直接修改，这样的话 ObjectAnimator 就不灵了啊。怎么办？这个时候你就可以用 ValueAnimator，在它的 onUpdate() 里面更新这个属性的值，并且手动调用 invalidate()。&gt;&gt; 所以，ViewPropertyAnimator、ObjectAnimator、ValueAnimator 这三种 Animator，它们其实是一种递进的关系：从左到右依次变得更加难用，也更加灵活。但我要说明一下，它们的性能是一样的，因为 ViewPropertyAnimator 和 ObjectAnimator 的内部实现其实都是 ValueAnimator，ObjectAnimator 更是本来就是 ValueAnimator 的子类，它们三个的性能并没有差别。它们的差别只是使用的便捷性以及功能的灵活性。所以在实际使用时候的选择，只要遵循一个原则就行：尽量用简单的。能用 View.animate() 实现就不用 ObjectAnimator，能用 ObjectAnimator 就不用 ValueAnimator。]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定View之绘制顺序]]></title>
    <url>%2F2018%2F02%2F07%2F%E8%87%AA%E5%AE%9AView%E4%B9%8B%E7%BB%98%E5%88%B6%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[super.onDraw() 前 or 后？ View 这个类中，onDraw() 是空实现，但是基于已有控件的自定义绘制，就不能不考虑 super.onDraw() 了：你需要根据自己的需求，判断出你绘制的内容需要盖住控件原有的内容还是需要被控件原有的内容盖住，从而确定你的绘制代码是应该写在 super.onDraw() 的上面还是下面。 写在 super.onDraw() 的下面 把绘制代码写在 super.onDraw() 的下面，由于绘制代码会在原有内容绘制结束之后才执行，所以绘制内容就会盖住控件原来的内容。 写在 super.onDraw() 的上面 如果把绘制代码写在 super.onDraw() 的上面，由于绘制代码会执行在原有内容的绘制之前，所以绘制的内容会被控件的原内容盖住。 dispatchDraw()：绘制子 View 的方法 Android 的绘制顺序：在绘制过程中，每一个 ViewGroup 会先调用自己的 onDraw()来绘制完自己的主体之后再去绘制它的子 View。对于上面这个例子来说，就是你的 LinearLayout 会在绘制完斑点后再去绘制它的子 View。那么在子 View 绘制完成之后，先前绘制的斑点就被子 View 盖住了。 「绘制子 View」是通过另一个绘制方法的调用来发生的，这个绘制方法叫做：dispatchDraw()。也就是说，在绘制过程中，每个 View 和 ViewGroup 都会先调用 onDraw() 方法来绘制主体，再调用 dispatchDraw() 方法来绘制子 View。注：虽然 View 和 ViewGroup 都有 dispatchDraw() 方法，不过由于 View 是没有子 View 的，所以一般来说 dispatchDraw() 这个方法只对 ViewGroup（以及它的子类）有意义。 写在 super.dispatchDraw() 的下面 只要重写 dispatchDraw()，并在 super.dispatchDraw() 的下面写上你的绘制代码，这段绘制代码就会发生在子 View 的绘制之后，从而让绘制内容盖住子 View 了。 写在 super.dispatchDraw() 的上面 把绘制代码写在 super.dispatchDraw() 的上面，这段绘制就会在 onDraw() 之后、 super.dispatchDraw() 之前发生，也就是绘制内容会出现在主体内容和子 View 之间 绘制过程简述 个完整的绘制过程会依次绘制以下几个内容： 背景（drawBackground()） 主体（onDraw()） 子 View（dispatchDraw()） 滑动边缘渐变和滑动条 前景 关于绘制方法，有两点需要注意一下： 出于效率的考虑，ViewGroup 默认会绕过 draw() 方法，换而直接执行 dispatchDraw()，以此来简化绘制流程。所以如果你自定义了某个 ViewGroup 的子类（比如 LinearLayout）并且需要在它的除 dispatchDraw() 以外的任何一个绘制方法内绘制内容，可能会需要调用 View.setWillNotDraw(false)这行代码来切换到完整的绘制流程（是「可能」而不是「必须」的原因是，有些 ViewGroup 是已经调用过 setWillNotDraw(false) 了的，例如 ScrollView）。 有的时候，一段绘制代码写在不同的绘制方法中效果是一样的，这时你可以选一个自己喜欢或者习惯的绘制方法来重写。但有一个例外：如果绘制代码既可以写在 onDraw() 里，也可以写在其他绘制方法里，那么优先写在 onDraw() ，因为 Android 有相关的优化，可以在不需要重绘的时候自动跳过 onDraw() 的重复执行，以提升开发效率。享受这种优化的只有 onDraw() 一个方法。]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定View之Canvas对绘制的辅助]]></title>
    <url>%2F2018%2F02%2F07%2F%E8%87%AA%E5%AE%9AView%E4%B9%8BCanvas%E5%AF%B9%E7%BB%98%E5%88%B6%E7%9A%84%E8%BE%85%E5%8A%A9%2F</url>
    <content type="text"><![CDATA[范围剪裁 范围裁切有两个方法： clipRect() 和 clipPath()。裁切方法之后的绘制代码，都会被限制在裁切范围内。 clipRect()1234canvas.save(); canvas.clipRect(left, top, right, bottom); canvas.drawBitmap(bitmap, x, y, paint); canvas.restore(); clipPath()123456789canvas.save(); canvas.clipPath(path1); canvas.drawBitmap(bitmap, point1.x, point1.y, paint); canvas.restore();canvas.save(); canvas.clipPath(path2); canvas.drawBitmap(bitmap, point2.x, point2.y, paint); canvas.restore(); 几何变换 几何变换的使用大概分为三类： 使用 Canvas 来做常见的二维变换； 使用 Matrix 来做常见和不常见的二维变换； 使用 Camera 来做三维变换。 使用 Canvas 来做常见的二维变换平移 Canvas.translate(float dx, float dy) 参数里的 dx 和 dy 表示横向和纵向的位移。 12345&gt; canvas.save(); &gt; canvas.translate(200, 0); &gt; canvas.drawBitmap(bitmap, x, y, paint); &gt; canvas.restore(); &gt; 移动 Canvas.translate(float x, float y, float z) 旋转 Canvas.rotate(float degrees, float px, float py) 参数里的 degrees 是旋转角度，单位是度（也就是一周有 360° 的那个单位），方向是顺时针为正向； px和 py 是轴心的位置。 缩放 Canvas.scale(float sx, float sy, float px, float py) 参数里的 sx sy 是横向和纵向的放缩倍数； px py 是放缩的轴心。 12345&gt; canvas.save(); &gt; canvas.scale(1.3f, 1.3f, x + bitmapWidth / 2, y + bitmapHeight / 2); &gt; canvas.drawBitmap(bitmap, x, y, paint); &gt; canvas.restore(); &gt; 错切 skew(float sx, float sy) 参数里的 sx 和 sy 是 x 方向和 y 方向的错切系数。 12345&gt; canvas.save(); &gt; canvas.skew(0, 0.5f); &gt; canvas.drawBitmap(bitmap, x, y, paint); &gt; canvas.restore(); &gt; 使用 Matrix 来做变换使用 Matrix 来做常见变换 Matrix 做常见变换的方式： 创建 Matrix 对象； 调用 Matrix 的 pre/postTranslate/Rotate/Scale/Skew() 方法来设置几何变换； 使用 Canvas.setMatrix(matrix) 或 Canvas.concat(matrix) 来把几何变换应用到 Canvas。 123456789101112Matrix matrix = new Matrix();...matrix.reset(); matrix.postTranslate(); matrix.postRotate();canvas.save(); canvas.concat(matrix); canvas.drawBitmap(bitmap, x, y, paint); canvas.restore(); 把 Matrix 应用到 Canvas 有两个方法： Canvas.setMatrix(matrix) 和 Canvas.concat(matrix)。 Canvas.setMatrix(matrix)：用 Matrix 直接替换 Canvas 当前的变换矩阵，即抛弃 Canvas 当前的变换，改用 Matrix 的变换（注：根据下面评论里以及我在微信公众号中收到的反馈，不同的系统中 setMatrix(matrix) 的行为可能不一致，所以还是尽量用 concat(matrix) 吧）； Canvas.concat(matrix)：用 Canvas 当前的变换矩阵和 Matrix 相乘，即基于 Canvas 当前的变换，叠加上 Matrix 中的变换。 使用 Matrix 来做自定义变换 Matrix 的自定义变换使用的是 setPolyToPoly() 方法。 用点对点映射的方式设置变换 Matrix.setPolyToPoly(float[] src, int srcIndex, float[] dst, int dstIndex, int pointCount) poly 就是「多」的意思。setPolyToPoly() 的作用是通过多点的映射的方式来直接设置变换。「多点映射」的意思就是把指定的点移动到给出的位置，从而发生形变。例如：(0, 0) -&gt; (100, 100) 表示把 (0, 0) 位置的像素移动到 (100, 100) 的位置，这个是单点的映射，单点映射可以实现平移。而多点的映射，就可以让绘制内容任意地扭曲。 参数里，src 和 dst 是源点集合目标点集；srcIndex 和 dstIndex 是第一个点的偏移；pointCount 是采集的点的个数（个数不能大于 4，因为大于 4 个点就无法计算变换了）。 12345678910111213Matrix matrix = new Matrix(); float pointsSrc = &#123;left, top, right, top, left, bottom, right, bottom&#125;; float pointsDst = &#123;left - 10, top + 50, right + 120, top - 90, left + 20, bottom + 30, right + 20, bottom + 60&#125;;...matrix.reset(); matrix.setPolyToPoly(pointsSrc, 0, pointsDst, 0, 4);canvas.save(); canvas.concat(matrix); canvas.drawBitmap(bitmap, x, y, paint); canvas.restore(); ​ 使用 Camera 来做三维变换 Camera 的三维变换有三类：旋转、平移、移动相机。 三维旋转 Camera.rotate() `Camera.rotate()一共有四个方法：rotateX(deg)rotateY(deg)rotateZ(deg)rotate(x, y, z) Camera 和 Canvas 一样也需要保存和恢复状态才能正常绘制，不然在界面刷新之后绘制就会出现问题。 如果你需要图形左右对称，需要配合上 Canvas.translate()，在三维旋转之前把绘制内容的中心点移动到原点，即旋转的轴心，然后在三维旋转后再把投影移动回来： 1234567891011canvas.save();camera.save(); // 保存 Camera 的状态 camera.rotateX(30); // 旋转 Camera 的三维空间 canvas.translate(centerX, centerY); // 旋转之后把投影移动回来 camera.applyToCanvas(canvas); // 把旋转投影到 Canvas canvas.translate(-centerX, -centerY); // 旋转之前把绘制内容移动到轴心（原点） camera.restore(); // 恢复 Camera 的状态canvas.drawBitmap(bitmap, point1.x, point1.y, paint); canvas.restore(); 平移 Camera.translate(float x, float y, float z) 设置虚拟相机的位置 Camera.setLocation(x, y, z) 参数的单位不是像素，而是 inch，英寸。这种设计源自 Android 底层的图像引擎 Skia 。在 Skia 中，Camera 的位置单位是英寸，英寸和像素的换算单位在 Skia 中被写死为了 72 像素，而 Android 中把这个换算单位照搬了过来。是的，它写死了。 在 Camera 中，相机的默认位置是 (0, 0, -8)（英寸）。8 x 72 = 576，所以它的默认位置是 (0, 0, -576)（像素）。如果绘制的内容过大，当它翻转起来的时候，就有可能出现图像投影过大的「糊脸」效果。而且由于换算单位被写死成了 72 像素，而不是和设备 dpi 相关的，所以在像素越大的手机上，这种「糊脸」效果会越明显。而使用 setLocation() 方法来把相机往后移动，就可以修复这种问题。Camera.setLocation(x, y, z) 的 x 和 y 参数一般不会改变，直接填 0 就好。]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定View之Paint详解]]></title>
    <url>%2F2018%2F02%2F07%2F%E8%87%AA%E5%AE%9AView%E4%B9%8BPaint%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"></content>
      <categories>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定View之Canvas的系列方法及 Paint最常见的使用]]></title>
    <url>%2F2018%2F02%2F07%2F%E8%87%AA%E5%AE%9AView%E4%B9%8BCanvas%E7%9A%84%E7%B3%BB%E5%88%97%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Canvas.drawXXX() 是自定义绘制最基本的操作。通过该方法可以绘制圆、方、图像、和文字，并且组合这些内容，在通过Paint的一些常见方法来对绘制内容的颜色和风格进行简单配置。 View的坐标系 在 Android 里，每个 View 都有一个自己的坐标系，彼此之间是不影响的。这个坐标系的原点是 View 左上角的那个点；水平方向是 x 轴，右正左负；竖直方向是 y 轴，下正上负。 Canvas.translate(dx,dy)：View的坐标系原点移动指定距离，dx为移动的x方向距离，dy为移动的y方向的问题。 Canvas.drawXXX() 和 Paint 基础 Canvas 类下的所有 draw- 开头的方法： drawCircle() drawBitmap() drawOval() drawPoint() drawRect() drawArc() drawPath() Paint 类的几个最常用的方法： Paint.setStyle(Style style) 设置绘制模式 Paint.Style.STROK：画线模式 Paint.Style.FILL：填充末世 FILL_AND_STROKE：既画线又填充 Paint.setColor(int color) 设置颜色 Paint.setStrokeWidth(float width) 设置线条宽度 Paint.setTextSize(float textSize) 设置文字大小 Paint.setAntiAlias(boolean aa) 设置抗锯齿开关 Paint.setTextAlign(Align align)设置文字居中，左对齐，右对齐 ​ 颜色填充 Canvas.drawColor(@ColorInt int color) 在整个绘制区域统一涂上指定的颜色,这类颜色填充方法一般用于在绘制之前设置底色，或者在绘制之后为界面设置半透明蒙版。 类似的方法还有 drawRGB(int r, int g, int b) 和 drawARGB(int a, int r, int g, int b) ，它们和 drawColor(color) 只是使用方式不同，作用都是一样的。 画圆 drawCircle(float centerX, float centerY, float radius, Paint paint) centerX , centerY：圆的圆心坐标（单位像素）。 radius：圆的半径（单位像素）。 画矩形 drawRect(float left, float top, float right, float bottom, Paint paint) left, top, right, bottom 是矩形四条边的坐标。 两个重载方法 drawRect(RectF rect, Paint paint) 和 drawRect(Rect rect, Paint paint)，直接设置RectF 或 Rect 对象来绘制矩形。 画点 drawPoint(float x, float y, Paint paint) x 和 y 是点的坐标。点的大小可以通过 paint.setStrokeWidth(width) 来设置； 点的形状可以通过 paint.setStrokeCap(cap) 来设置：ROUND 画出来是圆形的点，SQUARE 或 BUTT 画出来是方形的点 Paint.setStrokeCap(cap) 可以设置点的形状，但这个方法并不是专门用来设置点的形状的，而是一个设置线条端点形状的方法。端点有圆头 (ROUND)、平头 (BUTT) 和方头 (SQUARE) 三种。 drawPoints(float[] pts, int offset, int count, Paint paint) / drawPoints(float[] pts, Paint paint) 批量画点,pts 这个数组是点的坐标，每两个成一对；offset表示跳过数组的前几个数再开始记坐标；count 表示一共要绘制几个点。 画椭圆 drawOval(float left, float top, float right, float bottom, Paint paint) 只能绘制横着的或者竖着的椭圆，不能绘制斜的（斜的倒是也可以，但不是直接使用 drawOval()，而是配合几何变换）。left, top, right, bottom 是这个椭圆的左、上、右、下四个边界点的坐标。 重载方法 drawOval(RectF rect, Paint paint)，让你可以直接填写 RectF 来绘制椭圆。 画线 drawLine(float startX, float startY, float stopX, float stopY, Paint paint) 由于直线不是封闭图形，所以 setStyle(style) 对直线没有影响。 drawLines(float[] pts, int offset, int count, Paint paint) / drawLines(float[] pts, Paint paint) 批量画线。 画圆角矩形 drawRoundRect(float left, float top, float right, float bottom, float rx, float ry, Paint paint) left, top, right, bottom 是四条边的坐标，rx 和 ry 是圆角的横向半径和纵向半径。 重载方法 drawRoundRect(RectF rect, float rx, float ry, Paint paint)，让你可以直接填写 RectF 来绘制圆角矩形。 画 Bitmap drawBitmap(Bitmap bitmap, float left, float top, Paint paint) 重载方法： drawBitmap(Bitmap bitmap, Rect src, RectF dst, Paint paint) drawBitmap(Bitmap bitmap, Rect src, Rect dst, Paint paint) drawBitmap(Bitmap bitmap, Matrix matrix, Paint paint) drawBitmapMesh()，可以绘制具有网格拉伸效果的 Bitmap。 绘制弧形或扇形 drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint) left, top, right, bottom 描述的是这个弧形所在的椭圆；startAngle 是弧形的起始角度（x 轴的正向，即正右的方向，是 0 度的位置；顺时针为正角度，逆时针为负角度），sweepAngle 是弧形划过的角度；useCenter 表示是否连接到圆心，如果不连接到圆心，就是弧形，如果连接到圆心，就是扇形。 画自定义图形 drawPath(Path path, Paint paint) Path 方法第一类：直接描述路径 addXxx()：添加字图形。 添加圆： addCircle(float x, float y, float radius, Direction dir) 添加椭圆： addOval(float left, float top, float right, float bottom, Direction dir) / addOval(RectF oval, Direction dir) 添加矩形： addRect(float left, float top, float right, float bottom, Direction dir) / addRect(RectF rect, Direction dir) 添加圆角矩形： addRoundRect(RectF rect, float rx, float ry, Direction dir) / addRoundRect(float left, float top, float right, float bottom, float rx, float ry, Direction dir) / addRoundRect(RectF rect, float[] radii, Direction dir) / addRoundRect(float left, float top, float right, float bottom, float[] radii, Direction dir) 添加一个 Path： addPath(Path path) dir：画圆的路径的方向，路径方向是顺时针 (CW clockwise) 和逆时针 (CCW counter-clockwise) 。对于普通情况，这个参数填 CW 还是填 CCW 没有影响。它只是在需要填充图形 (Paint.Style 为 FILL 或 FILL_AND_STROKE) ，并且图形出现自相交时，用于判断填充范围。 xxxTo()：画线（直线或曲线） 第一组是添加的完整封闭图形（除了 addPath() ），而这一组添加的只是一条线。 画直线： lineTo(float x, float y) / rLineTo(float x, float y) ，从当前位置向目标位置画一条直线， x 和 y 是目标位置的坐标。这两个方法的区别是，lineTo(x, y) 的参数是绝对坐标，而 rLineTo(x, y) 的参数是相对当前位置的相对坐标 （前缀 r 指的就是 relatively 「相对地」)。当前位置：所谓当前位置，即最后一次调用画 Path 的方法的终点位置。初始值为原点 (0, 0)。 画二次贝塞尔曲线： quadTo(float x1, float y1, float x2, float y2) / rQuadTo(float dx1, float dy1, float dx2, float dy2)。x1, y1 和 x2, y2 则分别是控制点和终点的坐标。 画三次贝塞尔曲线： cubicTo(float x1, float y1, float x2, float y2, float x3, float y3) / rCubicTo(float x1, float y1, float x2, float y2, float x3, float y3) 。 移动到目标位置： moveTo(float x, float y) / rMoveTo(float x, float y)，设置图形的起点。 封闭当前子图形： close() Path 方法第二类：辅助的设置或计算 Path.setFillType(Path.FillType ft) 设置填充方式,FillType 值: EVEN_ODD ：全填充 WINDING （默认值）：交叉填充 INVERSE_EVEN_ODD INVERSE_WINDING ​ EVEN_ODD： even-odd rule （奇偶原则）：对于平面中的任意一点，向任意方向射出一条射线，这条射线和图形相交的次数（相交才算，相切不算哦）如果是奇数，则这个点被认为在图形内部，是要被涂色的区域；如果是偶数，则这个点被认为在图形外部，是不被涂色的区域。 WINDING non-zero winding rule （非零环绕数原则）：从平面中的点向任意方向射出一条射线，以 0 为初始值，对于射线和图形的所有交点，遇到每个顺时针的交点（图形从射线的左边向右穿过）把结果加 1，遇到每个逆时针的交点（图形从射线的右边向左穿过）把结果减 1，最终把所有的交点都算上，得到的结果如果不是 0，则认为这个点在图形内部，是要被涂色的区域；如果是 0，则认为这个点在图形外部，是不被涂色的区域。 图形的方向：对于添加子图形类方法（如 Path.addCircle() Path.addRect()）的方向，由方法的 dir 参数来控制，这个在前面已经讲过了；而对于画线类的方法（如 Path.lineTo() Path.arcTo()）就更简单了，线的方向就是图形的方向。 INVERSE_EVEN_ODD 和 INVERSE_WINDING，只是把EVEN_ODD和INVERSE_WINDING效果进行反转而已。 EVEN_ODD和INVERSE_WINDING完整效果图]]></content>
      <categories>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LRUCache原理]]></title>
    <url>%2F2018%2F02%2F04%2FLRUCache%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[LRUCache算法中LRU是指Last Recently Used，也就是最近最少使用算法。当缓存控件满了的时候，将最近最少使用的数据从缓存控件中删除以增加缓存空间来缓存新内容。这个算法内部有一个缓存列表，每当一个数据被访问的时候，改数据就会被提到列表头部，蓑衣列表尾部的数据就是最近最不常是使用的了，当缓存空间不足，就会删除列表尾部的缓存数据。 LRUCache源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345/** * LruCache通过强引用来缓存一定数量的值，每当一个值被访问时，这个值就会移动到缓存列表的头部。 * 如果插入数据时发现缓存不够，就会将队列中访问次数最少的数据删掉。 */public class LruCache&lt;K, V&gt; &#123; // 存放缓存内容的map private final LinkedHashMap&lt;K, V&gt; map; /** * Size of this cache in units. Not necessarily the number of elements. * 当前缓存已使用大小，不一定是元素的个数 */ private int size; // 内存最大值 private int maxSize; // 各个方法被调用的次数 private int putCount; private int createCount; private int evictionCount; private int hitCount; private int missCount; /** * @param maxSize for caches that do not override &#123;@link #sizeOf&#125;, this is * the maximum number of entries in the cache. For all other caches, * this is the maximum sum of the sizes of the entries in this cache. * 构造方法 传入maxSize是缓存的最大值 */ public LruCache(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;); &#125; this.maxSize = maxSize; // 初始化LinkedHashMap // 第一个参数是初始容量 // 第二个参数为填装因子或加载因子 // 第三个参数为排序模式，true表示在访问的时候进行排序，否则只在插入的时候排序。 this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true); &#125; /** * Sets the size of the cache. * 重置最大缓存 * @param maxSize The new maximum size. */ public void resize(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;); &#125; synchronized (this) &#123; this.maxSize = maxSize; &#125; trimToSize(maxSize); &#125; /** * Returns the value for &#123;@code key&#125; if it exists in the cache or can be * created by &#123;@code #create&#125;. If a value was returned, it is moved to the * head of the queue. This returns null if a value is not cached and cannot * be created. * 通过Key获取缓存的数据，如果通过这个方法得到的需要的元素,那么该元素会被放在缓存队列的头部 */ public final V get(K key) &#123; if (key == null) &#123; throw new NullPointerException(&quot;key == null&quot;); &#125; V mapValue; // 同步代码块 synchronized (this) &#123; // 从LinkedHashMap中获取数据 mapValue = map.get(key); if (mapValue != null) &#123; hitCount++; return mapValue; &#125; missCount++; &#125; /* * Attempt to create a value. This may take a long time, and the map * may be different when create() returns. If a conflicting value was * added to the map while create() was working, we leave that value in * the map and release the created value. * 如果通过Key从缓存集合中获取缓存不到的数据，就尝试使用creat(key)方法创造一个新数据。 * create(key)默认返回的也是null,需要重写该方法 */ V createdValue = create(key); if (createdValue == null) &#123; return null; &#125; // 若是重写了create(key)方法，便将新的数据放入缓存中。 synchronized (this) &#123; createCount++; mapValue = map.put(key, createdValue); if (mapValue != null) &#123; // There was a conflict so undo that last put 有冲突撤销之前设置的值 map.put(key, mapValue); &#125; else &#123; size += safeSizeOf(key, createdValue); &#125; &#125; if (mapValue != null) &#123; entryRemoved(false, key, createdValue, mapValue); return mapValue; &#125; else &#123; trimToSize(maxSize); return createdValue; &#125; &#125; /** * Caches &#123;@code value&#125; for &#123;@code key&#125;. The value is moved to the head of * the queue. * 向缓存队列中添加数据，并将数据移动到队列头部 * @return the previous value mapped by &#123;@code key&#125;. */ public final V put(K key, V value) &#123; if (key == null || value == null) &#123; throw new NullPointerException(&quot;key == null || value == null&quot;); &#125; V previous; synchronized (this) &#123; putCount++; // safeSizeOf(Key,value);该方法返回的是1，也就是将缓存的个数加1. // 当缓存的是图片的时候，这个size应该表示图片占用的内存的大小， // 所以应该重写里面调用sizeOf(key,value)的方法 size += safeSizeOf(key, value); // 将新创建的元素加入缓存队列，并在添加成功后返回这个元素 previous = map.put(key, value); if (previous != null) &#123; // 如果换回为null,则说明缓存失败，在已用的缓存大小中减去改元素大小 size -= safeSizeOf(key, previous); &#125; &#125; if (previous != null) &#123; entryRemoved(false, key, previous, value); &#125; trimToSize(maxSize); return previous; &#125; /** * Remove the eldest entries until the total of remaining entries is at or * below the requested size. * 修改缓存大小，是已用的缓存不大于设置的缓存最大值 * @param maxSize the maximum size of the cache before returning. May be -1 * to evict even 0-sized elements. */ public void trimToSize(int maxSize) &#123; while (true) &#123; K key; V value; synchronized (this) &#123; if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException(getClass().getName() + &quot;.sizeOf() is reporting inconsistent results!&quot;); &#125; // 已用缓存小于最大缓存，则完成任务退出循环 if (size &lt;= maxSize || map.isEmpty()) &#123; break; &#125; // 否则在缓存队列中先找到最近最少使用的元素， // 调用LinkedHashMap的eldest()方法返回最不经常使用的元素。 Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next(); // 删掉改元素减少已使用的缓存空间 key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); size -= safeSizeOf(key, value); evictionCount++; &#125; entryRemoved(true, key, value, null); &#125; &#125; /** * Removes the entry for &#123;@code key&#125; if it exists. * 删除 * @return the previous value mapped by &#123;@code key&#125;. */ public final V remove(K key) &#123; if (key == null) &#123; throw new NullPointerException(&quot;key == null&quot;); &#125; V previous; synchronized (this) &#123; previous = map.remove(key); if (previous != null) &#123; size -= safeSizeOf(key, previous); &#125; &#125; if (previous != null) &#123; entryRemoved(false, key, previous, null); &#125; return previous; &#125; /** * Called for entries that have been evicted or removed. This method is * invoked when a value is evicted to make space, removed by a call to * &#123;@link #remove&#125;, or replaced by a call to &#123;@link #put&#125;. The default * implementation does nothing. * * &lt;p&gt;The method is called without synchronization: other threads may * access the cache while this method is executing. * * @param evicted true if the entry is being removed to make space, false * if the removal was caused by a &#123;@link #put&#125; or &#123;@link #remove&#125;. * @param newValue the new value for &#123;@code key&#125;, if it exists. If non-null, * this removal was caused by a &#123;@link #put&#125;. Otherwise it was caused by * an eviction or a &#123;@link #remove&#125;. * 默认为空方法，有需要才会自己实现，evicted如果是true,则表示这个元素因为空间不够而被自动清理了，所以 * 可以在这个地方队被清理的元素进行再次缓存 */ protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) &#123;&#125; /** * Called after a cache miss to compute a value for the corresponding key. * Returns the computed value or null if no value can be computed. The * default implementation returns null. * * &lt;p&gt;The method is called without synchronization: other threads may * access the cache while this method is executing. * * &lt;p&gt;If a value for &#123;@code key&#125; exists in the cache when this method * returns, the created value will be released with &#123;@link #entryRemoved&#125; * and discarded. This can occur when multiple threads request the same key * at the same time (causing multiple values to be created), or when one * thread calls &#123;@link #put&#125; while another is creating a value for the same * key. */ protected V create(K key) &#123; return null; &#125; private int safeSizeOf(K key, V value) &#123; int result = sizeOf(key, value); if (result &lt; 0) &#123; throw new IllegalStateException(&quot;Negative size: &quot; + key + &quot;=&quot; + value); &#125; return result; &#125; /** * Returns the size of the entry for &#123;@code key&#125; and &#123;@code value&#125; in * user-defined units. The default implementation returns 1 so that size * is the number of entries and max size is the maximum number of entries. * 用来定义已用缓存的数量算法，默认是返回数量 * &lt;p&gt;An entry&apos;s size must not change while it is in the cache. */ protected int sizeOf(K key, V value) &#123; return 1; &#125; /** * Clear the cache, calling &#123;@link #entryRemoved&#125; on each removed entry. * 清空所有缓存 */ public final void evictAll() &#123; trimToSize(-1); // -1 will evict 0-sized elements &#125; /** * For caches that do not override &#123;@link #sizeOf&#125;, this returns the number * of entries in the cache. For all other caches, this returns the sum of * the sizes of the entries in this cache. * 不可重写，返回的值是缓存的条目数 */ public synchronized final int size() &#123; return size; &#125; /** * For caches that do not override &#123;@link #sizeOf&#125;, this returns the maximum * number of entries in the cache. For all other caches, this returns the * maximum sum of the sizes of the entries in this cache. */ public synchronized final int maxSize() &#123; return maxSize; &#125; /** * Returns the number of times &#123;@link #get&#125; returned a value that was * already present in the cache. * 已缓存的value的数目 */ public synchronized final int hitCount() &#123; return hitCount; &#125; /** * Returns the number of times &#123;@link #get&#125; returned null or required a new * value to be created. */ public synchronized final int missCount() &#123; return missCount; &#125; /** * Returns the number of times &#123;@link #create(Object)&#125; returned a value. */ public synchronized final int createCount() &#123; return createCount; &#125; /** * Returns the number of times &#123;@link #put&#125; was called. */ public synchronized final int putCount() &#123; return putCount; &#125; /** * Returns the number of values that have been evicted. */ public synchronized final int evictionCount() &#123; return evictionCount; &#125; /** * Returns a copy of the current contents of the cache, ordered from least * recently accessed to most recently accessed. */ public synchronized final Map&lt;K, V&gt; snapshot() &#123; return new LinkedHashMap&lt;K, V&gt;(map); &#125; @Override public synchronized final String toString() &#123; int accesses = hitCount + missCount; int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0; return String.format(Locale.US, &quot;LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]&quot;, maxSize, hitCount, missCount, hitPercent); &#125;&#125; LinkedHashMap LRUCache使用LinkedHashMap来存储缓存，LinkedHashMap内部有排序功能，当其构造方法第三个参数为true时，数据在被访问的时候就会排序，该排序的结果就是把最近访问的数据放在放在集合的最后面。所以要缓存不够是就会从前面开始删除。 构造方法1234567891011121314151617/** * Constructs an empty &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with the * specified initial capacity, load factor and ordering mode. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @param accessOrder the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for * access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */ public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder; &#125; Entity的定义LinkedHashMap内部是使用双向循环链表来存储数据，也就是每一个元素都持有他上一个元素的地址和下一个元素的地址 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * LinkedHashMap entry. */ private static class LinkedHashMapEntry&lt;K,V&gt; extends HashMapEntry&lt;K,V&gt; &#123; // These fields comprise the doubly linked list used for iteration. LinkedHashMapEntry&lt;K,V&gt; before, after; LinkedHashMapEntry(int hash, K key, V value, HashMapEntry&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125; /** * 从链表中删除这个元素 */ private void remove() &#123; before.after = after; after.before = before; &#125; /** * Inserts this entry before the specified existing entry in the list. */ private void addBefore(LinkedHashMapEntry&lt;K,V&gt; existingEntry) &#123; after = existingEntry; before = existingEntry.before; before.after = this; after.before = this; &#125; /** * 当集合的get方法被调用时，会调用这个方法。 * 如果accessOrder为true，就把这个元素放在集合的最末端。 */ void recordAccess(HashMap&lt;K,V&gt; m) &#123; LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m; if (lm.accessOrder) &#123; lm.modCount++; remove(); addBefore(lm.header); &#125; &#125; void recordRemoval(HashMap&lt;K,V&gt; m) &#123; remove(); &#125; &#125; get方法排序过程1234567public V get(Object key) &#123; LinkedHashMapEntry&lt;K,V&gt; e = (LinkedHashMapEntry&lt;K,V&gt;)getEntry(key); if (e == null) return null; e.recordAccess(this); return e.value; &#125; 每一个元素都持有他上一个元素的地址和下一个元素的地址，对于最后一个元素它会和header相互持有也就是header会持有最后一个元素地址作为before，而最后一个元素会持有header地址作为after。 recordAccess（this）方法，this就是这个LinkedHashMap123456789101112131415161718192021void recordAccess(HashMap&lt;K,V&gt; m) &#123; LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m; if (lm.accessOrder) &#123; lm.modCount++; remove(); addBefore(lm.header); &#125; &#125; // 调用remove方法，把自己从链表中移除： private void remove() &#123; before.after = after; after.before = before; &#125; // addBefore(lm.header)方法，把自己添加到链表的结尾 private void addBefore(LinkedHashMapEntry&lt;K,V&gt; existingEntry) &#123; after = existingEntry; before = existingEntry.before; before.after = this; after.before = this; &#125; 获取最该清楚的常用元素 eldest()方法，提供的就是最近最少使用的元素： 1234public Map.Entry&lt;K, V&gt; eldest() &#123; Entry&lt;K, V&gt; eldest = header.after; return eldest != header ? eldest : null;&#125; LruCache和LinkedHashMap结合实现缓存 LinkedHashMap第三个参数为true时，每次访问LinkedHashMap的数据，LinkedHashMap都回去进行排序，将最近访问的放在链表的末尾。 LruCache的put方法调用了LinkedHashMap的put来存储数据，自己进行了对缓存空间的计算。LinkedHashMap的put方法也会进行排序。 LruCache的get方法调用了LinkedHashMap的get来获取数据，由于LinkedHashMap构造方法的第三个参数为true,因此get也会触发LinkedHashMap的排序。 trimToSize(int maxSize) trimToSize(int maxSize)是LruCache的核心方法了，get和put都可能会执行这个方法。 1234567891011121314151617181920212223242526272829public void trimToSize(int maxSize) &#123; while (true) &#123; K key; V value; synchronized (this) &#123; if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException(getClass().getName() + &quot;.sizeOf() is reporting inconsistent results!&quot;); &#125; if (size &lt;= maxSize) &#123; break; &#125; Map.Entry&lt;K, V&gt; toEvict = map.eldest(); if (toEvict == null) &#123; break; &#125; key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); size -= safeSizeOf(key, value); evictionCount++; &#125; entryRemoved(true, key, value, null); &#125; &#125; 使用LruCache来缓存Bitmap12345678910111213141516171819202122LruCache&lt;String, Bitmap&gt; mLruCache; //获取手机最大内存 单位 kb int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); //一般都将1/8设为LruCache的最大缓存 int cacheSize = maxMemory / 8; mLruCache = new LruCache&lt;String, Bitmap&gt;(maxMemory / 8) &#123; /** * 这个方法从源码中看出来是设置已用缓存的计算方式的。 * 默认返回的值是1，也就是没缓存一张图片就将已用缓存大小加1. * 缓存图片看的是占用的内存的大小，每张图片的占用内存也是不一样的，一次不能这样算。 * 因此要重写这个方法，手动将这里改为本次缓存的图片的大小。 */ @Override protected int sizeOf(String key, Bitmap value) &#123; return value.getByteCount() / 1024; &#125; &#125;; //加入缓存 mLruCache.put(&quot;key&quot;, BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)); //从缓存中读取 Bitmap bitmap = mLruCache.get(&quot;key&quot;);]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有关MVP的设计]]></title>
    <url>%2F2018%2F02%2F04%2F%E6%9C%89%E5%85%B3MVP%E7%9A%84%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[BasePresenter中BaseView的绑定和解绑：由于Presenter要获取View对象调用View中方法，所以需要对View进行绑定，当View销毁时因为View的对象为null，需要Presenter对View进行解绑，不然Presenter会持有View的引用导致内存泄漏。 代理模式 抽象角色：声明真实对象和代理对象的共同接口； 代理角色：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。 真实角色：代理角色所代表的真实对象，是我们最终要引用的对象。 代理模式在MVP设计中的体现 第一重代理: 绑定与解绑的代理（代理角色ProxyMvpCallback为真实角色BaseActivity实现绑定与解绑功能） 抽象角色：MvpCallBack，创建与设置BasePresenter和BaseView的接口。 代理角色：ProxyMvpCallback 真实角色：BaseActivity 第二重代理：Activity生命周期的代理（代理对象BaseActivity为真实对象抽象角色MvpActivityDelegate实现Activity的生命周期方法） 抽象角色：MvpActivityDelegate 即代理Activity的生命周期 代理角色：BaseActivity为代理角色内部在Activity生命周期中调用了真实角色的MvpActivityDelegateImpl的生命周期方法。 真实角色：MvpActivityDelegateImpl，实现了Activity的生命周期。 第一重代理与第二重代理相结合即是双重代理：代理对象ProxyMvpCallback为真实对象MvpActivityDelegate在生命周期方法中实现绑定与解绑功能]]></content>
      <categories>
        <category>Android架构</category>
      </categories>
      <tags>
        <tag>MVP</tag>
      </tags>
  </entry>
</search>
