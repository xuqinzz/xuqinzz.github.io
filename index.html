<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="c5yB2B-3tswoQK7D0ZfZDqbSGvVzLxh-kwnbxyeTdaU" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="格物致知">
<meta property="og:type" content="website">
<meta property="og:title" content="跬步">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="跬步">
<meta property="og:description" content="格物致知">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="跬步">
<meta name="twitter:description" content="格物致知">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>




<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #ffffff; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #ffffff, 0 0 5px #ffffff; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #ffffff;    /*上边框颜色*/
        border-left-color: #ffffff;    /*左边框颜色*/
    }
</style>
  <title>跬步</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-113549877-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">跬步</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程表
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/02/I-Love-You-LZX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="作茧自缚">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/I-Love-You-LZX/" itemprop="url">I Love You LZX</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-02T21:36:30+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/02/I-Love-You-LZX/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/02/I-Love-You-LZX/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/02/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="作茧自缚">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-02T21:19:40+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/02/hello-world/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/02/hello-world/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/02/API-Guide之Device compatibility/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="作茧自缚">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/API-Guide之Device compatibility/" itemprop="url">API-Guide之设备兼容性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-02T22:51:44+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/guide/" itemprop="url" rel="index">
                    <span itemprop="name">guide</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/02/API-Guide之Device compatibility/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/05/02/API-Guide之Device compatibility/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<ol>
<li>Android系统运行在多种类型的设备上，包括手机、平板电脑以及电视机。作为开发者的我们应该尽量适配不同类型的设备，以挖掘潜在的用户。为了适配不同类型的设备，应用功能对于不同不用的设备或许有些不同存在一定的变化，并且对于不同的设备屏幕配置相应的界面。</li>
<li>为了帮助开发者适配不同的设备，Android提供了一个动态的应用程序框架。开发者可以在静态文件中提供特定于配置的应用资源，然后Android系统会根据当前的设备类型加载相应的资源。通过这种动态的框架开发者就可以仅发布单个应用程序包（APK）,便适配多种设备。</li>
<li>同时，开发者也可指定使用应用功能的要求，并限定那些类型的设备可以从Google Play上安装应用。</li>
</ol>
</blockquote>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><h3 id="设备兼容性"><a href="#设备兼容性" class="headerlink" title="设备兼容性"></a>设备兼容性</h3><ul>
<li>只有设备能够正确运行为Android执行环境编写的应用程序，设备才能 “与Android兼容”。 Android执行环境的确切细节由<a href="http://source.android.google.cn/compatibility/overview.html" target="_blank" rel="noopener">Android兼容性程序</a>定义，并且每个设备必须通过兼容性测试套件（CTS）才能被视为兼容。 </li>
</ul>
<h3 id="应用程序兼容性"><a href="#应用程序兼容性" class="headerlink" title="应用程序兼容性"></a>应用程序兼容性</h3><ul>
<li>应用是否与每种潜在的设备配置兼容。由于Android在各种设备配置上运行，某些功能在所有设备上都不可用。例如，某些设备可能不包含指南针传感器。如果您的应用程序的核心功能需要使用指南针传感器，那么您的应用程序仅与包含指南针传感器的设备兼容。 </li>
</ul>
<h3 id="应用对设备的可用性"><a href="#应用对设备的可用性" class="headerlink" title="应用对设备的可用性"></a>应用对设备的可用性</h3><blockquote>
<p>Android系统支持调用API来获取使用系统的功能，一些功能是基于硬件的（如指南针传感器），一些是基于软件的（如应用程序小部件），另一些则依赖于系统版本。并非所有的设备都支持全部功能，因此应用需要根据所需要的功能来控制应用对设备的可用性。</p>
<p>为了使应用获取尽可能多的用户，开发者应该尽可能使单个APK支持所有设备配置。在大多数情况下，开发者可以通过运行时禁用可选功能并为应用程序资源提供不同配置的替代选项来实现此目的。但是在并要情况下也可根据设备特征，通过Google Play应用商店限制应用程序在设备上的可用性：</p>
<ol>
<li>设备功能</li>
<li>平台版本</li>
<li>屏幕配置</li>
</ol>
</blockquote>
<h3 id="设备功能"><a href="#设备功能" class="headerlink" title="设备功能"></a>设备功能</h3><ul>
<li>Android为任何可能无法在所有设备上使用的硬件或软件功能定义了功能ID，以便开发者根据功能管理应用的可用性。例如，指南针传感器的功能ID是<code>FEATURE_SENSOR_COMPASS</code>，应用程序小窗口功能ID是<code>FEATURE_APP_WIDGETS</code>如果游标，可以阻止用户在其设备未提供给定功能的情况下通过将其声明为<uses-feature>的清单文件中的元素来安装应用。例如，如果应用在没有指南针传感器的设备上没有意义，则可根据以下清单标签声明指南针传感器：<code>&lt;manifest ... &gt; &lt;uses-feature android：name = “android.hardware.sensor.compass” android：required = “true” /&gt;     ... &lt;/ manifest&gt;</code></uses-feature></li>
<li>Google Play商店会将您应用所需的功能与每个用户设备上提供的功能进行比较，以确定您的应用是否与每个设备兼容。如果设备未提供您的应用所需的全部功能，则用户无法安装您的应用。 但是，如果您的应用程序的主要功能<em>不需要</em> 设备功能，则应该将该<code>required</code>属性设置为<code>&quot;false&quot;</code>并在运行时检查设备功能。如果应用程序功能在当前设备上不可用，请适度降低相应的应用程序功能。例如，您可以通过如下方式调用来查询某个功能是否可用 <code>hasSystemFeature()</code>： </li>
<li><strong>注意：</strong>某些系统权限隐式需要设备功能的可用性。例如，如果您的应用请求访问权限<code>BLUETOOTH</code>，则这隐含地要求<code>FEATURE_BLUETOOTH</code>设备功能。您可以禁用基于此功能的过滤功能，并通过将该<code>required</code>属性设置<code>&quot;false&quot;</code>为<uses-feature>标签，使应用可供没有蓝牙的设备使用.</uses-feature></li>
</ul>
<h3 id="平台版本"><a href="#平台版本" class="headerlink" title="平台版本"></a>平台版本</h3><ul>
<li><p>不同的设备可能会运行不同版本的Android平台，例如Android 4.0或Android 4.4。每个连续的平台版本通常会添加新版本中不可用的新API。为了指示哪些API可用，每个平台版本指定一个API级别。例如，Android 1.0是API级别1，Android 4.4是API级别19。</p>
</li>
<li><p>API级别允许使用清单标记及其<code>minSdkVersion</code>属性来声明应用程序兼容的最低版本。例如，日历提供程序API已添加到Android 4.0（API级别14）中。如果应用无法在没有这些API的情况下运行，您应该将API级别14声明为应用的最低支持版本。</p>
</li>
<li><p>该<code>minSdkVersion</code>属性声明了您的应用程序兼容的最低版本，并且该<code>targetSdkVersion</code>属性声明了对应用程序进行了优化的最高版本。但是，请注意<uses-sdk>元素中的属性被<code>build.gradle</code>文件中的相应属性覆盖。因此，如果使用Android Studio，则必须在其中指定值<code>minSdkVersion</code>和 <code>targetSdkVersion</code>值： </uses-sdk></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ndroid &#123; </span><br><span class="line">  defaultConfig &#123; </span><br><span class="line">    applicationId&apos;com.example.myapp &apos; </span><br><span class="line">    //定义运行应用程序所需的最低API级别。</span><br><span class="line">    minSdkVersion 15 </span><br><span class="line">    //指定用于测试应用程序的API级别。</span><br><span class="line">    targetSdkVersion 26 ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Android的每个后续版本都提供了使用以前平台版本的API构建的应用程序的兼容性，因此，在使用记录的Android API时，应用程序应始终与未来版本的Android兼容。 </p>
</li>
<li><strong>注意：</strong> 该<code>targetSdkVersion</code>属性不会阻止您的应用程序安装在高于指定值的平台版本上，但它很重要，因为它向系统指示您的应用程序是否应继承新版本中的行为更改。如果没有更新 <code>targetSdkVersion</code>到最新版本，则系统会假定您的应用在最新版本上运行时需要一些向后兼容的行为。例如，在Android 4.4的行为更改中，使用<code>AlarmManager</code>API 创建的警报现在默认为不精确，因此系统可以批量应用警报并保留系统电源，但如果您的目标API级别保持系统以前的API行为低于“19”。 </li>
</ul>
<h3 id="屏幕配置"><a href="#屏幕配置" class="headerlink" title="屏幕配置"></a>屏幕配置</h3><ul>
<li><p>Android可在各种尺寸的设备上运行，从手机到平板电脑和电视。为了按照屏幕类型对设备进行分类，Android为每个设备定义了两个特征：屏幕大小（屏幕的物理大小）和屏幕密度（屏幕上像素的物理密度，称为DPI）。为了简化不同的配置，Android将这些变体概括为多个组，使他们更容易定位： </p>
<ul>
<li>四种广义尺寸：小，正常，大和xlarge。</li>
<li>还有几种广义密度：mdpi（中等），hdpi（高），xhdpi（超高），xxhdpi（超高）以及其他。</li>
</ul>
</li>
<li><p>默认情况下，应用程序与所有屏幕尺寸和密度兼容，因为系统会根据每个屏幕的需要对UI布局和图像资源进行适当调整。但是，应该通过针对不同的屏幕尺寸添加专门的布局并优化通用屏幕密度的位图图像，优化每种屏幕配置的用户体验。 </p>
</li>
</ul>
<h2 id="屏幕兼容性概述"><a href="#屏幕兼容性概述" class="headerlink" title="屏幕兼容性概述"></a>屏幕兼容性概述</h2><blockquote>
<p>Android应用可能会运行在不同屏幕尺寸和密度的设备上。Android系统对不同痛的设备提供了同意开发环境，可以处理大多数的适配，从而将应用的界面调整为适应其显示的屏幕。并且，系统提供的API可用于控制应用适用于特定的屏幕尺寸和密度，以针对不同屏幕配置优化UI设计。虽然系统会对应用根据屏幕进行缩放和大小的调整，但是开发者也需针对屏幕尺寸和密度进行优化。</p>
</blockquote>
<h3 id="屏幕支持概览"><a href="#屏幕支持概览" class="headerlink" title="屏幕支持概览"></a>屏幕支持概览</h3><h4 id="术语和概念"><a href="#术语和概念" class="headerlink" title="术语和概念"></a>术语和概念</h4><ul>
<li><strong>屏幕尺寸：</strong>按照屏幕对角测量的实际物理尺寸，通常Android将所有屏幕尺寸分为四种通用尺寸：小、正常、大和超大。</li>
<li><strong>屏幕密度：</strong>屏幕物理区域中的像素密度；通常称为dpi(每英寸点数)。通常Android 将所有屏幕密度分组为六种通用密度： 低、中、高、超高、超超高和超超超高。 </li>
<li><strong>方向：</strong>从用户视角看屏幕方向，即横屏还是竖屏，分把表示屏幕的丛横比是宽还是高。注意，不同的设备默认以不同的方向操作，而且方向在运行时还可能回随着用户旋转设备而改变。</li>
<li><strong>分辨率：</strong>屏幕上物理像素的总和。添加对多种屏幕的支持时， 应用不会直接使用分辨率；而只应关注通用尺寸和密度组指定的屏幕 尺寸及密度。 </li>
<li><strong>密度无关像素（dp）：</strong>在定义UI布局时应使用的虚拟像素单位，用于以密度无关方式表示布局维度或位置。密度无关像素等于160dpi屏幕上的一个物理像素，这是系统为“中”密度屏幕假设的基线密度。在运行时，系统更加使用中屏幕的密度按需以透明方式处理dp单位的任何缩放。dp单位转为屏幕像素的公式为：px = dp * (dpi/160)。在定义应用的 UI 时应始终使用 dp 单位 ，以确保在不同密度的屏幕上正常显示 UI。 </li>
</ul>
<h4 id="支持的屏幕范围"><a href="#支持的屏幕范围" class="headerlink" title="支持的屏幕范围"></a>支持的屏幕范围</h4><ul>
<li><p>Android 将实际屏幕尺寸和密度的范围 分为： </p>
<ul>
<li>尺寸：小、正常、大和超大。</li>
<li>密度：<ul>
<li>ldpi（低）~120dpi</li>
<li>mdpi（中）~160dpi</li>
<li>hdpi（高）~240dpi</li>
<li>xhdpi（超高）~320dpi</li>
<li>xxhddpi（超超高）~480dpi</li>
<li>xxxhdpi（超超超高）~640dpi</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>每种通用的屏幕尺寸都关联了系统定义的最低 分辨率。这些最小尺寸以“dp”单位表示 — 在定义布局时应使用相同的单位 — 这样系统无需担心屏幕密度的变化。</p>
<ul>
<li><em>超大</em>屏幕至少为 960dp x 720dp</li>
<li><em>大</em>屏幕至少为 640dp x 480dp</li>
<li><em>正常</em>屏幕至少为 470dp x 320dp</li>
<li><em>小</em>屏幕至少为 426dp x 320dp</li>
</ul>
</li>
<li><p>要针对不同的屏幕尺寸和密度优化应用的 UI，可为任何通用的尺寸和密度提供 备用资源。 通常，应为某些不同的屏幕尺寸提供替代布局，为不同的屏幕密度提供替代位图图像。 在运行时，系统会根据当前设备屏幕的通用 尺寸或密度对应用使用适当的资源。 但是无需为所有屏幕尺寸和 密度的组合提供备用资源。 系统提供强大的兼容性功能，可处理在任何设备屏幕上 渲染应用的大多数工作，前提是您已经使用 可以适当调整大小的技术实现 UI。</p>
</li>
</ul>
<h4 id="密度独立性"><a href="#密度独立性" class="headerlink" title="密度独立性"></a>密度独立性</h4><ul>
<li>应用显示在密度不同的屏幕上时，如果它保持用户界面元素的物理尺寸（从 用户的视角），便可实现“密度独立性” 。保持密度独立性很重要，因为如果没有此功能，UI 元素（例如 按钮）在低密度屏幕上看起来较大，在高密度屏幕上看起来较小。这些 密度相关的大小变化可能给应用布局和易用性带来问题。图 2 和 3 分别显示了应用不提供密度独立性和 提供密度独立性时的差异。 </li>
<li>Android 系统可帮助您的应用以两种方式实现密度独立性：<ul>
<li>系统根据当前屏幕密度扩展 dp 单位数</li>
<li>系统在必要时可根据当前屏幕 密度将可绘制对象资源扩展到适当的大小。</li>
</ul>
</li>
<li>文本视图和位图可绘制对象具有以像素（<code>px</code> 单位）指定的尺寸，因此视图的物理尺寸在低密度屏幕上更大，在高密度 屏幕上更小。这是因为，虽然实际屏幕尺寸可能相同，但高密度屏幕 的每英寸像素更多（同样多的像素在一个更小的区域内）。布局 尺寸以密度独立的像素（<code>dp</code> 单位）指定。由于 密度独立像素的基线是中密度屏幕，因此具有中密度屏幕的设备看起来 与图低密度屏幕上一样。但对于低密度和高密度屏幕，系统 将分别增加和减少密度独立像素值，以适应 屏幕。 </li>
<li>大多数情况下，确保应用中的屏幕独立性很简单，只需以适当的密度独立像素（<code>dp</code> 单位）或 <code>&quot;wrap_content&quot;</code> 指定所有 布局尺寸值。系统然后根据适用于当前屏幕密度的缩放比例适当地缩放位图可绘制对象，以 适当的大小显示。 </li>
<li>但位图缩放可能导致模糊或像素化位图。为避免这些伪影，应为 不同的密度提供替代的位图资源。例如，应为高密度 屏幕提供分辨率较高的位图，然后系统对中密度 屏幕将使用这些位图，而无需调整位图大小。</li>
</ul>
<h3 id="支持多种密度"><a href="#支持多种密度" class="headerlink" title="支持多种密度"></a>支持多种密度</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><blockquote>
<p>Android 支持多种屏幕的基础是它能够管理针对当前屏幕配置 以适当方式渲染应用的布局和位图 可绘制对象。系统可处理大多数工作，通过适当地 缩放布局以适应屏幕尺寸/密度和根据屏幕密度缩放位图可绘制对象 ，在每种屏幕配置中渲染您的应用。 但是为了更适当的处理不同屏幕配置，还应该：</p>
</blockquote>
<ul>
<li><strong>在清单文件中显示声明你的应用支持哪些屏幕尺寸</strong>，要声明应用支持的屏幕尺寸，应在清单文件中包含<supports-screens>元素。 </supports-screens></li>
<li><strong>为不同屏幕尺寸提供不同的布局</strong>，可用于提供尺寸特定资源的配置限定符包括 <code>small</code>、<code>normal</code>、<code>large</code> 和 <code>xlarge</code>。例如，超大屏幕的布局应使用 <code>layout-xlarge/</code>。 从 Android 3.2（API 级别 13）开始，以上尺寸组已弃用，您 应改为使用 <code>sw&lt;N&gt;dp</code> 配置限定符来定义布局资源 可用的最小宽度。例如，如果多窗格平板电脑布局 需要至少 600dp 的屏幕宽度，应将其放在 <code>layout-sw600dp/</code> 中 。</li>
<li><strong>为不同屏幕密度提供不同的位图可绘制对象</strong> ，Android 会缩放位图可绘制对象（<code>.png</code>、<code>.jpg</code> 和 <code>.gif</code> 文件）和九宫格可绘制对象（<code>.9.png</code> 文件），使它们以适当的 物理尺寸显示在每部设备上。 例如，如果您的应用只为 基线中密度屏幕 (mdpi) 提供位图可绘制对象，则在高密度 屏幕上会增大位图，在低密度屏幕上会缩小位图。这种缩放可能在 位图中造成伪影。为确保位图的最佳显示效果，应针对 不同屏幕密度加入不同分辨率的替代版本。 </li>
<li><strong>注意</strong>：将您的所有启动器图标放在 <code>res/mipmap-[density]/</code> 文件夹中，而非 <code>res/drawable-[density]/</code> 文件夹中。无论安装应用的设备屏幕分辨率如何，Android 系统都会将资源保留在这些密度特定的文件夹中，例如 mipmap-xxxhdpi。此 行为可让启动器应用为您的应用选择要显示在主 屏幕上的最佳分辨率图标。</li>
</ul>
<h4 id="系统对应用适配的方法"><a href="#系统对应用适配的方法" class="headerlink" title="系统对应用适配的方法"></a>系统对应用适配的方法</h4><ol>
<li><p><strong>系统使用适当的备用资源：</strong>根据当前屏幕的尺寸和密度，系统将使用您的应用中提供的任何尺寸和 密度特定资源。例如，如果设备有 高密度屏幕，并且应用请求可绘制对象资源，系统将查找 与设备配置最匹配的可绘制对象资源目录。根据可用的其他 备用资源，包含 <code>hdpi</code> 限定符（例如 <code>drawable-hdpi/</code>）的资源目录可能是最佳匹配项，因此系统将使用此 目录中的可绘制对象资源。</p>
</li>
<li><p><strong>没有匹配的资源，系统将使用默认资源：</strong>并按需要向上 或向下扩展，以匹配当前的屏幕尺寸和密度。</p>
<p>“默认”资源是指未标记配置限定符的资源。例如，<code>drawable/</code> 中的资源是默认可绘制资源。 系统假设默认资源设计用于基线屏幕尺寸和密度，即 正常屏幕尺寸和中密度。 因此，系统对于高密度屏幕向上扩展默认密度 资源，对于低密度屏幕向下扩展。当系统查找密度特定的资源但在 密度特定目录中未找到时，不一定会使用默认资源。系统在缩放时可能 改用其他密度特定资源提供更好的 效果。例如，查找低密度资源但该资源不可用时， 系统会缩小资源的高密度版本，因为 系统可轻松以 0.5 为系数将高密度资源缩小至低密度资源，与以 0.75 为系数 缩小中密度资源相比，伪影更少。</p>
</li>
</ol>
<p>####使用配置限定符</p>
<ul>
<li><p>配置限定符使用方式</p>
<ol>
<li>在项目的 <code>res/</code>目录中新建一个目录，并使用以下 格式命名： <code>&lt;resources_name&gt;-&lt;qualifier&gt;</code><ul>
<li><code>&lt;resources_name&gt;</code> 是标准资源名称（例如 <code>drawable</code> 或 <code>layout</code>）。</li>
<li><code>&lt;qualifier&gt;</code> 是下表 1 中的配置限定符，用于指定 要使用这些资源的屏幕配置（例如 <code>hdpi</code> 或 <code>xlarge</code>）。可以一次使用多个 <code>&lt;qualifier&gt;</code> — 只需使用短划线分隔每个 限定符。</li>
</ul>
</li>
<li>将适当的配置特定资源保存在此新目录下。这些资源 文件的名称必须与默认资源文件完全一样。</li>
</ol>
</li>
<li><p>配置限定符表</p>
<p>| 限定符            | 说明                                                         |      |<br>| —————– | ———————————————————— | —- |<br>| <code>small</code>           | 适用于小尺寸屏幕的资源。                                     |      |<br>| <code>normal</code>          | 适用于<em>正常</em>尺寸屏幕的资源。（这是基线尺寸。）               |      |<br>| <code>large</code>           | 适用于<em>大</em>尺寸屏幕的资源。                                   |      |<br>| <code>xlarge</code>          | 适用于<em>超大</em>尺寸屏幕的资源。                                 |      |<br>| <code>ldpi</code>            | 适用于低密度 (<em>ldpi</em>) 屏幕 (~120dpi) 的资源。                |      |<br>| <code>mdpi</code>            | 适用于中密度 (<em>mdpi</em>) 屏幕 (~160dpi) 的资源。（这是基线 密度。） |      |<br>| <code>hdpi</code>            | 适用于高密度 (<em>hdpi</em>) 屏幕 (~240dpi) 的资源。                |      |<br>| <code>xhdpi</code>           | 适用于超高密度 (<em>xhdpi</em>) 屏幕 (~320dpi) 的资源。             |      |<br>| <code>xxhdpi</code>          | 适用于超超高密度 (<em>xxhdpi</em>) 屏幕 (~480dpi) 的资源。          |      |<br>| <code>xxxhdpi</code>         | 适用于超超超高密度 (<em>xxxhdpi</em>) 屏幕 (~640dpi) 的资源。此限定符仅适用于 启动器图标，请参阅上面的<a href="https://developer.android.google.cn/guide/practices/screens_support#xxxhdpi-note" target="_blank" rel="noopener">注</a>。 |      |<br>| <code>nodpi</code>           | 适用于所有密度的资源。这些是密度独立的资源。不管当前屏幕的密度如何，系统都不会 缩放以此限定符标记的资源。 |      |<br>| <code>tvdpi</code>           | 适用于密度介于 mdpi 和 hdpi 之间屏幕（约为 213dpi）的资源。它并不是 “主要”密度组，主要用于电视，而大多数应用都不 需要它 — 对于大多数应用而言，提供 mdpi 和 hdpi 资源便已足够，系统将根据需要对其进行 缩放。如果发现必须提供 tvdpi 资源，应以 1.33*mdpi 的系数 调整其大小。例如，mdpi 屏幕的 100px x 100px 图像应该相当于 tvdpi 的 133px x 133px。 |      |<br>| <code>land</code>            | 适用于横屏（长宽比）的资源。                                 |      |<br>| <code>port</code>            | 适用于竖屏（高宽比）的资源。                                 |      |<br>| <code>long</code>     纵横比 | 适用于纵横比明显高于或宽于（分别在竖屏 或横屏时）基线屏幕配置的屏幕的资源。 |      |<br>| <code>notlong</code>         | 适用于使用纵横比类似于基线屏幕 配置的屏幕的资源。            |      |</p>
</li>
</ul>
<h4 id="设计替代布局和可绘制对象"><a href="#设计替代布局和可绘制对象" class="headerlink" title="设计替代布局和可绘制对象"></a>设计替代布局和可绘制对象</h4><ul>
<li><p><strong>替代布局</strong></p>
<ul>
<li>在小屏幕上测试时，可能会发现您的布局不太适合 屏幕。例如，小屏幕设备的屏幕宽度可能无法容纳一排 按钮。在此情况下，您应该为小屏幕提供调整 按钮大小或位置的替代布局。</li>
<li><p>在超大屏幕上测试时，可能会发现您的布局无法 有效地利用大屏幕，并且明显拉伸填满屏幕。 在此情况下，应该为超大屏幕提供替代布局，以提供 针对大屏幕（例如平板电脑）优化、重新设计的 UI。  虽然应用不使用替代布局也能在大屏幕上正常运行，但 必须让用户感觉您的应用看起来像是专为其设备而设计。如果 UI 明显拉伸，用户很可能对 应用体验不满意。</p>
</li>
<li><p>对比横屏测试和竖屏测试时 可能会发现，竖屏时置于底部的 UI 在横屏时应位于屏幕右侧。 </p>
</li>
<li>应确保布局<ol>
<li>适应小屏幕（让用户能实际使用您的应用）</li>
<li>已针对大屏幕优化，可以利用其他屏幕空间</li>
<li>已同时针对横屏和竖屏方向优化</li>
</ol>
</li>
</ul>
</li>
<li><h4 id="替代可绘制对象"><a href="#替代可绘制对象" class="headerlink" title="替代可绘制对象"></a>替代可绘制对象</h4><ul>
<li><p>基本上每个应用都应该具有不同密度的替代可绘制对象 资源，因为基本上每个应用都有启动器图标，而且该图标应该在 所有屏幕密度中看起来都很好。同样，如果您的应用中包含其他位图可绘制对象（例如 应用中的菜单图标或其他图形），则应该为不同密度提供替代版本或 每种密度一个版本。</p>
</li>
<li><p>要为不同的密度创建替代位图可绘制对象，应遵循六种通用密度之间的 <strong>3:4:6:8:12:16 缩放</strong> </p>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/20/API-Guide之App-Resources/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="作茧自缚">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/20/API-Guide之App-Resources/" itemprop="url">API Guide之App Resources</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-20T00:47:23+08:00">
                2018-03-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/guide/" itemprop="url" rel="index">
                    <span itemprop="name">guide</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/20/API-Guide之App-Resources/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/03/20/API-Guide之App-Resources/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Providing-Resources提供资源"><a href="#Providing-Resources提供资源" class="headerlink" title="Providing Resources提供资源"></a>Providing Resources提供资源</h1><blockquote>
<p>App应该始终外部化应用资源，如图像和代码中的字符串资源，这样有利于单独维护这些资源。并且应该将资源分组到专门命名的资源目录中，以便为特定的设备提供备用资源。在运行时，Android 会根据当前配置使用适当的资源。例如，您可能需要根据屏幕尺寸提供不同的 UI 布局，或者根据语言设置提供不同的字符串。</p>
</blockquote>
<h2 id="资源类型目录"><a href="#资源类型目录" class="headerlink" title="资源类型目录"></a>资源类型目录</h2><ul>
<li>项目 <code>res/</code> 目录内支持的资源目录（表1）。</li>
</ul>
<table>
<thead>
<tr>
<th>目录</th>
<th>资源类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>animator/</code></td>
<td>用于定义<a href="https://developer.android.google.cn/guide/topics/graphics/prop-animation.html" target="_blank" rel="noopener">属性动画</a>的 XML 文件。</td>
</tr>
<tr>
<td><code>anim/</code></td>
<td>定义<a href="https://developer.android.google.cn/guide/topics/graphics/view-animation.html#tween-animation" target="_blank" rel="noopener">渐变动画</a>的 XML 文件。（属性动画也可以保存在此目录中，但是为了区分这两种类型，属性动画首选 <code>animator/</code> 目录。）</td>
</tr>
<tr>
<td><code>color/</code></td>
<td>用于定义颜色状态列表的 XML 文件。请参阅<a href="https://developer.android.google.cn/guide/topics/resources/color-list-resource.html" target="_blank" rel="noopener">颜色状态列表资源</a></td>
</tr>
<tr>
<td><code>drawable/</code></td>
<td>位图文件（<code>.png</code>、<code>.9.png</code>、<code>.jpg</code>、<code>.gif</code>）或编译为以下可绘制对象资源子类型的 XML 文件：位图文件九宫格（可调整大小的位图）状态列表形状动画可绘制对象其他可绘制对象请参阅 <a href="https://developer.android.google.cn/guide/topics/resources/drawable-resource.html" target="_blank" rel="noopener">可绘制对象资源</a>。</td>
</tr>
<tr>
<td><code>mipmap/</code></td>
<td>适用于不同启动器图标密度的可绘制对象文件。如需了解有关使用 <code>mipmap/</code> 文件夹管理启动器图标的详细信息，请参阅<a href="https://developer.android.google.cn/tools/projects/index.html#mipmap" target="_blank" rel="noopener">管理项目概览</a>。</td>
</tr>
<tr>
<td><code>layout/</code></td>
<td>用于定义用户界面布局的 XML 文件。 请参阅<a href="https://developer.android.google.cn/guide/topics/resources/layout-resource.html" target="_blank" rel="noopener">布局资源</a>。</td>
</tr>
<tr>
<td><code>menu/</code></td>
<td>用于定义应用菜单（如选项菜单、上下文菜单或子菜单）的 XML 文件。请参阅<a href="https://developer.android.google.cn/guide/topics/resources/menu-resource.html" target="_blank" rel="noopener">菜单资源</a>。</td>
</tr>
<tr>
<td><code>raw/</code></td>
<td>要以原始形式保存的任意文件。要使用原始 <code>InputStream</code> 打开这些资源，请使用资源 ID（即 <code>R.raw.*filename*</code>）调用 <code>Resources.openRawResource()</code>。但是，如需访问原始文件名和文件层次结构，则可以考虑将某些资源保存在 <code>assets/</code> 目录下（而不是 <code>res/raw/</code>）。<code>assets/</code> 中的文件没有资源 ID，因此您只能使用 <code>AssetManager</code> 读取这些文件。</td>
</tr>
<tr>
<td><code>values/</code></td>
<td>包含字符串、整型数和颜色等简单值的 XML 文件。其他 <code>res/</code> 子目录中的 XML 资源文件是根据 XML 文件名定义单个资源，而 <code>values/</code> 目录中的文件可描述多个资源。对于此目录中的文件，<code>&lt;resources&gt;</code> 元素的每个子元素均定义一个资源。例如，<code>&lt;string&gt;</code> 元素创建 <code>R.string</code> 资源，<code>&lt;color&gt;</code> 元素创建 <code>R.color</code> 资源。由于每个资源均用其自己的 XML 元素定义，因此您可以根据自己的需要命名文件，并将不同的资源类型放在一个文件中。但是，为了清晰起见，您可能需要将独特的资源类型放在不同的文件中。 例如，对于可在此目录中创建的资源，下面给出了相应的文件名约定：arrays.xml，用于资源数组（<a href="https://developer.android.google.cn/guide/topics/resources/more-resources.html#TypedArray" target="_blank" rel="noopener">类型化数组</a>）。colors.xml：<a href="https://developer.android.google.cn/guide/topics/resources/more-resources.html#Color" target="_blank" rel="noopener">颜色值</a>。dimens.xml：<a href="https://developer.android.google.cn/guide/topics/resources/more-resources.html#Dimension" target="_blank" rel="noopener">尺寸值</a>。strings.xml：<a href="https://developer.android.google.cn/guide/topics/resources/string-resource.html" target="_blank" rel="noopener">字符串值</a>。styles.xml：<a href="https://developer.android.google.cn/guide/topics/resources/style-resource.html" target="_blank" rel="noopener">样式</a>。请参阅<a href="https://developer.android.google.cn/guide/topics/resources/string-resource.html" target="_blank" rel="noopener">字符串资源</a>、<a href="https://developer.android.google.cn/guide/topics/resources/style-resource.html" target="_blank" rel="noopener">样式资源</a>和<a href="https://developer.android.google.cn/guide/topics/resources/more-resources.html" target="_blank" rel="noopener">更多资源类型</a>。</td>
</tr>
<tr>
<td><code>xml/</code></td>
<td>可以在运行时通过调用 <code>Resources.getXML()</code> 读取的任意 XML 文件。各种 XML 配置文件（如<a href="https://developer.android.google.cn/guide/topics/search/searchable-config.html" target="_blank" rel="noopener">可搜索配置</a>）都必须保存在此处。</td>
</tr>
</tbody>
</table>
<h2 id="提供备用资源"><a href="#提供备用资源" class="headerlink" title="提供备用资源"></a>提供备用资源</h2><blockquote>
<p>几乎每个应用都应提供备用资源以支持特定的设备配置。</p>
</blockquote>
<ul>
<li>为一组资源指定特定于配置的备用资源：</li>
</ul>
<ol>
<li><p>在<code>res/</code>中创建一个以<code>&lt;resources_name&gt;-&lt;config_qualifier&gt;</code>形式命名的新目录。</p>
<ul>
<li><em>&lt;resources_name&gt;</em> 是相应默认资源的目录名称（如表 1 中所定义）。</li>
<li><em><qualifier></qualifier></em> 是指定要使用这些资源的各个配置的名称（如表 2 中所定义）。</li>
</ul>
<p>您可以追加多个 <em><qualifier></qualifier></em>。以短划线将其分隔。</p>
<p><strong>注意</strong>：追加多个限定符时，必须按照表 2 中列出的相同顺序放置它们。如果限定符的顺序错误，则该资源将被忽略。</p>
</li>
<li><p>将相应的备用资源保存在此新目录下。这些资源文件的名称必须与默认资源文件完全一样。</p>
<p>例如，以下是一些默认资源和备用资源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">res/</span><br><span class="line">    drawable/   </span><br><span class="line">        icon.png</span><br><span class="line">        background.png    </span><br><span class="line">    drawable-hdpi/  </span><br><span class="line">        icon.png</span><br><span class="line">        background.png</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>hdpi</code> 限定符表示该目录中的资源适用于屏幕密度较高的设备。其中每个可绘制对象目录中的图像已针对特定的屏幕密度调整大小，但是文件名完全相同。 这样一来，用于引用 <code>icon.png</code> 或 <code>background.png</code> 图像的资源 ID 始终相同，但是 Android 会通过将设备配置信息与资源目录名称中的限定符进行比较，选择最符合当前设备的各个资源版本。</p>
<p>Android 支持若干配置限定符，您可以通过使用短划线分隔每个限定符，向一个目录名称添加多个限定符。表 2 按优先顺序列出了有效的配置限定符；如果对资源目录使用多个限定符，则必须按照表中列出的顺序将它们添加到目录名称。</p>
</li>
</ol>
<ul>
<li>配置限定符名称(表2)</li>
</ul>
<table>
<thead>
<tr>
<th>配置</th>
<th>限定符值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>MCC 和 MNC</td>
<td>示例：<code>mcc310`</code>mcc310-mnc004<code></code>mcc208-mnc00`等等</td>
<td>移动国家代码 (MCC)，（可选）后跟设备 SIM 卡中的移动网络代码 (MNC)。例如，<code>mcc310</code> 是指美国的任一运营商，<code>mcc310-mnc004</code> 是指美国的 Verizon 公司，<code>mcc208-mnc00</code> 是指法国的 Orange 公司。如果设备使用无线电连接（GSM 手机），则 MCC 和 MNC 值来自 SIM 卡。也可以单独使用 MCC（例如，将国家/地区特定的合法资源包括在应用中）。如果只需根据语言指定，则改用“语言和区域”限定符（稍后进行介绍）。 如果决定使用 MCC 和 MNC 限定符，请谨慎执行此操作并测试限定符是否按预期工作。另请参阅配置字段 <code>mcc</code> 和 <code>mnc</code>，这两个字段分别表示当前的移动国家代码和移动网络代码。</td>
</tr>
<tr>
<td>语言和区域</td>
<td>示例：<code>en`</code>fr<code></code>en-rUS`等</td>
<td>语言通过由两个字母组成的 <a href="http://www.loc.gov/standards/iso639-2/php/code_list.php" target="_blank" rel="noopener">ISO 639-1</a> 语言代码定义，可以选择后跟两个字母组成的 <a href="http://www.iso.org/iso/en/prods-services/iso3166ma/02iso-3166-code-lists/list-en1.html" target="_blank" rel="noopener">ISO 3166-1-alpha-2</a> 区域码（前带小写字母“<code>r</code>”）。这些代码不区分大小写；<code>r</code> 前缀用于区分区域码。 不能单独指定区域。如果用户更改系统设置中的语言，它有可能在应用生命周期中发生改变。 如需了解这会在运行期间给应用带来哪些影响，请参阅<a href="https://developer.android.google.cn/guide/topics/resources/runtime-changes.html" target="_blank" rel="noopener">处理运行时变更</a>。有关针对其他语言本地化应用的完整指南，请参阅<a href="https://developer.android.google.cn/guide/topics/resources/localization.html" target="_blank" rel="noopener">本地化</a>。另请参阅 <code>locale</code> 配置字段，该字段表示当前的语言区域。</td>
</tr>
<tr>
<td>布局方向</td>
<td><code>ldrtl`</code>ldltr`</td>
<td>应用的布局方向。<code>ldrtl</code> 是指“布局方向从右到左”。<code>ldltr</code> 是指“布局方向从左到右”，这是默认的隐式值。它适用于布局、图片或值等任何资源。例如，若要针对阿拉伯语提供某种特定布局，并针对任何其他“从右到左”语言（如波斯语或希伯来语）提供某种通用布局，则可编码如下：<code>res/    layout/           main.xml  (Default layout)    layout-ar/          main.xml  (Specific layout for Arabic)    layout-ldrtl/          main.xml  (Any &quot;right-to-left&quot; language, except                  for Arabic, because the &quot;ar&quot; language qualifier                  has a higher precedence.)</code><strong>注</strong>：要为应用启用从右到左的布局功能，必须将 <a href="https://developer.android.google.cn/guide/topics/manifest/application-element.html#supportsrtl" target="_blank" rel="noopener"><code>supportsRtl</code></a> 设置为 <code>&quot;true&quot;</code>，并将 <a href="https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element.html#target" target="_blank" rel="noopener"><code>targetSdkVersion</code></a> 设置为 17 或更高版本。<em>此项为 API 级别 17 中新增配置。</em></td>
</tr>
<tr>
<td>smallestWidth</td>
<td><code>sw&lt;N&gt;dp</code>示例：<code>sw320dp`</code>sw600dp<code></code>sw720dp`等等</td>
<td>屏幕的基本尺寸，由可用屏幕区域的最小尺寸指定。 具体来说，设备的 smallestWidth 是屏幕可用高度和宽度的最小尺寸（您也可以将其视为屏幕的“最小可能宽度”）。无论屏幕的当前方向如何，您均可使用此限定符确保应用 UI 的可用宽度至少为 <code>&lt;N&gt;</code>dp。例如，如果布局要求屏幕区域的最小尺寸始终至少为 600dp，则可使用此限定符创建布局资源 <code>res/layout-sw600dp/</code>。仅当可用屏幕的最小尺寸至少为 600dp 时，系统才会使用这些资源，而不考虑 600dp 所代表的边是用户所认为的高度还是宽度。smallestWidth 是设备的固定屏幕尺寸特性；<strong>设备的 smallestWidth 不会随屏幕方向的变化而改变</strong>。设备的 smallestWidth 将屏幕装饰元素和系统 UI 考虑在内。例如，如果设备的屏幕上有一些永久性 UI 元素占据沿 smallestWidth 轴的空间，则系统会声明 smallestWidth 小于实际屏幕尺寸，因为这些屏幕像素不适用于您的 UI。 因此，使用的值应该是<em>布局所需要</em>的实际最小尺寸（通常，无论屏幕的当前方向如何，此值都是布局支持的“最小宽度”）。以下是一些可用于普通屏幕尺寸的值：320，适用于屏幕配置如下的设备：240x320 ldpi（QVGA 手机）320x480 mdpi（手机）480x800 hdpi（高密度手机）480，适用于 480x800 mdpi 之类的屏幕（平板电脑/手机）。600，适用于 600x1024 mdpi 之类的屏幕（7 英寸平板电脑）。720，适用于 720x1280 mdpi 之类的屏幕（10 英寸平板电脑）。应用为多个资源目录提供不同的 smallestWidth 限定符值时，系统会使用最接近（但未超出）设备 smallestWidth 的值。<em>此项为 API 级别 13 中新增配置。</em>另请参阅 <a href="https://developer.android.google.cn/guide/topics/manifest/supports-screens-element.html#requiresSmallest" target="_blank" rel="noopener"><code>android:requiresSmallestWidthDp</code></a> 属性和 <code>smallestScreenWidthDp</code> 配置字段，前者声明与应用兼容的最小 smallestWidth；后者存放设备的 smallestWidth 值。如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅<a href="https://developer.android.google.cn/guide/practices/screens_support.html" target="_blank" rel="noopener">支持多种屏幕</a>开发者指南。</td>
</tr>
<tr>
<td>可用宽度</td>
<td><code>w&lt;N&gt;dp</code>示例：<code>w720dp</code>等</td>
<td>指定资源应该使用的最小可用屏幕宽度，以 <code>dp</code> 为单位，由 <code>&lt;N&gt;</code> 值定义。在横向和纵向之间切换时，为了匹配当前实际宽度，此配置值也会随之发生变化。应用为多个资源目录提供不同的此配置值时，系统会使用最接近（但未超出）设备当前屏幕宽度的值。 此处的值考虑到了屏幕装饰元素，因此如果设备显示屏的左边缘或右边缘上有一些永久性 UI 元素，考虑到这些 UI 元素，它会使用小于实际屏幕尺寸的宽度值，这样会减少应用的可用空间。<em>此项为 API 级别 13 中新增配置。</em>另请参阅 <code>screenWidthDp</code> 配置字段，该字段存放当前屏幕宽度。如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅<a href="https://developer.android.google.cn/guide/practices/screens_support.html" target="_blank" rel="noopener">支持多种屏幕</a>开发者指南。</td>
</tr>
<tr>
<td>可用高度</td>
<td><code>h&lt;N&gt;dp</code>示例：<code>h720dp</code>等</td>
<td>指定资源应该使用的最小可用屏幕高度，以“dp”为单位，由 <code>&lt;N&gt;</code> 值定义。 在横向和纵向之间切换时，为了匹配当前实际高度，此配置值也会随之发生变化。应用为多个资源目录提供不同的此配置值时，系统会使用最接近（但未超出）设备当前屏幕高度的值。 此处的值考虑到了屏幕装饰元素，因此如果设备显示屏的上边缘或下边缘有一些永久性 UI 元素，考虑到这些 UI 元素，同时为减少应用的可用空间，它会使用小于实际屏幕尺寸的高度值。 非固定的屏幕装饰元素（例如，全屏时可隐藏的手机状态栏）并不在考虑范围内，标题栏或操作栏等窗口装饰也不在考虑范围内，因此应用必须准备好处理稍小于其所指定值的空间。<em>此项为 API 级别 13 中新增配置。</em>另请参阅 <code>screenHeightDp</code> 配置字段，该字段存放当前屏幕宽度。如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅<a href="https://developer.android.google.cn/guide/practices/screens_support.html" target="_blank" rel="noopener">支持多种屏幕</a>开发者指南。</td>
</tr>
<tr>
<td>屏幕尺寸</td>
<td><code>small`</code>normal<code>large</code>xlarge`</td>
<td><code>small</code>：尺寸类似于低密度 QVGA 屏幕的屏幕。小屏幕的最小布局尺寸约为 320x426 dp 单位。例如，QVGA 低密度屏幕和 VGA 高密度屏幕。<code>normal</code>：尺寸类似于中等密度 HVGA 屏幕的屏幕。标准屏幕的最小布局尺寸约为 320x470 dp 单位。例如，WQVGA 低密度屏幕、HVGA 中等密度屏幕、WVGA 高密度屏幕。<code>large</code>：尺寸类似于中等密度 VGA 屏幕的屏幕。 大屏幕的最小布局尺寸约为 480x640 dp 单位。 例如，VGA 和 WVGA 中等密度屏幕。<code>xlarge</code>：明显大于传统中等密度 HVGA 屏幕的屏幕。超大屏幕的最小布局尺寸约为 720x960 dp 单位。在大多数情况下，屏幕超大的设备体积过大，不能放进口袋，最常见的是平板式设备。 <em>API 级别 9 中的新增配置。**</em>注<strong>：使用尺寸限定符并不表示资源仅适用于该尺寸的屏幕。 如果没有为备用资源提供最符合当前设备配置的限定符，则系统可能使用其中<a href="https://developer.android.google.cn/guide/topics/resources/providing-resources.html#BestMatch" target="_blank" rel="noopener">最匹配</a>的资源。</strong>注意<strong>：如果所有资源均使用大于当前屏幕的尺寸限定符，则系统</strong>不*<em>会使用这些资源，并且应用在运行时将会崩溃（例如，如果所有布局资源均用 <code>xlarge</code> 限定符标记，但设备是标准尺寸的屏幕）。</em>此项为 API 级别 4 中新增配置。*如需了解详细信息，请参阅<a href="https://developer.android.google.cn/guide/practices/screens_support.html" target="_blank" rel="noopener">支持多种屏幕</a>。另请参阅 <code>screenLayout</code> 配置字段，该字段表示屏幕是小尺寸、标准尺寸还是大尺寸。</td>
</tr>
<tr>
<td>屏幕纵横比</td>
<td><code>long`</code>notlong`</td>
<td><code>long</code>：宽屏，如 WQVGA、WVGA、FWVGA<code>notlong</code>：非宽屏，如 QVGA、HVGA 和 VGA<em>此项为 API 级别 4 中新增配置。</em>它完全基于屏幕的纵横比（宽屏较宽），而与屏幕方向无关。另请参阅 <code>screenLayout</code> 配置字段，该字段指示屏幕是否为宽屏。</td>
</tr>
<tr>
<td>圆形屏幕</td>
<td><code>round`</code>notround`</td>
<td><code>round</code>：圆形屏幕，例如圆形可穿戴式设备<code>notround</code>：方形屏幕，例如手机或平板电脑<em>此项为 API 级别 23 中新增配置。</em>另请参阅 <code>isScreenRound()</code> 配置方法，其指示屏幕是否为宽屏。</td>
</tr>
<tr>
<td>屏幕方向</td>
<td><code>port`</code>land`</td>
<td><code>port</code>：设备处于纵向（垂直）<code>land</code>：设备处于横向（水平）如果用户旋转屏幕，它有可能在应用生命周期中发生改变。 如需了解这会在运行期间给应用带来哪些影响，请参阅<a href="https://developer.android.google.cn/guide/topics/resources/runtime-changes.html" target="_blank" rel="noopener">处理运行时变更</a>。另请参阅 <code>orientation</code> 配置字段，该字段指示当前的设备方向。</td>
</tr>
<tr>
<td>UI 模式</td>
<td><code>car`</code>desk<code></code>televisionappliancewatch  `</td>
<td><code>car</code>：设备正在车载手机座上显示<code>desk</code>：设备正在桌面手机座上显示<code>television</code>：设备正在电视上显示，为用户提供“十英尺”体验，其 UI 位于远离用户的大屏幕上，主要面向方向键或其他非指针式交互<code>appliance</code>：设备用作不带显示屏的装置<code>watch</code>：设备配有显示屏，戴在手腕上<em>此项为 API 级别 8 中新增配置，API 13 中新增电视配置，API 20 中新增手表配置。</em>如需了解应用在设备插入手机座或从中移除时的响应方式，请阅读<a href="https://developer.android.google.cn/training/monitoring-device-state/docking-monitoring.html" target="_blank" rel="noopener">确定并监控插接状态和类型</a>。如果用户将设备放入手机座中，它有可能在应用生命周期中发生改变。 可以使用 <code>UiModeManager</code> 启用或禁用其中某些模式。如需了解这会在运行期间给应用带来哪些影响，请参阅<a href="https://developer.android.google.cn/guide/topics/resources/runtime-changes.html" target="_blank" rel="noopener">处理运行时变更</a>。</td>
</tr>
<tr>
<td>夜间模式</td>
<td><code>night`</code>notnight`</td>
<td><code>night</code>：夜间<code>notnight</code>：白天<em>此项为 API 级别 8 中新增配置。</em>如果夜间模式停留在自动模式（默认），它有可能在应用生命周期中发生改变。在这种情况下，该模式会根据当天的时间进行调整。 可以使用 <code>UiModeManager</code> 启用或禁用此模式。如需了解这会在运行期间给应用带来哪些影响，请参阅<a href="https://developer.android.google.cn/guide/topics/resources/runtime-changes.html" target="_blank" rel="noopener">处理运行时变更</a>。</td>
</tr>
<tr>
<td>屏幕像素密度 (dpi)</td>
<td><code>ldpi</code>…<code>nodpi`</code>tvdpi<code></code>anydpi`</td>
<td><code>ldpi</code>：低密度屏幕；约为 120dpi。<code>mdpi</code>：中等密度（传统 HVGA）屏幕；约为 160dpi。<code>hdpi</code>：高密度屏幕；约为 240dpi。<code>xhdpi</code>：超高密度屏幕；约为 320dpi。<em>此项为 API 级别 8 中新增配置</em><code>xxhdpi</code>：超超高密度屏幕；约为 480dpi。<em>此项为 API 级别 16 中新增配置</em><code>xxxhdpi</code>：超超超高密度屏幕使用（仅限启动器图标，请参阅“支持多种屏幕”中的<a href="https://developer.android.google.cn/guide/practices/screens_support.html#xxxhdpi-note" target="_blank" rel="noopener">注释</a>）；约为 640dpi。 <em>此项为 API 级别 18 中新增配置</em><code>nodpi</code>：它可用于您不希望缩放以匹配设备密度的位图资源。<code>tvdpi</code>：密度介于 mdpi 和 hdpi 之间的屏幕；约为 213dpi。它并不是“主要”密度组， 主要用于电视，而大多数应用都不需要它。对于大多数应用而言，提供 mdpi 和 hdpi 资源便已足够，系统将根据需要对其进行缩放。<em>此项为 API 级别 13 中新增配置</em><code>anydpi</code>：此限定符适合所有屏幕密度，其优先级高于其他限定符。 这对于<a href="https://developer.android.google.cn/training/material/drawables.html#VectorDrawables" target="_blank" rel="noopener">矢量可绘制对象</a>很有用。 <em>此项为 API 级别 21 中新增配置</em>六个主要密度之间的缩放比为 3:4:6:8:12:16（忽略 tvdpi 密度）。因此，9x9 (ldpi) 位图相当于 12x12 (mdpi)、18x18 (hdpi)、24x24 (xhdpi) 位图，依此类推。如果您认为图像资源在电视或其他某些设备上呈现的效果不够好，而想尝试使用 tvdpi 资源，则缩放比例为 1.33*mdpi。例如，mdpi 屏幕的 100px x 100px 图像应该相当于 tvdpi 的133px x 133px。<strong>注</strong>：使用密度限定符并不表示资源仅适用于该密度的屏幕。 如果没有为备用资源提供最符合当前设备配置的限定符，则系统可能使用其中<a href="https://developer.android.google.cn/guide/topics/resources/providing-resources.html#BestMatch" target="_blank" rel="noopener">最匹配</a>的资源。如需了解有关如何处理不同屏幕密度以及 Android 如何缩放位图以适应当前密度的详细信息，请参阅<a href="https://developer.android.google.cn/guide/practices/screens_support.html" target="_blank" rel="noopener">支持多种屏幕</a>。</td>
</tr>
<tr>
<td></td>
<td><code>notouch`</code>finger`</td>
<td><code>notouch</code>：设备没有触摸屏。<code>finger</code>：设备有一个专供用户通过手指直接与其交互的触摸屏。另请参阅 <code>touchscreen</code> 配置字段，该字段指示设备上的触摸屏类型。</td>
</tr>
<tr>
<td>键盘可用性</td>
<td><code>keysexposed`</code>keyshidden<code></code>keyssoft`</td>
<td><code>keysexposed</code>：设备具有可用的键盘。如果设备启用了软键盘（不无可能），那么即使硬键盘没有展示给用户，哪怕设备没有硬键盘，也可以使用此限定符。 如果没有提供或已经禁用软键盘，则只有在显示硬键盘时才会使用此限定符。<code>keyshidden</code>：设备具有可用的硬键盘，但它处于隐藏状态，且设备没有启用软键盘。<code>keyssoft</code>：设备已经启用软键盘（无论是否可见）。如果提供了 <code>keysexposed</code> 资源，但未提供 <code>keyssoft</code> 资源，那么只要系统已经启用软键盘，就会使用<code>keysexposed</code> 资源，而不考虑键盘是否可见。如果用户打开硬键盘，它有可能在应用生命周期中发生改变。 如需了解这会在运行期间给应用带来哪些影响，请参阅<a href="https://developer.android.google.cn/guide/topics/resources/runtime-changes.html" target="_blank" rel="noopener">处理运行时变更</a>。另请参阅配置字段 <code>hardKeyboardHidden</code> 和 <code>keyboardHidden</code>，这两个字段分别指示硬键盘的可见性和任何一种键盘（包括软键盘）的可见性。</td>
</tr>
<tr>
<td>主要文本输入法</td>
<td><code>nokeys`</code>qwerty<code></code>12key`</td>
<td><code>nokeys</code>：设备没有用于文本输入的硬按键。<code>qwerty</code>：设备具有标准硬键盘（无论是否对用户可见）。<code>12key</code>：设备具有 12 键硬键盘（无论是否对用户可见）。另请参阅 <code>keyboard</code> 配置字段，该字段指示可用的主要文本输入法。</td>
</tr>
<tr>
<td>导航键可用性</td>
<td><code>navexposed`</code>navhidden`</td>
<td><code>navexposed</code>：导航键可供用户使用。<code>navhidden</code>：导航键不可用（例如，位于密封盖子后面）。如果用户显示导航键，它有可能在应用生命周期中发生改变。 如需了解这会在运行期间给应用带来哪些影响，请参阅<a href="https://developer.android.google.cn/guide/topics/resources/runtime-changes.html" target="_blank" rel="noopener">处理运行时变更</a>。另请参阅 <code>navigationHidden</code> 配置字段，该字段指示导航键是否处于隐藏状态。</td>
</tr>
<tr>
<td>主要非触摸导航方法</td>
<td><code>nonav`</code>dpad<code>trackball</code>wheel`</td>
<td><code>nonav</code>：除了使用触摸屏以外，设备没有其他导航设施。<code>dpad</code>：设备具有用于导航的方向键。<code>trackball</code>：设备具有用于导航的轨迹球。<code>wheel</code>：设备具有用于导航的方向盘（不常见）。另请参阅 <code>navigation</code> 配置字段，该字段指示可用的导航方法类型。</td>
</tr>
<tr>
<td>平台版本（API 级别）</td>
<td>示例：<code>v3`</code>v4<code></code>v7`等等</td>
<td>设备支持的 API 级别。例如，<code>v1</code> 对应于 API 级别 1（带有 Android 1.0 或更高版本系统的设备），<code>v4</code> 对应于 API 级别 4（带有 Android 1.6 或更高版本系统的设备）。如需了解有关这些值的详细信息，请参阅 <a href="https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element.html#ApiLevels" target="_blank" rel="noopener">Android API 级别</a>文档。</td>
</tr>
</tbody>
</table>
<h2 id="限定符命名规则"><a href="#限定符命名规则" class="headerlink" title="限定符命名规则"></a>限定符命名规则</h2><ul>
<li>用配置限定符名称的规则：<ul>
<li>可以为单组资源指定多个限定符，并使用短划线分隔。例如，<code>drawable-en-rUS-land</code> 适用于横排美国英语设备。</li>
<li>这些限定符必须遵循表 2中列出的顺序。例如：<ul>
<li>错误：<code>drawable-hdpi-port/</code></li>
<li>正确：<code>drawable-port-hdpi/</code></li>
</ul>
</li>
</ul>
</li>
<li>不能嵌套备用资源目录。例如，您不能拥有 <code>res/drawable/drawable-en/</code>。</li>
<li>值不区分大小写。在处理之前，资源编译器会将目录名称转换为小写，以避免不区分大小写的文件系统出现问题。 名称中使用的任何大写字母只是为了便于认读。</li>
<li>对于每种限定符类型，仅支持一个值。例如，若要对西班牙语和法语使用相同的可绘制对象文件，则您肯定不能拥有名为 <code>drawable-rES-rFR/</code> 的目录，而是需要两个包含相应文件的资源目录，如 <code>drawable-rES/</code> 和 <code>drawable-rFR/</code>。然而，实际上您无需将相同的文件都复制到这两个位置。相反，您可以创建指向资源的别名。 请参阅下面的<a href="https://developer.android.google.cn/guide/topics/resources/providing-resources.html#AliasResources" target="_blank" rel="noopener">创建别名资源</a>。</li>
</ul>
<h2 id="创建别名资源"><a href="#创建别名资源" class="headerlink" title="创建别名资源"></a>创建别名资源</h2><blockquote>
<p>如果想将某一资源用于多种设备配置（但是不想作为默认资源提供），则无需将同一资源放入多个备用资源目录中。 而是可以（在某些情况下）创建备用资源，充当保存在默认资源目录下的资源的别名。（<strong>注</strong>：并非所有资源都会提供相应机制让您创建指向其他资源的别名。 特别是，<code>xml/</code> 目录中的动画资源、菜单资源、原始资源以及其他未指定资源均不提供此功能。）</p>
<p>例如，假设您有一个应用图标 <code>icon.png</code>，并且需要不同语言区域的独特版本。 但是，加拿大英语和加拿大法语这两种语言区域需要使用同一版本。 您可能会认为需要将相同的图像复制到加拿大英语和加拿大法语对应的资源目录中，但事实并非如此。 相反，可以将用于二者的图像另存为 <code>icon_ca.png</code>（除 <code>icon.png</code> 以外的任何名称），并将其放入默认 <code>res/drawable/</code> 目录中。然后，在 <code>res/drawable-en-rCA/</code> 和 <code>res/drawable-fr-rCA/</code> 中创建 <code>icon.xml</code> 文件，使用 <code>&lt;bitmap&gt;</code> 元素引用 <code>icon_ca.png</code> 资源。这样，您只需存储 PNG 文件的一个版本和两个指向该版本的小型 XML 文件。（XML 文件示例如下。）</p>
</blockquote>
<ul>
<li><h4 id="可绘制对象"><a href="#可绘制对象" class="headerlink" title="可绘制对象"></a>可绘制对象</h4><ul>
<li><p>要创建指向现有可绘制对象的别名，请使用 <bitmap> 元素。例如：</bitmap></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;bitmap xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:src=&quot;@drawable/icon_ca&quot; /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果将此文件另存为 <code>icon.xml</code>（例如，在备用资源目录中，另存为 <code>res/drawable-en-rCA/</code>），则会编译到可作为 <code>R.drawable.icon</code> 引用的资源中，但实际上它是 <code>R.drawable.icon_ca</code> 资源（保存在 <code>res/drawable/</code> 中）的别名。</p>
</li>
</ul>
</li>
<li><h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><ul>
<li><p>要创建指向现有布局的别名，请使用包装在 <code>&lt;merge&gt;</code> 中的 <code>&lt;include&gt;</code> 元素。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;merge&gt;</span><br><span class="line">    &lt;include layout=&quot;@layout/main_ltr&quot;/&gt;</span><br><span class="line">&lt;/merge&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果将此文件另存为 <code>main.xml</code>，则会编译到可作为 <code>R.layout.main</code> 引用的资源中，但实际上它是 <code>R.layout.main_ltr</code> 资源的别名。</p>
</li>
</ul>
</li>
<li><h4 id="字符串和其他简单值"><a href="#字符串和其他简单值" class="headerlink" title="字符串和其他简单值"></a>字符串和其他简单值</h4><ul>
<li><p>要创建指向现有字符串的别名，只需将所需字符串的资源 ID 用作新字符串的值即可。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;string name=&quot;hello&quot;&gt;Hello&lt;/string&gt;</span><br><span class="line">    &lt;string name=&quot;hi&quot;&gt;@string/hello&lt;/string&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://developer.android.google.cn/guide/topics/resources/more-resources.html" target="_blank" rel="noopener">其他简单值</a>的原理相同。 例如，颜色：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;color name=&quot;red&quot;&gt;#f00&lt;/color&gt;</span><br><span class="line">    &lt;color name=&quot;highlight&quot;&gt;@color/red&lt;/color&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="利用资源提供最佳设备兼容性"><a href="#利用资源提供最佳设备兼容性" class="headerlink" title="利用资源提供最佳设备兼容性"></a>利用资源提供最佳设备兼容性</h2><blockquote>
<p>要使应用支持多种设备配置，则务必为应用使用的每种资源类型提供默认资源，这一点非常重要。\</p>
<p>例如，如果应用支持多种语言，请始终包含不带<a href="https://developer.android.google.cn/guide/topics/resources/providing-resources.html#LocaleQualifier" target="_blank" rel="noopener">语言和区域限定符</a>的 <code>values/</code> 目录（用于保存字符串）。相反，如果您将所有字符串放入带有语言和区域限定符的目录中，则在语言设置不支持您的字符串的设备上运行应用时，应用将会崩溃。 但是，只要提供默认 <code>values/</code> 资源，应用就会正常运行（即使用户不理解该语言，这也总比崩溃要好）。</p>
<p>如果根据屏幕方向提供不同的布局资源，则应选择一个方向作为默认方向。 例如，不要在 <code>layout-land/</code> 和 <code>layout-port/</code> 中分别提供横向和纵向的布局资源，而是保留其中之一作为默认设置，例如：<code>layout/</code> 用于横向，<code>layout-port/</code> 用于纵向。</p>
<p>提供默认资源至关重要，这不仅仅因为应用可能在超出预期的配置上运行，也因为新版 Android 有时会添加旧版本不支持的配置限定符。若要使用新的资源限定符，又希望维持对旧版 Android 的代码兼容性，则当旧版 Android 运行应用时，如果不提供默认资源，应用将会崩溃，这是因为它无法使用以新限定符命名的资源。例如，如果将 <a href="https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element.html#min" target="_blank" rel="noopener"><code>minSdkVersion</code></a> 设置为 4，并使用<a href="https://developer.android.google.cn/guide/topics/resources/providing-resources.html#NightQualifier" target="_blank" rel="noopener">夜间模式</a>（<code>night</code> 或 <code>notnight</code>，API 级别 8 中新增配置）限定所有可绘制对象资源，则 API 级别 4 设备无法访问可绘制对象资源，而且会崩溃。在这种情况下，您可能希望 <code>notnight</code> 成为默认资源，为此，您应排除该限定符，使可绘制对象资源位于 <code>drawable/</code> 或 <code>drawable-night/</code> 中。</p>
<p>因此，为了提供最佳设备兼容性，请始终为应用正确运行所必需的资源提供默认资源。 然后，使用配置限定符为特定的设备配置创建备用资源。</p>
<p>这条规则有一个例外：如果应用的 <a href="https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element.html#min" target="_blank" rel="noopener"><code>minSdkVersion</code></a> 为 4 或更高版本，则在提供带<a href="https://developer.android.google.cn/guide/topics/resources/providing-resources.html#DensityQualifier" target="_blank" rel="noopener">屏幕密度</a>限定符的备用可绘制对象资源时，不需要默认可绘制对象资源。 即使没有默认可绘制对象资源，Android 也可以从备用屏幕密度中找到最佳匹配项并根据需要缩放位图。 但是，为了在所有类型的设备上提供最佳体验，您应该为所有三种类型的密度提供备用可绘制对象。</p>
</blockquote>
<h2 id="Android-如何查找最佳匹配资源"><a href="#Android-如何查找最佳匹配资源" class="headerlink" title="Android 如何查找最佳匹配资源"></a>Android 如何查找最佳匹配资源</h2><ul>
<li><p>当请求要为其提供备用资源的资源时，Android 会根据当前的设备配置选择要在运行时使用的备用资源。为演示 Android 如何选择备用资源，假设以下可绘制对象目录分别包含相同图像的不同版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">drawable/</span><br><span class="line">drawable-en/</span><br><span class="line">drawable-fr-rCA/</span><br><span class="line">drawable-en-port/</span><br><span class="line">drawable-en-notouch-12key/</span><br><span class="line">drawable-port-ldpi/</span><br><span class="line">drawable-port-notouch-12key/</span><br></pre></td></tr></table></figure>
</li>
<li><p>同时，通过将设备配置与可用的备用资源进行比较，Android 从 <code>drawable-en-port</code> 中选择可绘制对象。假设设备配置如下：</p>
<ul>
<li>语言区域 = <code>en-GB</code> </li>
<li>屏幕方向 = <code>port</code> </li>
<li>屏幕像素密度 = <code>hdpi</code> </li>
<li>触摸屏类型 = <code>notouch</code> </li>
<li>主要文本输入法 = <code>12key</code></li>
</ul>
</li>
<li><p>系统使用以下逻辑决定要使用的资源：</p>
<ol>
<li><p>淘汰与设备配置冲突的资源文件。</p>
</li>
<li><p>选择列表中（下一个）优先级最高的限定符。（先从 MCC 开始，然后下移。）</p>
<p><img src="http://ouv36g1sw.bkt.clouddn.com/Android%20%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E6%9C%80%E4%BD%B3%E5%8C%B9%E9%85%8D%E8%B5%84%E6%BA%90%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE" alt="Android 如何查找最佳匹配资源的流程图"></p>
</li>
<li><p>是否有资源目录包括此限定符?</p>
<ul>
<li>若无，请返回到第 2 步，看看下一个限定符。（在该示例中，除非达到语言限定符，否则答案始终为“否”。）</li>
<li>若有，请继续执行第 4 步。</li>
</ul>
</li>
<li><p>淘汰不含此限定符的资源目录。在该示例中，系统会淘汰所有不含语言限定符的目录。(<strong>例外：</strong>如果涉及的限定符是屏幕像素密度，则 Android 会选择最接近设备屏幕密度的选项。通常，Android 倾向于缩小大型原始图像，而不是放大小型原始图像。请参阅<a href="https://developer.android.google.cn/guide/practices/screens_support.html" target="_blank" rel="noopener">支持多种屏幕</a>)。</p>
</li>
<li><p>返回并重复第 2 步、第 3 步和第 4 步，直到只剩下一个目录为止。在此示例中，屏幕方向是下一个判断是否匹配的限定符。因此，未指定屏幕方向的资源被淘汰：</p>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>尽管对所请求的每个资源均执行此程序，但是系统仍会对某些方面做进一步优化。 例如，系统一旦知道设备配置，即会淘汰可能永远无法匹配的备用资源。 比如说，如果配置语言是英语（“en”），则系统绝不会将语言限定符设置为非英语的任何资源目录包含在选中的资源池中（不过，仍会将不带语言限定符的资源目录包含在该池中）。</p>
<p>根据屏幕尺寸限定符选择资源时，如果没有更好的匹配资源，则系统将使用专为小于当前屏幕的屏幕而设计的资源（例如，如有必要，大尺寸屏幕将使用标准尺寸的屏幕资源）。 但是，如果唯一可用的资源大于当前屏幕，则系统<strong>不会</strong>使用这些资源，并且如果没有其他资源与设备配置匹配，应用将会崩溃（例如，如果所有布局资源均用 <code>xlarge</code> 限定符标记，但设备是标准尺寸的屏幕）。</p>
<p><strong>注</strong>：限定符的优先顺序（<a href="https://developer.android.google.cn/guide/topics/resources/providing-resources.html#table2" target="_blank" rel="noopener">表 2</a> 中）比与设备完全匹配的限定符数量更加重要。例如，在上面的第 4 步中，列表剩下的最后选项包括三个与设备完全匹配的限定符（方向、触摸屏类型和输入法），而 <code>drawable-en</code> 只有一个匹配参数（语言）。但是，语言的优先顺序高于其他两个限定符，因此<code>drawable-port-notouch-12key</code> 被淘汰。</p>
</blockquote>
<h1 id="Accessing-Resources访问资源"><a href="#Accessing-Resources访问资源" class="headerlink" title="Accessing Resources访问资源"></a>Accessing Resources访问资源</h1><blockquote>
<p>在应用中提供资源后（<a href="https://developer.android.google.cn/guide/topics/resources/providing-resources.html" target="_blank" rel="noopener">提供资源</a>中对此做了阐述），可通过引用其资源 ID 来应用该资源。 所有资源 ID 都在您项目的 <code>R</code> 类中定义，后者由 <code>aapt</code> 工具自动生成。</p>
<p>编译应用时，<code>aapt</code> 会生成 <code>R</code> 类，其中包含您的 <code>res/</code> 目录中所有资源的资源 ID。 每个资源类型都有对应的 <code>R</code>子类（例如，<code>R.drawable</code> 对应于所有可绘制对象资源），而该类型的每个资源都有对应的静态整型数（例如，<code>R.drawable.icon</code>）。这个整型数就是可用来检索资源的资源 ID。</p>
<p>尽管资源 ID 是在 <code>R</code> 类中指定的，但应该永远都不需要在其中查找资源 ID。</p>
</blockquote>
<ul>
<li>资源 ID 始终由以下部分组成：<ul>
<li><strong>资源类型</strong>：每个资源都被分到一个“类型”组中，例如 <code>string</code>、<code>drawable</code> 和 <code>layout</code>。</li>
<li><strong>资源名称</strong>，它是不包括扩展名的文件名；或是 XML <code>android:name</code> 属性中的值，如果资源是简单值的话（例如字符串）。</li>
</ul>
</li>
<li>访问资源的方法有两种：<ul>
<li><strong>在代码中：</strong>使用来自 <code>R</code> 类的某个子类的静态整型数，如：<code>R.string.hello</code></li>
<li><strong>在 XML 中：</strong>使用同样与您 <code>R</code> 类中定义的资源 ID 对应的特殊 XML 语法，如<code>@string/hello</code>。</li>
</ul>
</li>
</ul>
<p>##在代码中访问资源</p>
<ul>
<li><strong>语法</strong>：[&lt;package_name&gt;.]R.&lt;resource_type&gt;.&lt;resource_name&gt;<ul>
<li><em>&lt;package_name&gt;</em> 是资源所在包的名称（如果引用的资源来自您自己的资源包，则不需要）。</li>
<li><em>&lt;resource_type&gt;</em> 是资源类型的 <code>R</code> 子类。</li>
<li><em>&lt;resource_name&gt;</em> 是不带扩展名的资源文件名，或 XML 元素中的 <code>android:name</code> 属性值（如果资源是简单值）</li>
</ul>
</li>
<li><strong>用例</strong>：<code>getWindow().setBackgroundDrawableResource(R.drawable.my_background_image) ;</code></li>
</ul>
<h2 id="在-XML-中访问资源"><a href="#在-XML-中访问资源" class="headerlink" title="在 XML 中访问资源"></a>在 XML 中访问资源</h2><ul>
<li><p>利用对现有资源的引用为某些 XML 属性和元素定义值。</p>
</li>
<li><p><strong>语法：</strong>@[&lt;package_name&gt;:]&lt;resource_type&gt;/&lt;resource_name&gt;</p>
<ul>
<li><code>&lt;package_name&gt;</code> 是资源所在包的名称（如果引用的资源来自相同的包，则不需要）</li>
<li><code>&lt;resource_type&gt;</code> 是资源类型的 <code>R</code> 子类</li>
<li><code>&lt;resource_name&gt;</code> 是不带扩展名的资源文件名，或 XML 元素中的 <code>android:name</code> 属性值（如果资源是简单值）。</li>
</ul>
</li>
<li><p><strong>用例：</strong>在某些情况下，您必须使用资源作为 XML 中的值（例如，对小部件应用可绘制图像），但您也可以在 XML 中任何接受简单值的地方使用资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">   &lt;color name=&quot;opaque_red&quot;&gt;#f00&lt;/color&gt;</span><br><span class="line">   &lt;string name=&quot;hello&quot;&gt;Hello!&lt;/string&gt;</span><br><span class="line">&lt;/resources&gt;</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;EditText xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;fill_parent&quot;</span><br><span class="line">    android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">    android:textColor=&quot;@color/opaque_red&quot;</span><br><span class="line">    android:text=&quot;@string/hello&quot; /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>引用样式属性：</strong>通过样式属性资源在当前应用的风格主题中引用某个属性的值。 通过引用样式属性，可以不采用为 UI 元素提供硬编码值这种方式，而是通过为 UI 元素设置样式，使其匹配当前风格主题提供的标准变型来定制这些元素的外观。引用样式属性的实质作用是，“在当前风格主题中使用此属性定义的样式”。要引用样式属性，名称语法几乎与普通资源格式完全相同，只不过将 at 符号 (<code>@</code>) 改为问号 (<code>?</code>)，资源类型部分为可选项。 例如：</p>
<p><code>?&lt;package_name&gt;:/&lt;resource_name&gt;</code></p>
</li>
</ul>
<ul>
<li><h2 id="访问平台资源"><a href="#访问平台资源" class="headerlink" title="访问平台资源"></a>访问平台资源</h2><blockquote>
<p>Android 包含许多标准资源，例如样式、风格主题和布局。要访问这些资源，可以通过 <code>android</code> 包名称限定您的资源引用。例如，将 Android 提供的布局资源用于 <code>ListAdapter</code> 中的列表项：<code>setListAdapter(new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, myarray));</code></p>
</blockquote>
<h1 id="Handing-Runtime-Change处理运行时变更"><a href="#Handing-Runtime-Change处理运行时变更" class="headerlink" title="Handing Runtime Change处理运行时变更"></a>Handing Runtime Change处理运行时变更</h1><blockquote>
<p>有些设备配置可能会在运行时发生变化（例如屏幕方向、键盘可用性及语言）。发生这种变化时，Android 会重启正在运行的 <code>Activity</code>（先后调用 <code>onDestroy()</code> 和 <code>onCreate()</code>）。重启行为旨在通过利用与新设备配置匹配的备用资源自动重新加载您的应用，来帮助它适应新配置。</p>
<p>Activity必须通过常规的Activity生命周期恢复以前的状态，在Activity生命周期中，Android 会在销毁 Activity 之前调用 <code>onSaveInstanceState()</code>以保存有关应用的相关状态的数据。然后可以在 <code>onCreate()</code> 或 <code>onRestoreInstanceState()</code> 期间恢复 Activity 状态。</p>
<p>重启应用并恢复大量数据不仅成本高昂，而且用户体验并不好，所以可以选用以下方式进行配置变更：</p>
<ol>
<li><strong>在配置变更期间保留对象：</strong>允许 Activity 在配置变更时重启，但是要将有状态对象传递给 Activity 的新实例。</li>
<li><strong>自行处理配置变更：</strong>阻止系统在某些配置变更期间重启 Activity，但要在配置确实发生变化时接收回调，这样，就能够根据需要手动更新 Activity。</li>
</ol>
</blockquote>
<h2 id="在配置变更期保留对象"><a href="#在配置变更期保留对象" class="headerlink" title="在配置变更期保留对象"></a>在配置变更期保留对象</h2><blockquote>
<p>如果重启 Activity 需要恢复大量数据、重新建立网络连接或执行其他密集操作，那么因配置变更而引起的完全重启可能会给用户留下应用运行缓慢的体验。并且通过<code>onSaveInstanceState()</code> 回调为您保存的 <code>Bundle</code>，可能无法完全恢复 Activity 状态，因为它并非设计用于携带大型对象(例如位图等)，而且其中数据必须先序列化，在进行反序列化，这可能会消耗大量的内存使得配置变更时运行缓慢。 在这种情况下，如果 Activity 因配置变更而重启，则可通过保留 <code>Fragment</code> 来减轻重新初始化 Activity 的负担。此片段可能包含要保留的有状态对象的引用。</p>
</blockquote>
<ul>
<li><p>当 Android 系统因配置变更而关闭 Activity 时，不会销毁您已标记为要保留的 Activity 的片段。 可以将此类片段添加到 Activity 以保留有状态的对象。要在运行时配置变更期间将有状态的对象保留在片段中，请执行以下操作：</p>
<ol>
<li><p>扩展 <code>Fragment</code> 类并声明对有状态对象的引用。</p>
</li>
<li><p>在创建片段后调用 <code>setRetainInstance(boolean)</code>。</p>
</li>
<li><p>将片段添加到 Activity。</p>
</li>
<li><p>重启 Activity 后，使用 <code>FragmentManager</code> 检索片段。</p>
</li>
<li><p>代码示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class RetainedFragment extends Fragment &#123;</span><br><span class="line"></span><br><span class="line">    // data object we want to retain</span><br><span class="line">    private MyDataObject data;</span><br><span class="line"></span><br><span class="line">    // this method is only called once for this fragment</span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        // retain this fragment</span><br><span class="line">        setRetainInstance(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(MyDataObject data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyDataObject getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，使用 FragmentManager 将片段添加到 Activity。在运行时配置变更期间再次启动 Activity 时，可以获得片段中的数据对象。 例如，按如下方式定义 Activity：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class MyActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">    private RetainedFragment dataFragment;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.main);</span><br><span class="line"></span><br><span class="line">        // find the retained fragment on activity restarts</span><br><span class="line">        FragmentManager fm = getFragmentManager();</span><br><span class="line">        dataFragment = (DataFragment) fm.findFragmentByTag(“data”);</span><br><span class="line"></span><br><span class="line">        // create the fragment and data the first time</span><br><span class="line">        if (dataFragment == null) &#123;</span><br><span class="line">            // add the fragment</span><br><span class="line">            dataFragment = new DataFragment();</span><br><span class="line">            fm.beginTransaction().add(dataFragment, “data”).commit();</span><br><span class="line">            // load the data from the web</span><br><span class="line">            dataFragment.setData(loadMyData());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // the data is available in dataFragment.getData()</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// onCreate() 添加了一个片段或恢复了对它的引用。onCreate() 还将有状态的对象存储在片段实例内部。</span><br><span class="line">// onDestroy() 对所保留的片段实例内的有状态对象进行更新</span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        // store the data in the fragment</span><br><span class="line">        dataFragment.setData(collectMyLoadedData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>注意：**尽管您可以存储任何对象，但是切勿传递与 <code>Activity</code> 绑定的对象，例如，<code>Drawable</code>、<code>Adapter</code>、<code>View</code> 或其他任何与 <code>Context</code> 关联的对象。否则，它将泄漏原始 Activity 实例的所有视图和资源。 （泄漏资源意味着应用将继续持有这些资源，但是无法对其进行垃圾回收，因此可能会丢失大量内存。）</p>
</li>
</ol>
</li>
</ul>
<h2 id="自行变更配置"><a href="#自行变更配置" class="headerlink" title="自行变更配置"></a>自行变更配置</h2><ul>
<li>自行处理配置变更可能导致备用资源的使用更为困难，因为系统不会为您自动应用这些资源。 只能在必须避免 Activity 因配置变更而重启这一万般无奈的情况下，才考虑采用自行处理配置变更这种方法，而且对于大多数应用并不建议使用此方法。</li>
</ul>
</li>
</ul>
<ul>
<li><p>要声明由 Activity 处理配置变更，请在清单文件中编辑相应的<activity>元素，以包含 <a href="https://developer.android.google.cn/guide/topics/manifest/activity-element.html#config" target="_blank" rel="noopener"><code>android:configChanges</code></a> 属性以及代表要处理的配置的值。<a href="https://developer.android.google.cn/guide/topics/manifest/activity-element.html#config" target="_blank" rel="noopener"><code>android:configChanges</code></a> 属性的文档中列出了该属性的可能值（最常用的值包括 <code>&quot;orientation&quot;</code> 和 <code>&quot;keyboardHidden&quot;</code>，分别用于避免因屏幕方向和可用键盘改变而导致重启）。可以在该属性中声明多个配置值，方法是用管道 <code>|</code> 字符分隔这些配置值。例如：</activity></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=&quot;.MyActivity&quot;</span><br><span class="line">          android:configChanges=&quot;orientation|keyboardHidden&quot;</span><br><span class="line">          android:label=&quot;@string/app_name&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>当其中一个配置发生变化时，<code>MyActivity</code> 不会重启。相反，<code>MyActivity</code> 会收到对 <code>onConfigurationChanged()</code> 的调用。向此方法传递<code>Configuration</code> 对象指定新设备配置。可以通过读取 <code>Configuration</code> 中的字段，确定新配置，然后通过更新界面中使用的资源进行适当的更改。调用此方法时，Activity 的 <code>Resources</code> 对象会相应地进行更新，以根据新配置返回资源，就能够在系统不重启 Activity 的情况下轻松重置 UI 的元素。</p>
<blockquote>
<p><strong>注意：</strong>从 Android 3.2（API 级别 13）开始，当设备在纵向和横向之间切换时，<strong>“屏幕尺寸”也会发生变化</strong>。因此，在开发针对 API 级别 13 或更高版本（正如 <a href="https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element.html#min" target="_blank" rel="noopener"><code>minSdkVersion</code></a> 和 <a href="https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element.html#target" target="_blank" rel="noopener"><code>targetSdkVersion</code></a> 属性中所声明）的应用时，若要避免由于设备方向改变而导致运行时重启，则除了 <code>&quot;orientation&quot;</code> 值以外，还必须添加 <code>&quot;screenSize&quot;</code> 值。 即必须声明 <code>android:configChanges=&quot;orientation|screenSize&quot;</code>。</p>
</blockquote>
</li>
<li><p><code>Configuration</code> 对象代表所有当前配置，而不仅仅是已经变更的配置。不用关注配置具体发生了哪些变更，就可以轻松地重新分配所有资源，为正在处理的配置提供备用资源。 例如，由于 <code>Resources</code> 对象现已更新，因此您可以通过 <code>setImageResource()</code> 重置任何 <code>ImageView</code>，并且使用适合于新配置的资源。</p>
<blockquote>
<p><strong>注意：</strong>在声明由 Activity 处理配置变更时，应重置要为其提供备用资源的所有元素。 如果声明由 Activity 处理方向变更，而且有些图像应该在横向和纵向之间切换，则必须在 <code>onConfigurationChanged()</code> 期间将每个资源重新分配给每个元素。</p>
</blockquote>
</li>
</ul>
<p>#App Manifest File应用清单</p>
<blockquote>
<p>每个应用的根目录中都必须包含一个 <code>AndroidManifest.xml</code> 文件（且文件名精确无误）。 清单文件向 Android 系统提供应用的必要信息，系统必须具有这些信息方可运行应用的任何代码。</p>
<p>清单文件作用：</p>
<ul>
<li>为应用的 Java 软件包命名。软件包名称充当应用的唯一标识符。</li>
<li>描述应用的各个组件，包括构成应用的 Activity、服务、广播接收器和内容提供程序。它还为实现每个组件的类命名并发布其功能，例如它们可以处理的 <code>Intent</code> 消息。这些声明向 Android 系统告知有关组件以及可以启动这些组件的条件的信息。</li>
<li>确定托管应用组件的进程。</li>
<li>声明应用必须具备哪些权限才能访问 API 中受保护的部分并与其他应用交互。还声明其他应用与该应用组件交互所需具备的权限</li>
<li>列出 <code>Instrumentation</code> 类，这些类可在应用运行时提供分析和其他信息。这些声明只会在应用处于开发阶段时出现在清单中，在应用发布之前将移除。</li>
<li>声明应用所需的最低 Android API 级别</li>
<li>列出应用必须链接到的库</li>
</ul>
</blockquote>
<h2 id="清单文件结构"><a href="#清单文件结构" class="headerlink" title="清单文件结构"></a>清单文件结构</h2><ul>
<li><code>&lt;action&gt;</code></li>
<li><code>&lt;activity&gt;</code></li>
<li><code>&lt;activity-alias&gt;</code></li>
<li><code>&lt;application&gt;</code></li>
<li><code>&lt;category&gt;</code></li>
<li><code>&lt;data&gt;</code></li>
<li><code>&lt;grant-uri-permission&gt;</code></li>
<li><code>&lt;instrumentation&gt;</code></li>
<li><code>&lt;intent-filter&gt;</code></li>
<li><code>&lt;manifest&gt;</code></li>
<li><code>&lt;meta-data&gt;</code></li>
<li><code>&lt;permission&gt;</code></li>
<li><code>&lt;permission-group&gt;</code></li>
<li><code>&lt;permission-tree&gt;</code></li>
<li><code>&lt;provider&gt;</code></li>
<li><code>&lt;receiver&gt;</code></li>
<li><code>&lt;service&gt;</code></li>
<li><code>&lt;supports-screens&gt;</code></li>
<li><code>&lt;uses-configuration&gt;</code></li>
<li><code>&lt;uses-feature&gt;</code></li>
<li><code>&lt;uses-library&gt;</code></li>
<li><code>&lt;uses-permission&gt;</code></li>
<li><code>&lt;uses-sdk&gt;</code></li>
</ul>
<p>##文件约定</p>
<ul>
<li><p><strong>元素：</strong></p>
<ul>
<li>只有 <code>&lt;manifest&gt;</code> 和 <code>&lt;application&gt;</code> 元素是必需的，它们都必须存在并且只能出现一次。其他大部分元素可以出现多次或者根本不出现。但清单文件中必须至少存在其中某些元素才有用。</li>
<li>如果一个元素包含某些内容，也就包含其他元素。所有值均通过属性进行设置，而不是通过元素内的字符数据设置。</li>
<li>同一级别的元素通常不分先后顺序。例如，<code>&lt;activity&gt;</code>、<code>&lt;provider&gt;</code> 和 <code>&lt;service&gt;</code> 元素可以按任何顺序混合在一起。这条规则有两个主要例外：<ul>
<li><code>&lt;activity-alias&gt;</code> 元素必须跟在别名所指的 <code>&lt;activity&gt;</code> 之后。</li>
<li><code>&lt;application&gt;</code> 元素必须是 <code>&lt;manifest&gt;</code> 元素内最后一个元素。换言之，<code>&lt;/manifest&gt;</code> 结束标记必须紧接在 <code>&lt;/application&gt;</code> 结束标记后。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>属性：</strong></p>
<ul>
<li>从某种意义上说，所有属性都是可选的。但是，必须指定某些属性，元素才可实现其目的。请使用本文档作为参考。对于真正可选的属性，它将指定默认值或声明缺乏规范时将执行何种操作。</li>
<li>除了根 <code>&lt;manifest&gt;</code> 元素的一些属性外，所有属性名称均以 <code>android:</code> 前缀开头。例如，<code>android:alwaysRetainTaskState</code>。由于该前缀是通用的，因此在按名称引用属性时，本文档通常会将其忽略。</li>
</ul>
</li>
<li><p><strong>声明类名：</strong></p>
<ul>
<li><p>许多元素对应于 Java 对象，包括应用本身的元素（<code>&lt;application&gt;</code> 元素）及其主要组件：Activity (<code>&lt;activity&gt;</code>)、服务 (<code>&lt;service&gt;</code>)、广播接收器 (<code>&lt;receiver&gt;</code>) 以及内容提供程序 (<code>&lt;provider&gt;</code>)。</p>
</li>
<li><p>若针对组件类（<code>Activity</code>、<code>Service</code> 和 <code>BroadcastReceiver`</code>ContentProvider<code>）几乎一直采用的方式来定义子类，则该子类需通过</code>name<code>属性来声明。该名称必须包含完整的软件包名称。例如，</code>Service` 子类可能会声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest . . . &gt;</span><br><span class="line">    &lt;application . . . &gt;</span><br><span class="line">        &lt;service android:name=&quot;com.example.project.SecretService&quot; . . . &gt;</span><br><span class="line">            . . .</span><br><span class="line">        &lt;/service&gt;</span><br><span class="line">        . . .</span><br><span class="line">    &lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果字符串的第一个字符是句点，则应用的软件包名称（如 <code>&lt;manifest&gt;</code> 元素的 <code>package</code> 属性所指定）将附加到该字符串。以下赋值与上述方法相同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest package=&quot;com.example.project&quot; . . . &gt;</span><br><span class="line">    &lt;application . . . &gt;</span><br><span class="line">        &lt;service android:name=&quot;.SecretService&quot; . . . &gt;</span><br><span class="line">            . . .</span><br><span class="line">        &lt;/service&gt;</span><br><span class="line">        . . .</span><br><span class="line">    &lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当启动组件时，Android 系统会创建已命名子类的实例。如果未指定子类，则会创建基类的实例。</p>
</li>
</ul>
</li>
<li><p><strong>多个值：</strong>如果可以指定多个值，则几乎总是在重复此元素，而不是列出单个元素内的多个值。</p>
</li>
<li><p><strong>资源值：</strong>某些属性的值可以显示给用户，例如，Activity 的标签和图标。这些属性的值应该本地化，并通过资源或主题进行设置。资源值用以下格式表示：<code>@[&lt;i&gt;package&lt;/i&gt;:]&lt;i&gt;type&lt;/i&gt;/&lt;i&gt;name&lt;/i&gt;。</code>如果资源与应用在同一个软件包中，可以省略<em>软件包</em>名称。</p>
</li>
<li><p><strong>字符串值：</strong>如果属性值为字符串，则必须使用双反斜杠 (\) 转义字符，例如，使用 \n 表示换行符或使用 \uxxxx 表示 Unicode 字符。</p>
</li>
</ul>
<h2 id="文件功能"><a href="#文件功能" class="headerlink" title="文件功能"></a>文件功能</h2><ul>
<li><p><strong>Intent过滤器</strong></p>
<ul>
<li>应用核心组件（例如其 Activity、服务和广播接收器）由 <em>intent</em> 激活。Intent 是一系列用于描述所需操作的信息（<code>Intent</code> 对象），其中包括要执行操作的数据、应执行操作的组件类别以及其他相关说明。Android 系统会查找合适的组件来响应 intent，根据需要启动组件的新实例，并将其传递到 <code>Intent</code> 对象。</li>
<li>组件将通过 <em>intent 过滤器</em>公布它们可响应的 intent 类型。由于Android 系统在启动某组件之前必须了解该组件可以处理的 intent，因此 intent 过滤器在清单中被指定为 <code>&lt;intent-filter&gt;</code> 元素。一个组件可有任意数量的过滤器，其中每个过滤器描述一种不同的功能。</li>
<li>显式命名目标组件的 intent 将激活该组件，因此过滤器不起作用。不按名称指定目标的 intent 只有在能够通过组件的一个过滤器时才可激活该组件。</li>
</ul>
</li>
<li><p><strong>图标和标签</strong></p>
<ul>
<li>对于可以显示给用户的小图标和文本标签，大量元素具有 <code>icon</code> 和 <code>label</code> 属性。此外，对于同样可以显示在屏幕上的较长说明文本，某些元素还具有 <code>description</code> 属性。例如，<code>&lt;permission&gt;</code> 元素具有所有这三个属性。因此，当系统询问用户是否授权给请求获得权限的应用时，权限图标、权限名称以及所需信息的说明均会呈现给用户。</li>
<li>无论何种情况下，在包含元素中设置的图标和标签都将成为所有容器子元素的默认 <code>icon</code> 和 <code>label</code> 设置。因此，在 <code>&lt;application&gt;</code> 元素中设置的图标和标签是每个应用组件的默认图标和标签。同样，为组件（例如 <code>&lt;activity&gt;</code> 元素）设置的图标和标签是组件每个 <code>&lt;intent-filter&gt;</code> 元素的默认设置。如果 <code>&lt;application&gt;</code> 元素设置标签，但是 Activity 及其 intent 过滤器不执行此操作，则应用标签将被视为 Activity 和 intent 过滤器的标签。</li>
<li>在实现过滤器公布的功能时，只要向用户呈现组件，系统便会使用为 intent 过滤器设置的图标和标签表示该组件。例如，具有 <code>android.intent.action.MAIN</code> 和 <code>android.intent.category.LAUNCHER</code> 设置的过滤器将 Activity 公布为可启动应用的功能，即，公布为应显示在应用启动器中的功能。在过滤器中设置的图标和标签显示在启动器中。</li>
</ul>
</li>
<li><p><strong>权限</strong></p>
<ul>
<li><p>权限是一种限制，用于限制对部分代码或设备上数据的访问。施加限制是为了保护可能被误用以致破坏或损害用户体验的关键数据和代码。每种权限均由一个唯一的标签标识。标签通常指示受限制的操作。以下是 Android 定义的一些权限：</p>
<ul>
<li><code>android.permission.CALL_EMERGENCY_NUMBERS</code></li>
<li><code>android.permission.READ_OWNER_DATA</code></li>
<li><code>android.permission.SET_WALLPAPER</code></li>
<li><code>android.permission.DEVICE_POWER</code></li>
</ul>
</li>
<li><p>如果应用需要访问受权限保护的功能，则必须在清单中使用 <code>&lt;uses-permission&gt;</code> 元素声明应用需要该权限。将应用安装到设备上之后，安装程序会通过检查签署应用证书的颁发机构并（在某些情况下）询问用户，确定是否授予请求的权限。如果授予权限，则应用能够使用受保护的功能。否则，其访问这些功能的尝试将会失败，并且不会向用户发送任何通知。</p>
</li>
<li><p>应用也可以使用权限保护自己的组件。它可以采用由 Android 定义（如 <code>android.Manifest.permission</code> 中所列）或由其他应用声明的任何权限。它也可以定义自己的权限。</p>
<p>​</p>
</li>
</ul>
</li>
<li><p><strong>库</strong></p>
<ul>
<li>每个应用均链接到默认的 Android 库，该库中包括用于开发应用（以及通用类，如 Activity、服务、intent、视图、按钮、应用、ContentProvider）的基本软件包。</li>
<li>某些软件包驻留在自己的库中。如果应用使用来自其中任一软件包的代码，则必须明确要求其链接到这些软件包。清单必须包含单独的 <code>&lt;uses-library&gt;</code> 元素来命名其中每个库。库名称可在软件包的文档中找到。</li>
</ul>
</li>
</ul>
<h1 id="App-Permissions应用权限"><a href="#App-Permissions应用权限" class="headerlink" title="App Permissions应用权限"></a>App Permissions应用权限</h1><blockquote>
<p>为了维护系统和用户的安全，Android需要应用程序在使用特定系统数据和功能之前声明所需的权限。根据区域的敏感程度，系统可能会自动授予权限，或者可能会要求用户批准该请求。</p>
</blockquote>
<h2 id="权限概述"><a href="#权限概述" class="headerlink" title="权限概述"></a>权限概述</h2><blockquote>
<p>权限需要许可的目的是保护Android用户的隐私。 Android应用程序必须请求访问敏感用户数据（如联系人和短信）以及某些系统功能（如相机和互联网）的权限。根据功能的不同，系统可能会自动授予权限，或者可能会提示用户批准请求。这里介绍的内容包括：如何向用户显示权限，安装时间和运行时权限请求之间的区别，权限的执行方式以及权限和权限组的权限类型。</p>
</blockquote>
<h3 id="权限许可"><a href="#权限许可" class="headerlink" title="权限许可"></a>权限许可</h3><ul>
<li>应用必须在清单文件中使用<code>&lt;uses-prmission&gt;</code>标签声明所需要的权限，若应用在其清单中列出了正常权限（即，对用户的隐私或设备操作不构成风险的权限），系统会自动将这些权限授予给应用。但是若应用在其清单中列出了危险权限（即可能影响用户隐私或设备正常运行的权限），如SEND_SMS权限，则用户必须明确同意授予这些权限。</li>
<li>危险权限获取<ul>
<li>运行时请求授予危险权限（Android6.0及以上）：<ul>
<li>如果设备运行的是Android 6.0（API级别23）或更高版本，并且该应用的targetSdkVersion为23或更高，则安装时用户不会收到任何应用权限的通知。应用程序必须要求用户在运行时授予危险权限。当应用程序请求权限时，用户会看到一个系统对话框，告诉用户您的应用尝试访问哪个权限组。该对话框包含拒绝和允许按钮。</li>
<li>如果用户拒绝权限请求，则在应用下次请求权限时，该对话框将包含一个复选框，该复选框在选中后表示用户不会再次被要求提供权限。如果用户选中永不再问框并点击拒绝，如果稍后尝试请求相同的权限，则系统将不再提示用户。</li>
<li>即使用户向应用程序授予您所请求的权限，但是用户还可以选择在系统设置中逐个启用和禁用权限，因此还是应该始终在运行时检查并请求权限以防止运行时错误（SecurityException）。</li>
</ul>
</li>
<li>安装时获取权限（Android5.1.1及以下）<ul>
<li>如果设备运行Android 5.1.1（API级别22）或更低，或者应用程序的targetSdkVersion为22或更低，则系统会自动要求用户在安装时为应用授予所有危险权限。</li>
<li>在安装时用户如果拒绝授予这些危险权限那么将无法安装应用，如果应用程序更新包含对额外权限的需求，则会在更新应用程序之前提示用户接受这些新权限。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="硬件权限"><a href="#硬件权限" class="headerlink" title="硬件权限"></a>硬件权限</h3><ul>
<li><p>访问某些硬件功能（例如蓝牙或相机）需要应用程序许可。但并非所有的Android设备都具备这些硬件功能。因此，如果应用请求CAMERA权限，则还必须在清单中包含<uses-feature>标记以声明该功能是否实际需要。</uses-feature></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-feature android:name=&quot;android.hardware.camera&quot; android:required=&quot;false&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>如果您为该功能声明了android：required =“false”，则Google Play允许应用安装在没有此功能的设备上。然后，必须通过调用PackageManager.hasSystemFeature（）来检查当前设备是否在运行时具有该功能，并在不可用时正常禁用该功能。</p>
</li>
<li><p>如果您提供<uses-feature>标记，那么当Google Play发现应用请求相应的权限时，它会假定应用需要此功能。因此，它会在没有此功能的设备上过滤您的应用，就像您在<uses-feature>标记中声明了android：required =“true”一样。</uses-feature></uses-feature></p>
</li>
</ul>
<h3 id="声明权限"><a href="#声明权限" class="headerlink" title="声明权限"></a>声明权限</h3><blockquote>
<p>权限不仅用于请求系统功能。应用程序提供的服务可以执行自定义权限，以限定可使用它们的对象。</p>
</blockquote>
<ul>
<li><strong>Activity权限声明：</strong>在应用清单文件<activity>标签中使用android：permission权限属性，限定可以启动该Activity的Activity。在Context.startActivity()和Activity.startActivityForResult()中检查权限。如果调用者没有所需的权限，则会在调用时调抛出SecurityException；</activity></li>
<li><strong>Service权限声明：</strong>在应用清单文件<service>标签中使用android：permission权限属性，限定可以启动或绑定到关联的Service的对象。在Context.startService()，Context.stopService()和Context.bindService()中检查权限。如果调用者没有所需的权限，则会在调用时调抛出SecurityException；</service></li>
<li><strong>Braodcast权限声明：</strong><ul>
<li>在应用清单文件<receiver>标签中使用android：permission权限属性，限定可以将广播发送到关联的BroadcastReceiver的对象。在Context.sendBroadcast()返回后检查权限，因为系统试图将提交的广播传送给指定的接收者。因此，权限不足导致的调用失败不会导致异常并抛回给调用者。</receiver></li>
<li>以同样的方式，可以向Context.registerReceiver()提供权限，以限制向以代码注册的接收者进行广播的广播。换句话说，当调用Context.sendBroadcast（）可以使用权限来限制哪些广播接收器可以接收广播。在接收者和广播者都需要获得权限时，必须通过权限检查才能将意图传递到关联的目标。</li>
</ul>
</li>
<li><strong>Content Provider权限声明：</strong><ul>
<li>在应用清单文件<provider>标签中使用android：permission权限属性，限定可以访问ContentProvider中的数据的对象（内容提供者有一个重要的额外的安全机制也就是URI权限）。与其他组件不同，应用可以设置两个单独的权限属性：android:readPermission限制谁可以从提供者读取，而android: writePermission限制谁可以写入它。如果提供者受到读写权限的保护，只保留写权限并不意味着可以从提供者读取。</provider></li>
<li>当首次检索提供程序时（如果没有任何权限，会引发SecurityException）并在对提供程序执行时检查权限。使用ContentResolver.query()需要保持读取权限;使用ContentResolver.insert()，ContentResolver.update()，ContentResolver.delete()需要写入权限。在所有这些情况下，不保留所需的权限会导致SecurityException从。</li>
</ul>
</li>
<li><strong>URI权限 ：</strong><ul>
<li>目前权限机制并不能完全满足Content Provider的需求。内容提供者希望通过读写权限来保护自己，而客户端也需要将特定的URI传递给其他应用程序供他们操作。例如电子邮件程序中的附件，因为设计到敏感的用户数据，访问电子邮件受到权限保护。但是，如果将图像附件的URI提供给图像查看器，则该图像查看器不再具有打开附件的权限，因为它没有理由持有访问所有电子邮件的权限。</li>
<li>此问题的解决方案是每个URI权限：在启动活动或将结果返回给活动时，调用者可以设置Intent.FLAG_GRANT_READ_URI_PERMISSION和/或Intent.FLAG_GRANT_WRITE_URI_PERMISSION。这允许接收活动权限访问意图中的特定数据URI，而不管其是否具有访问与意图相对应的内容提供者中的数据的任何权限。</li>
<li>这种机制允许一种通用的能力风格模型，在这种模型中，用户交互（例如打开附件或从列表中选择联系人）驱动临时授予细化权限。这可能是将应用程序所需的权限仅限于与其行为直接相关的权限的关键工具。要构建使其他应用程序对您的应用程序负责的最安全的实现，应该以这种方式使用细化的权限，并使用android:grantUriPermissions属性或<grant-uri-permissions>标签声明您的应用程序的支持。</grant-uri-permissions></li>
</ul>
</li>
<li><strong>其他权限声明：</strong><ul>
<li>任何调用服务时都可以强制任意细化权限。这是通过Context.checkCallingPermission()方法完成的。使用所需的权限字符串进行调用，并返回一个整数，指示该权限是否已授予当前经常调用。请注意，只有当您执行从另一个进程调用的调用时（通常是通过从服务发布的IDL接口或以其他方式向另一个进程发送的调用），才可以使用它。</li>
<li>还有许多其他有用的方法来检查权限。如果应用拥有另一个进程的进程ID（PID），则可以使用Context.checkPermission()方法检查针对该PID的权限。如果拥有其他应用的软件包名称，则可以使用PackageManager.checkPermission()方法来确定该特定软件包是否已被授予特定权限。</li>
</ul>
</li>
</ul>
<h3 id="权限自动调整"><a href="#权限自动调整" class="headerlink" title="权限自动调整"></a>权限自动调整</h3><ul>
<li>随着Android的更新，系统可能会某些API增加的限制，因此应用可能需要获取之前不需要的权限。由于应用之前对这些API的访问是不需要相应权限直接访问的，因此Android会将新的权限直接添加到清单文件，以避免在新版本的Android系统中应用的崩溃。Android会根据targetSdkVersion属性的值来确定应用是否需要添加权限。</li>
<li>如果应用自动添加了权限，那么即使您的应用实际上不需要它们，Google Play上的应用列表也会列出这些附加权限。为了避免这种情况并移除不需要的权限，请始终将targetSdkVersion更新为尽可能高。可在Build.VERSION_CODES文档中看到每个版本添加了哪些权限。</li>
</ul>
<h3 id="权限保护级别"><a href="#权限保护级别" class="headerlink" title="权限保护级别"></a>权限保护级别</h3><blockquote>
<p>权限分为几个保护级别。保护级别影响是否需要运行时权限请求。有三个保护级别会影响第三方应用程序：正常，签名和危险权限。</p>
</blockquote>
<ul>
<li><strong>普通权限</strong><ul>
<li>普通权限包括应用程序需要访问应用程序沙箱外的数据或资源，该访问操作对用户的隐私或其他应用程序的风险很小。例如，设置时区的权限是普通权限。</li>
<li>如果应用程序在其清单中声明它需要正常许可，系统会在安装时自动授予应用程序该许可权。系统不会提示用户授予正常权限，并且用户无法撤消这些权限。</li>
<li>从Android8.1开始一下权限为普通权限：<ul>
<li><code>ACCESS_LOCATION_EXTRA_COMMANDS</code></li>
<li><code>ACCESS_NETWORK_STATE</code></li>
<li><code>ACCESS_NOTIFICATION_POLICY</code></li>
<li><code>ACCESS_WIFI_STATE</code></li>
<li><code>BLUETOOTH</code></li>
<li><code>BLUETOOTH_ADMIN</code></li>
<li><code>BROADCAST_STICKY</code></li>
<li><code>CHANGE_NETWORK_STATE</code></li>
<li><code>CHANGE_WIFI_MULTICAST_STATE</code></li>
<li><code>CHANGE_WIFI_STATE</code></li>
<li><code>DISABLE_KEYGUARD</code></li>
<li><code>EXPAND_STATUS_BAR</code></li>
<li><code>GET_PACKAGE_SIZE</code></li>
<li><code>INSTALL_SHORTCUT</code></li>
<li><code>INTERNET</code></li>
<li><code>KILL_BACKGROUND_PROCESSES</code></li>
<li><code>MANAGE_OWN_CALLS</code></li>
<li><code>MODIFY_AUDIO_SETTINGS</code></li>
<li><code>NFC</code></li>
<li><code>READ_SYNC_SETTINGS</code></li>
<li><code>READ_SYNC_STATS</code></li>
<li><code>RECEIVE_BOOT_COMPLETED</code></li>
<li><code>REORDER_TASKS</code></li>
<li><code>REQUEST_COMPANION_RUN_IN_BACKGROUND</code></li>
<li><code>REQUEST_COMPANION_USE_DATA_IN_BACKGROUND</code></li>
<li><code>REQUEST_DELETE_PACKAGES</code></li>
<li><code>REQUEST_IGNORE_BATTERY_OPTIMIZATIONS</code></li>
<li><code>REQUEST_INSTALL_PACKAGES</code></li>
<li><code>SET_ALARM</code></li>
<li><code>SET_WALLPAPER</code></li>
<li><code>SET_WALLPAPER_HINTS</code></li>
<li><code>TRANSMIT_IR</code></li>
<li><code>USE_FINGERPRINT</code></li>
<li><code>VIBRATE</code></li>
<li><code>WAKE_LOCK</code></li>
<li><code>WRITE_SYNC_SETTINGS</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>签名权限</strong><ul>
<li>系统在安装时授予这些应用的权限，但仅当试图使用权限的应用程序由与定义权限的应用程序相同的证书签名时。</li>
<li>从Android 8.1（API级别27）开始，第三方应用程序可以使用的以下权限分类为PROTECTION_SIGNATURE：<ul>
<li><code>BIND_ACCESSIBILITY_SERVICE</code></li>
<li><code>BIND_AUTOFILL_SERVICE</code></li>
<li><code>BIND_CARRIER_SERVICES</code></li>
<li><code>BIND_CHOOSER_TARGET_SERVICE</code></li>
<li><code>BIND_CONDITION_PROVIDER_SERVICE</code></li>
<li><code>BIND_DEVICE_ADMIN</code></li>
<li><code>BIND_DREAM_SERVICE</code></li>
<li><code>BIND_INCALL_SERVICE</code></li>
<li><code>BIND_INPUT_METHOD</code></li>
<li><code>BIND_MIDI_DEVICE_SERVICE</code></li>
<li><code>BIND_NFC_SERVICE</code></li>
<li><code>BIND_NOTIFICATION_LISTENER_SERVICE</code></li>
<li><code>BIND_PRINT_SERVICE</code></li>
<li><code>BIND_SCREENING_SERVICE</code></li>
<li><code>BIND_TELECOM_CONNECTION_SERVICE</code></li>
<li><code>BIND_TEXT_SERVICE</code></li>
<li><code>BIND_TV_INPUT</code></li>
<li><code>BIND_VISUAL_VOICEMAIL_SERVICE</code></li>
<li><code>BIND_VOICE_INTERACTION</code></li>
<li><code>BIND_VPN_SERVICE</code></li>
<li><code>BIND_VR_LISTENER_SERVICE</code></li>
<li><code>BIND_WALLPAPER</code></li>
<li><code>CLEAR_APP_CACHE</code></li>
<li><code>MANAGE_DOCUMENTS</code></li>
<li><code>READ_VOICEMAIL</code></li>
<li><code>REQUEST_INSTALL_PACKAGES</code></li>
<li><code>SYSTEM_ALERT_WINDOW</code></li>
<li><code>WRITE_SETTINGS</code></li>
<li><code>WRITE_VOICEMAIL</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>危险权限</strong><ul>
<li>危险权限涵盖应用程序需要涉及用户私人信息的数据或资源的区域，或者可能会影响用户的存储数据或其他应用程序的操作。例如，阅读用户联系人的权限是危险的权限。如果一个应用程序声明它需要一个危险的权限，用户必须明确授予该应用程序的权限。在用户批准权限之前，应用无法提供取决于该权限的功能。要使用危险权限，应用必须提示用户在运行时授予权限。</li>
</ul>
</li>
<li><strong>特殊权限</strong><ul>
<li>有几个权限不具有正常和危险的权限。 SYSTEM_ALERT_WINDOW和WRITE_SETTINGS特别敏感，所以大多数应用程序不应该使用它们。如果应用程序需要这些权限之一，则必须在清单中声明权限，并发送请求用户授权的意图。系统通过向用户显示详细的管理屏幕来响应意图。</li>
</ul>
</li>
</ul>
<h3 id="权限组"><a href="#权限组" class="headerlink" title="权限组"></a>权限组</h3><blockquote>
<p>根据权限与之相关的功能权限被组织到权限组中。在此系统下，权限请求在组级别处理，并且单个权限组对应于应用清单中的多个权限声明。例如，SMS组包含READ_SMS和RECEIVE_SMS声明。以这种方式分组权限使用户能够做出更有意义和更明智的选择。</p>
</blockquote>
<ul>
<li><p>所有危险的Android权限都属于权限组。不管保护级别如何，任何权限都可以属于权限组。但是，如果权限是危险的，权限组只会影响用户体验。</p>
</li>
<li><p>如果设备运行的是Android 6.0（API级别23），并且该应用的targetSdkVersion为23或更高，则当您的应用请求危险权限时，以下系统行为适用：</p>
<ul>
<li>如果应用程序当前没有权限组的权限，系统会向描述该应用程序想要访问的权限组的用户显示权限请求对话框。该对话框没有描述该组内的特定权限。例如，如果某个应用程序请求READ_CONTACTS权限，则系统对话框只是表示应用程序需要访问该设备的联系人。如果用户同意，系统只给予应用程序许可。</li>
<li>如果应用程序已被授予同一权限组中的另一个危险权限，系统会立即授予权限，而不会与用户进行任何交互。例如，如果一个应用程序先前已经请求并被授予了READ_CONTACTS权限，并且它然后请求了WRITE_CONTACTS，则系统立即授予该权限而不向用户显示权限对话框。</li>
<li><strong>警告：</strong>未来版本的Android SDK可能会将特定权限从一个组移到另一个组。因此，不要将您的应用的逻辑基于这些权限组的结构。例如，从Android 8.1（API级别27）开始，READ_CONTACTS与WRITE_CONTACTS处于相同的权限组。如果应用程序请求READ_CONTACTS权限，然后请求WRITE_CONTACTS权限，请不要假定系统可以自动授予WRITE_CONTACTS权限。</li>
</ul>
</li>
<li><p>如果设备运行Android 5.1（API级别22）或更低，或者应用程序的targetSdkVersion为22或更低，则系统会要求用户在安装时授予权限。系统再一次告诉用户应用程序需要什么权限组，而不是个人权限。例如，当应用程序请求READ_CONTACTS时，安装对话框会列出联系人组。当用户接受时，只有READ_CONTACTS权限被授予应用程序。</p>
</li>
<li><p>危险的权限和权限组</p>
<p>| Permission Group | Permissions                                                  |<br>| —————- | :———————————————————– |<br>| <code>CALENDAR</code>       | <code>READ_CALENDAR</code>                                                                                                                                      <code>WRITE_CALENDAR</code> |<br>| <code>CAMERA</code>         | <code>CAMERA</code>                                                     |<br>| <code>CONTACTS</code>       | <code>READ_CONTACTS</code>                                                                                                                                       <code>WRITE_CONTACTS</code>                                                                                                                                             <code>GET_ACCOUNTS</code> |<br>| <code>LOCATION</code>       | <code>ACCESS_FINE_LOCATION</code>                                                                                                                      <code>ACCESS_COARSE_LOCATION</code> |<br>| <code>MICROPHONE</code>     | <code>RECORD_AUDIO</code>                                               |<br>| <code>PHONE</code>          | <code>READ_PHONE_STATE</code>                                                                                                                <code>READ_PHONE_NUMBERS</code>                                                                                                                 <code>CALL_PHONE</code>                                                                                                                     <code>ANSWER_PHONE_CALLS</code> (<em>must request at  runtime</em>)                                                                   <code>READ_CALL_LOG</code>                                                                                                                                                            <code>WRITE_CALL_LOG</code>                                                                                                                                                      <code>ADD_VOICEMAIL</code>                                                                                                                                <code>USE_SIP</code>                                                                                                                        <code>PROCESS_OUTGOING_CALLS</code>                                                                                                   <code>ANSWER_PHONE_CALLS</code> |<br>| <code>SENSORS</code>        | <code>BODY_SENSORS</code>                                               |<br>| <code>SMS</code>            | <code>SEND_SMS</code>                                                                                                                                 <code>RECEIVE_SMS</code>                                                                                                                                <code>READ_SMS</code>                                                                                                                                                    <code>RECEIVE_WAP_PUSH</code>                                                                                                                   <code>RECEIVE_MMS</code> |<br>| <code>STORAGE</code>        | <code>READ_EXTERNAL_STORAGE`</code>WRITE_EXTERNAL_STORAGE`              |</p>
</li>
</ul>
<h3 id="查看应用程序的权限"><a href="#查看应用程序的权限" class="headerlink" title="查看应用程序的权限"></a>查看应用程序的权限</h3><ul>
<li><p>可以使用Settings应用程序和shell命令adb shell pm列表权限查看系统中当前定义的所有权限。要使用设置应用，请转到设置&gt;应用。选择一个应用并向下滚动以查看该应用使用的权限。对于开发人员，adb’-s’选项以类似于用户看到它们的方式显示权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell pm list permissions -s</span><br><span class="line">All Permissions:</span><br><span class="line"></span><br><span class="line">Network communication: view Wi-Fi state, create Bluetooth connections, full</span><br><span class="line">internet access, view network state</span><br><span class="line"></span><br><span class="line">Your location: access extra location provider commands, fine (GPS) location,</span><br><span class="line">mock location sources for testing, coarse (network-based) location</span><br><span class="line"></span><br><span class="line">Services that cost you money: send SMS messages, directly call phone numbers</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以使用adb -g选项在模拟器或测试设备上安装应用程序时自动授予所有权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell install -g MyApp.apk</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="在运行时请求权限"><a href="#在运行时请求权限" class="headerlink" title="在运行时请求权限"></a>在运行时请求权限</h2><blockquote>
<p>从 Android 6.0（API 级别 23）开始，用户开始在应用运行时向其授予权限，而不是在应用安装时授予。此方法可以简化应用安装过程，因为用户在安装或更新应用时不需要授予权限。它还让用户可以对应用的功能进行更多控制；例如，用户可以选择为相机应用提供相机访问权限，而不提供设备位置的访问权限。用户可以随时进入应用的“Settings”屏幕调用权限。</p>
</blockquote>
<ul>
<li>系统权限分为两类：正常权限和危险权限<ul>
<li>正常权限不会直接给用户隐私权带来风险。如果应用在其清单中列出了正常权限，系统将自动授予该权限。</li>
<li>危险权限会授予应用访问用户机密数据的权限。如果列出了危险权限，则用户必须明确批准您的应用使用这些权限。</li>
</ul>
</li>
<li>在所有版本的 Android 中，您应用都需要在其应用清单中同时声明它需要的正常权限和危险权限，如声明权限中所述。不过，该声明的影响因系统版本和应用的目标 SDK 级别的不同而有所差异：<ul>
<li>如果设备运行的是 Android 5.1 或更低版本，或者应用的目标 SDK 为 22 或更低：如果您在清单中列出了危险权限，则用户必须在安装应用时授予此权限；如果他们不授予此权限，系统根本不会安装应用。</li>
<li>如果设备运行的是 Android 6.0 或更高版本，或者应用的目标 SDK 为 23 或更高：应用必须在清单中列出权限，并且它必须在运行时请求其需要的每项危险权限。用户可以授予或拒绝每项权限，且即使用户拒绝权限请求，应用仍可以继续运行有限的功能。</li>
<li>如果设备运行的是 Android 5.1 或更低版本，或者应用的目标 SDK 为 22 或更低：如果您清单中列出了危险权限，则用户必须在安装应用时授予此权限；如果他们不授予此权限，系统根本不会安装应用。</li>
<li>如果设备运行的是 Android 6.0 或更高版本，或者应用的目标 SDK 为 23 或更高：应用必须在清单中列出权限，<em>并且</em>它必须在运行时请求其需要的每项危险权限。用户可以授予或拒绝每项权限，且即使用户拒绝权限请求，应用仍可以继续运行有限的功能。</li>
</ul>
</li>
</ul>
<h3 id="检查权限"><a href="#检查权限" class="headerlink" title="检查权限"></a>检查权限</h3><ul>
<li><p>如果应用需要危险权限，则每次执行需要这一权限的操作时您都必须检查自己是否具有该权限。用户始终可以自由调用此权限。</p>
</li>
<li><p>要检查您是否具有某项权限，请调用 <code>ContextCompat.checkSelfPermission()</code> 方法。例如，以下代码段显示了如何检查 Activity 是否具有在日历中进行写入的权限：</p>
<p><code>int permissionCheck =ContextCompat.checkSelfPermission(thisActivity,Manifest.permission.WRITE_CALENDAR);</code></p>
<p>如果应用具有此权限，方法将返回 <code>PackageManager.PERMISSION_GRANTED</code>，并且应用可以继续操作。如果应用不具有此权限，方法将返回 <code>PERMISSION_DENIED</code>，且应用必须明确向用户要求权限</p>
</li>
</ul>
<h3 id="请求权限"><a href="#请求权限" class="headerlink" title="请求权限"></a>请求权限</h3><blockquote>
<p>如果应用需要应用清单中列出的危险权限，那么，它必须要求用户授予该权限。Android 为您提供了多种权限请求方式。调用这些方法将显示一个标准的 Android 对话框，不过，能对它们进行自定义。</p>
</blockquote>
<ul>
<li><p><strong>向用户解释需要权限的原因</strong></p>
<ul>
<li>在某些情况下，可能需要让用户了解您的应用为什么需要某项权限。例如，如果用户启动一个摄影应用，用户对应用要求使用相机的权限可能不会感到吃惊，但用户可能无法理解为什么此应用想要访问用户的位置或联系人。在请求权限之前，不妨为用户提供一个解释。请记住，不需要通过解释来说服用户；如果提供太多解释，用户可能发现应用令人失望并将其移除。</li>
<li>可以采用的一个方法是仅在用户已拒绝某项权限请求时提供解释。如果用户继续尝试使用需要某项权限的功能，但继续拒绝权限请求，则可能表明用户不理解应用为什么需要此权限才能提供相关功能。对于这种情况，比较好的做法是显示解释。</li>
<li>为了帮助查找用户可能需要解释的情形，Android 提供了一个实用程序方法，即 <code>shouldShowRequestPermissionRationale()</code>。如果应用之前请求过此权限但用户拒绝了请求，此方法将返回 <code>true</code>。如果用户在过去拒绝了权限请求，并在权限请求系统对话框中选择了 <strong>Don’t ask again</strong> 选项，此方法将返回 <code>false</code>。如果设备规范禁止应用具有该权限，此方法也会返回 <code>false</code>。</li>
</ul>
</li>
<li><p><strong>请求需要的权限</strong></p>
<ul>
<li><p>如果应用尚无所需的权限，则应用必须调用一个 <code>requestPermissions()</code> 方法，以请求权限。应用将传递其所需的权限，以及指定用于识别此权限请求的整型请求代码。此方法异步运行：它会立即返回，并且在用户响应对话框之后，系统会使用结果调用应用的回调方法，将应用传递的相同请求代码传递到 <code>requestPermissions()</code>。</p>
</li>
<li><p>例如，以下代码可以检查应用是否具备读取用户联系人的权限，并根据需要请求该权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Here, thisActivity is the current activity</span><br><span class="line">if (ContextCompat.checkSelfPermission(thisActivity,</span><br><span class="line">                Manifest.permission.READ_CONTACTS)</span><br><span class="line">        != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line"></span><br><span class="line">    // Should we show an explanation?</span><br><span class="line">    if (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity,</span><br><span class="line">            Manifest.permission.READ_CONTACTS)) &#123;</span><br><span class="line"></span><br><span class="line">        // Show an expanation to the user *asynchronously* -- don&apos;t block</span><br><span class="line">        // this thread waiting for the user&apos;s response! After the user</span><br><span class="line">        // sees the explanation, try again to request the permission.</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        // No explanation needed, we can request the permission.</span><br><span class="line"></span><br><span class="line">        ActivityCompat.requestPermissions(thisActivity,</span><br><span class="line">                new String[]&#123;Manifest.permission.READ_CONTACTS&#125;,</span><br><span class="line">                MY_PERMISSIONS_REQUEST_READ_CONTACTS);</span><br><span class="line"></span><br><span class="line">        // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an</span><br><span class="line">        // app-defined int constant. The callback method gets the</span><br><span class="line">        // result of the request.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注</strong>：当您的应用调用 <code>requestPermissions()</code> 时，系统将向用户显示一个标准对话框。应用无法配置或更改此对话框。如果需要为用户提供任何信息或解释，您应在调用 <code>requestPermissions()</code> 之前进行，如解释应用为什么需要权限中所述。</p>
</li>
</ul>
</li>
<li><p><strong>处理权限请求响应</strong></p>
<ul>
<li><p>当应用请求权限时，系统将向用户显示一个对话框。当用户响应时，系统将调用应用的 <code>onRequestPermissionsResult()</code> 方法，向其传递用户响应。应用必须重写改方法，以了解是否已获得相应权限。回调会将您传递的相同请求代码传递给 <code>requestPermissions()</code>。例如，如果应用请求 <code>READ_CONTACTS</code> 访问权限，则它可能采用以下回调方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onRequestPermissionsResult(int requestCode,</span><br><span class="line">        String permissions[], int[] grantResults) &#123;</span><br><span class="line">    switch (requestCode) &#123;</span><br><span class="line">        case MY_PERMISSIONS_REQUEST_READ_CONTACTS: &#123;</span><br><span class="line">            // If request is cancelled, the result arrays are empty.</span><br><span class="line">            if (grantResults.length &gt; 0</span><br><span class="line">                &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line"></span><br><span class="line">                // permission was granted, yay! Do the</span><br><span class="line">                // contacts-related task you need to do.</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                // permission denied, boo! Disable the</span><br><span class="line">                // functionality that depends on this permission.</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // other &apos;case&apos; lines to check for other</span><br><span class="line">        // permissions this app might request</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>系统显示的对话框说明了您的应用需要访问的权限组；它不会列出具体权限。例如，如果请求 <code>READ_CONTACTS</code> 权限，系统对话框只显示应用需要访问设备的联系人。用户只需要为每个权限组授予一次权限。如果应用请求该组中的任何其他权限（已在您的应用清单中列出），系统将自动授予应用这些权限。当请求此权限时，系统会调用 <code>onRequestPermissionsResult()</code> 回调方法，并传递 <code>PERMISSION_GRANTED</code>，如果用户已通过系统对话框明确同意您的权限请求，系统将采用相同方式操作。</p>
</li>
<li><p><strong>注</strong>：应用仍需要明确请求其需要的每项权限，即使用户已向应用授予该权限组中的其他权限。此外，权限分组在将来的 Android 版本中可能会发生变化。您的代码不应依赖特定权限属于或不属于相同组这种假设。</p>
<p>例如，假设应用清单中列出了 <code>READ_CONTACTS</code> 和 <code>WRITE_CONTACTS</code>。如果请求 <code>READ_CONTACTS</code> 且用户授予了此权限，那么，当请求 <code>WRITE_CONTACTS</code> 时，系统将立即授予您该权限，不会与用户交互。如果用户拒绝了某项权限请求，应用应采取适当的操作。例如，应用可能显示一个对话框，解释它为什么无法执行用户已经请求但需要该权限的操作。当系统要求用户授予权限时，用户可以选择指示系统不再要求提供该权限。这种情况下，无论应用在什么时候使用 <code>requestPermissions()</code> 再次要求该权限，系统都会立即拒绝此请求。系统会调用<code>onRequestPermissionsResult()</code> 回调方法，并传递 <code>PERMISSION_DENIED</code>，如果用户再次明确拒绝了应用的请求，系统将采用相同方式操作。这意味着当您调用 <code>requestPermissions()</code> 时，应用不能假设已经发生与用户的任何直接交互。</p>
</li>
</ul>
</li>
</ul>
<h2 id="权限请求示例"><a href="#权限请求示例" class="headerlink" title="权限请求示例"></a>权限请求示例</h2><blockquote>
<p>权限请求保护设备中可用的敏感信息，并且只能在访问信息对于您的应用的运行是必需的时才使用。权限请求示例提供了有关如何在不需要访问此类信息的情况下实现相同（或更好）功能的提示;</p>
</blockquote>
<h3 id="使用Android权限的原则"><a href="#使用Android权限的原则" class="headerlink" title="使用Android权限的原则"></a>使用Android权限的原则</h3><ol>
<li><strong>只使用应用程序工作所需的权限：</strong>因为可能有另一种方法可以满足您的需求（系统意图，标识符，电话背景），而无需依赖敏感信息。</li>
<li><strong>注意jar包所需要的权限：</strong>当你使用一个库时，应该清楚它所需要的权限以及权限的用途然后获取它所需要的权限。</li>
<li><strong>权限透明原则：</strong>进行权限请求时，应当告知用户获取权限的原因。使此信息与权限请求一起提供，包括安装，运行时或更新权限对话。</li>
<li><strong>确保系统访问清晰：</strong>当访问敏感功能（例如相机或麦克风）时，应在收集数据时提供连续请求以便清楚地向用户显示。</li>
</ol>
<h3 id="Android6-0的权限变更"><a href="#Android6-0的权限变更" class="headerlink" title="Android6.0的权限变更"></a>Android6.0的权限变更</h3><blockquote>
<p>Android 6.0 引入了一个新的权限策略，它允许应用程序在运行时向用户请求权限，而不是在安装之前。当应用程序实际需要受服务保护的服务或数据时，应用程序支持使用新的策略进行权限请求。虽然这不会（必然）改变整体应用程序行为，但它确实会引起敏感用户数据处理方式相关的一些更改。</p>
</blockquote>
<ul>
<li><strong>权限请求增加提示</strong>：在运行时，会在应用程序对话框中提示用户所使用的功能会涵盖那些权限以及权限组组。用户对请求权限的对话框中的提示很敏感，更重要的是，如果要求的权限与应用的目的不匹配，应该向用户提供详细的解释，说明为什么要求获取该权限;只要有可能，应该在请求时提供请求的解释，并在用户拒绝请求时在后续对话框中提供解释。</li>
<li><strong>授予权限的灵活性更大</strong>：用户可以在请求和设置时拒绝权限的授权，但当用户的操作或使用的功能因此而中断时。应用可以监控有多少用户拒绝权限，以便在重构时避免使用该权限，或者对为什么应用需要获得改权限才能正常工作提供更好的解释。还应该确保应用处理在用户拒绝权限请求或关闭设置中的权限时创建的异常。</li>
<li><strong>增加了操作负担</strong>：要求用户单独授予权限的访问权限，而不是一组权限。这对于最小化请求的权限数量非常重要，因为它增加了用户授予权限的操作负担，并增加了至少拒绝一个请求的可能性。</li>
</ul>
<h3 id="避免请求不必要的权限"><a href="#避免请求不必要的权限" class="headerlink" title="避免请求不必要的权限"></a>避免请求不必要的权限</h3><blockquote>
<p>每当您要求获得权限时，都会强制用户做出决定。应用应该尽量减少请求获取权限。如果用户运行的是Android 6.0（API级别23）或更高版本，则每次用户尝试一些需要权限的程序功能时，应用程序都必须使用权限请求中断用户的工作。如果用户正在运行早期版本的Android，则用户必须在安装应用程序时授予每个应用程序的权限;如果列表太长或看起来不合适，用户可能决定根本不安装您的应用程序。出于这些原因，应该尽量减少应用程序需要的权限数量。</p>
</blockquote>
<ul>
<li><strong>优先使用Intent</strong><ul>
<li>在很多情况下，应用可以选择两种方式执行任务。应用程序可以获取权限自己执行任务，也可以使用意图让另一个应用程序执行任务，这样就不必获取权限。<ul>
<li>例如，假设应用需要能够使用设备相机拍照。应用可以请求CAMERA权限，该权限允许应用直接访问摄像头。然后，应用将使用相机API来控制相机并拍摄照片。这种方法中应用完全控制摄影过程，并让摄像头UI整合到应用中。</li>
<li>但是，如果应用对访问用户数据的需求不频繁 ， 换句话说，每次需要访问数据时，用户都都会看到一个请求权限的对话框，这会严重影响用户的体验。应用可以使用基于意图的请求。 Android提供了一些应用程序可以在不需要权限的情况下使用的系统意图，因为用户选择在发出基于意图的请求时与应用程序共享什么（如果有的话）。例如，MediaStore.ACTION_IMAGE_CAPTURE或MediaStore.ACTION_VIDEO_CAPTURE的intent操作类型可用于获取图像或视频，而无需直接使用Camera对象（需要权限）。在这种情况下，每次捕获图像时，系统意图都会代表应用请求用户的许可。</li>
</ul>
</li>
<li>直接使用权限和使用Intent的优缺点：<ul>
<li><strong>使用权限：</strong><ul>
<li>执行操作时，应用可全面控制用户体验。但是，如此广泛的控制会增加代码的复杂性，因为需要设计合适的UI。</li>
<li>系统会在运行时或安装时提示用户授予一次权限（具体取决于用户的Android版本）。之后，应用可以执行操作，而无需用户进行额外的交互。但是，如果用户未授予权限（或稍后撤销权限），则应用程序将失去执行操作的能力。</li>
</ul>
</li>
<li><strong>使用Intent：</strong><ul>
<li>应用不必为操作设计UI。处理意图的应用程序提供UI。</li>
<li>用户可以使用他们的首选应用程序来完成任务。例如，用户可以选择最喜欢的照片应用拍照。</li>
<li>如果用户没有该操作的默认应用程序，系统会提示用户选择一个应用程序。如果用户没有指定默认处理程序，则每次执行操作时可能需要经过额外的对话框。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>不要让用户陷于频繁的请求处理</strong><ul>
<li>如果用户运行Android 6.0（API级别23）或更高版本，则用户必须在运行应用程序时授予您的应用程序权限。如果您一次性向用户提出大量权限请求，您可能会压倒用户并导致他们退出应用。</li>
<li>开发者应该根据需求去请求权限。在某些情况下，一个或多个权限可能对应用程序绝对是必不可少的。应用程序启动后立即要求提供所有这些权限可能很有意义。例如，如果制作摄影应用程序，该应用程序需要访问设备摄像头。当用户第一次启动应用程序时，用户会被要求获得使用相机的权限并不感到惊讶。但是，如果同一个应用程序还具有与用户的联系人共享照片的功能，那么在首次启动时，可能不应要求提供READ_CONTACTS权限。相反，请等到用户尝试使用“共享”功能并要求获得许可。</li>
<li>如果应用程序提供了教程，那么在教程序列结尾处请求应用程序的基本权限也是很容易让用户接受的。</li>
</ul>
</li>
<li><strong>多媒体应用失去焦点进入后台是暂停播放</strong><ul>
<li>应用程序在用户接到电话时进入后台并且失去焦点，并且只有在呼叫停止后才能重新调整焦点。在这些情况下的常见方法（例如媒体播放器在通话期间静音或暂停）是使用PhoneStateListener监听呼叫状态的更改或监听android.intent.action.PHONE_STATE的广播。该解决方案的问题在于它需要READ_PHONE_STATE权限，这会强制用户授予对各种敏感数据的访问权限，例如设备和SIM硬件ID以及来电的电话号码。</li>
<li>应用可以通过请求AudioFocus来避免此问题，因为它不需要明确权限（因为它不访问敏感信息）。只需将代码置于onAudioFocusChange()事件处理程序中所需的代码，并在操作系统移动其音频焦点时自动运行。</li>
</ul>
</li>
<li><strong>确定应用运行的设备标识</strong><ul>
<li>应用程序可能具有对特定设备的偏好或消息传递（例如，在服务器为用户保存设备特定的播放列表，以便用户可以为他们的汽车和家中有不同的播放列表）。一种常见的解决方案是利用设备标识符，例如设备IMEI，但这需要设备ID和呼叫信息权限组（M +中的PHONE）。它还使用无法重置并在所有应用程序之间共享的标识符。</li>
<li>使用这些类型的标识符有两种选择：<ul>
<li>使用com.google.android.gms.iid InstanceID API。 getInstance（上下文上下文）.getID()将为应用程序实例返回唯一的设备标识符。结果是一个应用程序实例作用域标识符，可以在存储有关应用程序的信息时用作键，并在用户重新安装应用程序时重置。</li>
<li>使用基本系统函数（如randomUUID()）创建属于应用程序存储空间的自己的标识符。</li>
</ul>
</li>
</ul>
</li>
<li><strong>为广告和用户分析功能创建唯一标识符</strong><ul>
<li>对于广告和用户分析功能，需要一个唯一标识符来为未登录应用的用户构建配置文件（例如，针对广告的用户定位定位或计算广告转化率）。</li>
<li>为广告和用户分析构建配置文件有时需要和其他应用程序共享的标识符。常见的解决方案涉及利用设备标识符，如设备IMEI，它需要设备ID和呼叫信息权限组（API级别23+中的PHONE），并且不能由用户重置。在任何这些情况下，除了使用不可重置的标识符并要求用户特殊的权限外，还将违反Play开发者计划政策。不幸的是，在这些情况下，使用com.google.android.gms.iid InstanceID API或系统函数来创建应用程序范围ID不是合适的解决方案，因为ID可能需要跨应用程序共享。另一种解决方案是通过getId()方法使用AdvertisingIdClient.Info类中的广告标识符。应用可以使用getAdvertisingIdInfo(Context)方法创建AdvertisingIdClient.Info对象，并调用getId()方法以使用标识符。注意这个方法是阻塞的，所以你不应该从主线程调用它;这个方法的详细解释可以在这里找到</li>
</ul>
</li>
<li><strong>了解应用使用的第三方库</strong><ul>
<li>应用中使用的库也需要权限。例如，广告和分析库可能需要访问位置或身份权限组才能实现所需的功能。但从用户的角度来看，权限请求来自你的应用程序，而不是库。</li>
<li>正如用户选择相同功能使用较少权限的应用程序一样，开发人员应该查看其库并选择未使用不必要权限的第三方SDK。例如，尝试避免需要身份权限组的库，除非存在明确的面向用户的原因，为什么应用程序需要这些权限。特别是，对于提供位置功能的库，请确保您不需要请求FINE_LOCATION权限，除非使用基于位置的定位功能。</li>
</ul>
</li>
<li><strong>解释为什么需要权限</strong><ul>
<li>调用requestPermissions()时系统显示的权限对话框表示应用需要什么权限，但没有说明原因。在某些情况下，用户可能会觉得令人费解的。因此在调用requestPermissions()之前需要向用户解释为什么你的应用程序需要权限。</li>
<li>如果仅使用属于某个权限组的API调用的一小部分，则有助于明确列出正在使用哪些权限以及原因。例如：<ul>
<li>如果只使用粗略位置，请让用户在应用说明中或在有关应用的帮助文章中了解这一点。</li>
<li>如果需要访问短信以接收验证码，以保护用户免遭欺诈，请让用户在应用说明中和/或第一次访问数据时了解相关信息。</li>
<li>注意：如果应用程序的适配版本是Android 8.0（API级别26）或更高，请不要请求READ_SMS权限作为验证用户凭据的一部分。相反，请使用createAppSpecificSmsToken()生成特定于应用程序的令牌，然后将此令牌传递给可发送验证SMS消息的其他应用程序或服务。</li>
</ul>
</li>
<li>让用户实时了解敏感数据访问也是有利的也是有利的。例如，如果应用正在访问摄像头或麦克风，最好让用户知道应用程序中某处的通知图标或通知托盘中的通知图标（如果应用程序在后台运行），这表示应用不是在偷偷手机用户数据。</li>
<li>如果需要申请在应用中制作某些内容的权限，但其原因尚不清楚，请找到让用户知道为什么需要最敏感的权限。</li>
</ul>
</li>
</ul>
<h3 id="测试两种权限模式"><a href="#测试两种权限模式" class="headerlink" title="测试两种权限模式"></a>测试两种权限模式</h3><blockquote>
<p>从 Android 6.0 开始，用户在应用运行时允许或者拒绝权限而不是在应用安装时，这导致你需要测试各种条件下app 的表现。在 Android 6.0之前，你可以合理假定你的 app 一直可运行，它拥有所有在 app manifest中声明的权限。在新的权限模式下，你不能这么认为了。</p>
</blockquote>
<ul>
<li><p>以下提示将帮助你验证 Android 6.0及以上系统的权限相关代码问题。</p>
<ul>
<li><p>验证 app 当前权限以及相关代码路径。</p>
</li>
<li><p>测试用户通过权限保护服务和数据。</p>
</li>
<li><p>测试多种权限分别被允许、拒绝的组合情况。比如，相机 app 可能在 manifest 文件中声明了<code>CAMERA</code> 、 <code>READ_CONTACTS</code> 和 <code>ACCESS_FINE_LOCATION</code> 权限。你应该测试每个权限打开和关闭的情况来确保 app 可以优雅地处理所有权限配置情况。记住，从 Android 6.0开始用户可以打开或关闭任意一个app的权限，即便是 targets API 在 22及以下的。</p>
</li>
<li><p>使用 adb 工具通过命令行管理权限：</p>
<ul>
<li><p>以组的形式列出权限和状态：</p>
<p><code>$ adb shell pm list permissions -d -g</code></p>
</li>
<li><p>允许或拒绝一个或多个权限：</p>
<p><code>$ adb shell pm [grant|revoke]</code></p>
</li>
</ul>
</li>
<li><p>为使用权限的服务分析 app</p>
</li>
</ul>
</li>
</ul>
<p>##自定义应用权限</p>
<blockquote>
<p>通过定义自定义权限，应用程序可以与其他应用程序共享其资源和功能。</p>
</blockquote>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote>
<p>Android是一个权限隔离的操作系统，每个应用程序都以不同的系统标识（Linux用户标识和组标识）运行，Linux将应用程序与系统隔离开来。应用可以通过定义权限(其他应用可以请求)来将自身功能展示给其他应用。并且还可以定义自动提供给任何其他使用相同证书签名的应用程序的权限。</p>
</blockquote>
<ul>
<li><strong>应用签名：</strong>所有APK必须使用其开发人员拥有私钥的证书进行签名。此证书标识应用的作者。证书不需要由证书颁发机构签名;对于Android应用程序来说，使用自签名证书是完全可以允许并常用的。 Android中证书的用途是区分应用作者。这允许系统授予或拒绝应用程序访问签名级别的权限，并授予或拒绝应用程序的请求获得与另一个应用程序相同的Linux身份。</li>
<li><strong>用户ID和文件访问权限：</strong>在安装时，Android系统为每个应用提供独有的Linux用户ID。应用在该设备的使用寿命中，应用身份保持不变（UID不变）。同一个软件包在不同的设备上，可能有不同的UID;重要的是每个软件包在给定设备上具有不同的UID。由于安全实施发生在流程级别，因此任何两个软件包的代码通常无法在同一进程中运行，因为它们需要以不同的Linux用户身份运行。您可以使用每个软件包的AndroidManifest.xml清单标记中的sharedUserId属性为它们分配相同的用户ID。通过这样做，这两个包将被视为同一个应用程序，并具有相同的用户标识和文件权限。请注意，为了保持安全性，只有两个使用相同签名签名（并请求相同sharedUserId）的应用将被赋予相同的用户ID。应用程序存储的任何数据都将被分配该应用程序的用户ID，而其他软件包通常无法访问该ID。</li>
</ul>
<h3 id="定义和执行权限"><a href="#定义和执行权限" class="headerlink" title="定义和执行权限"></a>定义和执行权限</h3><ol>
<li><p>要执行权限，首先必须在AndroidManifest.xml中使用一个或多个<permission>元素声明。</permission></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest</span><br><span class="line">  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">  package=&quot;com.example.myapp&quot; &gt;</span><br><span class="line">    </span><br><span class="line">    &lt;permission</span><br><span class="line">      android:name=&quot;com.example.myapp.permission.DEADLY_ACTIVITY&quot;</span><br><span class="line">      android:label=&quot;@string/permlab_deadlyActivity&quot;</span><br><span class="line">      android:description=&quot;@string/permdesc_deadlyActivity&quot;</span><br><span class="line">      android:permissionGroup=&quot;android.permission-group.COST_MONEY&quot;</span><br><span class="line">      android:protectionLevel=&quot;dangerous&quot; /&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>注意：除非所有应用都使用相同的签名证书，否则系统不允许多个应用声明具有相同名称的权限。如果应用声明了权限，则系统不允许用户安装具有相同权限名的其它应用，除非应用的签名证书相同。为避免命名冲突，建议为自定义权限使用反向域名式命名，如com.example.myapp.ENGAGE_HYPERSPACE。</p>
</li>
<li><p>必需的使用protectionLevel属性，来告诉系统如何向用户通知需要许可的应用程序，或者允许谁拥有该许可权。</p>
</li>
<li><p>可选择使用android:permissionGroup属性，来帮助系统向用户显示权限。在大多数情况下，应用应该将其设置为标准系统权限组（在android.Manifest.permission_group中列出），尽管可以自己定义一个组。最好使用现有组，因为这简化了向用户显示的权限UI。</p>
</li>
<li><p>应用需要提供标签和描述权限。这些是用户在查看权限列表（android:label）或单个权限（android:description）上的详细信息时可以看到的字符串资源。标签应该是简短的，用几句话来描述权限所保护的关键功能。描述应该是几个句子，描述应用获取权限做什么。我们的约定是一个两个句子的描述：第一个句子描述权限，第二个句子警告用户在应用程序被授予权限时可能出错的类型。以下CALL_PHONE权限的标签和说明示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;string name=&quot;permlab_callPhone&quot;&gt;directly call phone numbers&lt;/string&gt;</span><br><span class="line">&lt;string name=&quot;permdesc_callPhone&quot;&gt;Allows the app to call</span><br><span class="line">    phone numbers without your intervention. Malicious apps may</span><br><span class="line">    cause unexpected calls on your phone bill. Note that this does not</span><br><span class="line">    allow the app to call emergency numbers.&lt;/string&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><strong>创建一个权限组</strong><ul>
<li>应用可以使用android:permissionGroup属性来帮助系统向用户描述权限。在大多数情况下，会希望将其设置为标准系统组（在android.Manifest.permission_group中列出），但也可以使用<permission-group>定义自己的组。</permission-group></li>
<li><permission-group>元素为一组权限定义了一个标签 - 这两个标签都在清单中用<permission>元素声明并在别处声明。这仅影响将权限分配给用户时的分组方式。 <permission-group>元素不指定属于该组的权限，但是它给该组一个名称。应用可以通过将组名分配给<permission>元素的permissionGroup属性来在组中放置权限。</permission></permission-group></permission></permission-group></li>
</ul>
</li>
<li><strong>自定义权限的建议</strong><ul>
<li>如果正在设计一系列向其它应用公开功能的应用程序，在设计应用程序时请尽量保证每个权限仅定义一次。如果应用程序未使用相同的证书签名，每个权限只能定义一次。即使这些应用程序都使用相同的证书进行签名，最好只定义一次权限。</li>
<li>如果该功能仅适用于使用于提供应用程序签名相同的签名的应用程序，则可以通过使用签名检查来避免定义自定义权限。当其中一个应用程序向另一个应用程序发出请求时，第二个应用程序可以验证这两个应用程序是否已使用相同的证书进行签名，然后再执行该请求。</li>
<li>如果您正在开发仅在自己的设备上安装的应用程序，则应开发并安装管理套件中所有应用程序权限的程序包。这个包不需要自己提供任何服务。它只是声明所有权限，而套件中的其他应用程序则使用<uses-permission>元素请求这些权限。</uses-permission></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/14/API Guide之应用基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="作茧自缚">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/14/API Guide之应用基础知识/" itemprop="url">API Guide之应用基础知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-14T22:04:45+08:00">
                2018-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/guide/" itemprop="url" rel="index">
                    <span itemprop="name">guide</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/14/API Guide之应用基础知识/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/03/14/API Guide之应用基础知识/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android应用的沙箱机制"><a href="#Android应用的沙箱机制" class="headerlink" title="Android应用的沙箱机制"></a>Android应用的沙箱机制</h1><h2 id="最小权限原则"><a href="#最小权限原则" class="headerlink" title="最小权限原则"></a>最小权限原则</h2><ul>
<li>Android操作系统是一个多用户的Linux系统，其中每个应用都是不同的用户，并且系统会为每个应用分配一个唯一的Linux用户ID（用户ID仅系统使用，应用并不知晓）。系统为应用中的所有文件设置权限，并且只可用分配给该应用的用户ID才能访问这些文件；</li>
<li>默认情况下，每个应用都运行在自己的Linux进程内，并且每个进程都有自己的虚拟机（VM），应用代码是在与其它应用隔离的环境中运行的。Android会在需要执行任何应用组建时启动该组件所在的进程，然后在不再需要该进程或者系统必须为其它应用提供内存时关闭该进程；</li>
<li>默认情况下，每个应用只能访问或执行其工作所需的组建，而并不能访问其他组件，并且应用无法访问系统中其未获取权限的部分。</li>
</ul>
<h2 id="共享数据和访问系统服务"><a href="#共享数据和访问系统服务" class="headerlink" title="共享数据和访问系统服务"></a>共享数据和访问系统服务</h2><ul>
<li>两个应用共享同一Linux用户ID时，它们可以相互访问彼此的文件，同时为了节省系统资源，可以安排具有相同用户ID的应用在同一Linux进程中运行，共享同一VM（签名证书相同）。</li>
<li>在获取相应权限的条件下，应用可以请求访问设备中的数据（如用户的联系人、短信、可装载存储装置 [SD 卡]、相机、蓝牙等）。 </li>
</ul>
<h1 id="应用组件"><a href="#应用组件" class="headerlink" title="应用组件"></a>应用组件</h1><blockquote>
<p>应用组件是Android应用构建的基块。每个组件都是一个不同的点，系统可以通过组件进入应用。并非所有组件都是用户的实际入口，有些组件互相依赖，但每个组件都以独立实体的形式存在，并发挥特定作用 — 每个组件都是唯一的构建基块，有助于定义应用的总体行为。共有四种类型的组件分别是：Activity、服务、内容提供者、广播接收器。</p>
</blockquote>
<h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><ul>
<li>Activity表示具有用户界面的单一屏幕。</li>
</ul>
<h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><ul>
<li>服务是一种在后台运行的组件，用于执行长时间运行的操作或为远程进程执行作业。 服务不提供用户界面。 例如，当用户位于其他应用中时，服务可能在后台播放音乐或者通过网络获取数据，但不会阻断用户与 Activity 的交互。 诸如 Activity 等其他组件可以启动服务，让其运行或与其绑定以便与其进行交互。</li>
</ul>
<h2 id="内容提供程序"><a href="#内容提供程序" class="headerlink" title="内容提供程序"></a>内容提供程序</h2><ul>
<li>内容提供程序管理一组共享的应用数据。可以将数据存储在文件系统、SQLite 数据库、网络上或者应用可以访问的任何其他永久性存储位置。 其他应用可以通过内容提供程序查询数据，甚至修改数据（如果内容提供程序允许）。 例如，Android 系统可提供管理用户联系人信息的内容提供程序。 因此，任何具有适当权限的应用都可以查询内容提供程序的某一部分（如 <code>ContactsContract.Data</code>），以读取和写入有关特定人员的信息。内容提供程序也适用于读取和写入应用不共享的私有数据。 例如，<a href="https://developer.android.google.cn/resources/samples/NotePad/index.html" target="_blank" rel="noopener">记事本</a>示例应用使用内容提供程序来保存笔记。</li>
</ul>
<h2 id="广播接收器"><a href="#广播接收器" class="headerlink" title="广播接收器"></a>广播接收器</h2><ul>
<li>广播接收器是一种用于响应系统范围广播通知的组件。 许多广播都是由系统发起的，应用自身也可以发起广播 — 例如。 尽管广播接收器不会显示用户界面，但它们可以创建状态栏通知在发生广播事件时提醒用户。 但广播接收器更常见的用途只是作为通向其他组件的“通道”，设计用于执行极少量的工作。</li>
</ul>
<h1 id="启动组件"><a href="#启动组件" class="headerlink" title="启动组件"></a>启动组件</h1><p>在 Android 系统启动应用组件之前，系统必须通过读取应用的 <code>AndroidManifest.xml</code> 文件（“清单”文件）确认组件存在。 应用必须在此文件中声明其所有组件，该文件必须位于应用项目目录的根目录中。</p>
<p>除了声明应用的组件外，清单文件还有许多其他作用，如：</p>
<ul>
<li>确定应用需要的任何用户权限，如互联网访问权限或对用户联系人的读取权限</li>
<li>根据应用使用的 API，声明应用所需的最低 <a href="https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element.html#ApiLevels" target="_blank" rel="noopener">API 级别</a></li>
<li>声明应用使用或需要的硬件和软件功能，如相机、蓝牙服务或多点触摸屏幕</li>
<li>应用需要链接的 API 库（Android 框架 API 除外），如 <a href="http://code.google.com/android/add-ons/google-apis/maps-overview.html" target="_blank" rel="noopener">Google 地图库</a></li>
<li>其他功能</li>
</ul>
<h1 id="声明组件"><a href="#声明组件" class="headerlink" title="声明组件"></a>声明组件</h1><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li>清单文件的主要任务是告知系统有关应用组件的信息。例如，清单文件可以像下面这样声明 Activity：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;manifest ... &gt;</span><br><span class="line">    &lt;application android:icon=&quot;@drawable/app_icon.png&quot; ... &gt;</span><br><span class="line">        &lt;activity android:name=&quot;com.example.project.ExampleActivity&quot;</span><br><span class="line">                  android:label=&quot;@string/example_label&quot; ... &gt;</span><br><span class="line">        &lt;/activity&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>&lt;application&gt;</code> 元素中，<code>android:icon</code> 属性指向标识应用的图标所对应的资源。</li>
<li>在 <code>&lt;activity&gt;</code> 元素中，<code>android:name</code> 属性指定 <code>Activity</code> 子类的完全限定类名，<code>android:label</code> 属性指定用作 Activity 的用户可见标签的字符串。</li>
<li>必须通过以下方式声明所有应用组件：<ul>
<li>Activity 的 <code>&lt;activity&gt;</code> 元素</li>
<li>服务的 <code>&lt;service&gt;</code> 元素</li>
<li>广播接收器的 <code>&lt;receiver&gt;</code> 元素</li>
<li>内容提供程序的 <code>&lt;provider&gt;</code> 元素</li>
</ul>
</li>
<li>未在清单文件中声明的 Activity、服务和内容提供程序对系统不可见，因此也永远不会运行。 不过，广播接收器可以在清单文件中声明或在代码中动态创建（如 <code>BroadcastReceiver</code> 对象）并通过调用 <code>registerReceiver()</code> 在系统中注册。</li>
</ul>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li><p>可以使用 <code>Intent</code> 来启动 Activity、服务和广播接收器。 可以通过在 Intent 中显式命名目标组件（使用组件类名）来执行此操作。 不过，Intent 的真正强大之处在于<em>隐式 Intent</em> 概念。 隐式 Intent 的作用无非是描述要执行的操作类型（还可选择描述您想执行的操作所针对的数据），让系统能够在设备上找到可执行该操作的组件，并启动该组件。 如果有多个组件可以执行 Intent 所描述的操作，则由用户选择使用哪一个组件。</p>
</li>
<li><p>系统通过将接收到的 Intent 与设备上的其他应用的清单文件中提供的 <em>Intent 过滤器</em>进行比较来确定可以响应 Intent 的组件。</p>
</li>
<li><p>当应用在清单文件中声明 Activity 时，可以选择性地加入声明 Activity 功能的 Intent 过滤器，以便响应来自其他应用的 Intent。 您可以通过将 <a href="https://developer.android.google.cn/guide/topics/manifest/intent-filter-element.html" target="_blank" rel="noopener"><code></code></a> 元素作为组件声明元素的子项进行添加来为您的组件声明 Intent 过滤器。</p>
</li>
<li><p>例如，如果您开发的电子邮件应用包含一个用于撰写新电子邮件的 Activity，则可以像下面这样声明一个 Intent 过滤器来响应“send” Intent（以发送新电子邮件），然后，如果另一个应用创建了一个包含<code>ACTION_SEND</code> 操作的 Intent，并将其传递到 <code>startActivity()</code>，则系统可能会启动您的 Activity，以便用户能够草拟并发送电子邮件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest ... &gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;application ... &gt;</span><br><span class="line">        &lt;activity android:name=&quot;com.example.project.ComposeEmailActivity&quot;&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.intent.action.SEND&quot; /&gt;</span><br><span class="line">                &lt;data android:type=&quot;*/*&quot; /&gt;</span><br><span class="line">                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">        &lt;/activity&gt;</span><br><span class="line">    &lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<h1 id="声明应用要求"><a href="#声明应用要求" class="headerlink" title="声明应用要求"></a>声明应用要求</h1><ul>
<li>基于 Android 系统的设备多种多样，并非所有设备都提供相同的特性和功能。 为防止将您的应用安装在缺少应用所需特性的设备上，您必须通过在清单文件中声明设备和软件要求，为您的应用支持的设备类型明确定义一个配置文件。 其中的大多数声明只是为了提供信息，系统不会读取它们，但 Google Play 等外部服务会读取它们，以便当用户在其设备中搜索应用时为用户提供过滤功能。</li>
</ul>
<h1 id="应用资源"><a href="#应用资源" class="headerlink" title="应用资源"></a>应用资源</h1><ul>
<li>Android 应用并非只包含代码 — 它还需要与源代码分离的资源，如图像、音频文件以及任何与应用的视觉呈现有关的内容。 例如，您应该通过 XML 文件定义 Activity 用户界面的动画、菜单、样式、颜色和布局。 使用应用资源能够在不修改代码的情况下轻松地更新应用的各种特性，并可通过提供备用资源集让您能够针对各种设备配置（如不同的语言和屏幕尺寸）优化您的应用。</li>
<li>对于 Android 项目中包括的每一项资源，SDK 构建工具都会定义一个唯一的整型 ID，您可以利用它来引用应用代码或 XML 中定义的其他资源中的资源。 例如，如果您的应用包含一个名为 <code>logo.png</code> 的图像文件（保存在 <code>res/drawable/</code> 目录中），则 SDK 工具会生成一个名为 <code>R.drawable.logo</code> 的资源 ID，您可以利用它来引用该图像并将其插入您的用户界面。</li>
<li>提供与源代码分离的资源的其中一个最重要优点在于，您可以提供针对不同设备配置的备用资源。 例如，通过在 XML 中定义 UI 字符串，您可以将字符串翻译为其他语言，并将这些字符串保存在单独的文件中。 然后，Android 系统会根据向资源目录名称追加的语言<em>限定符</em>（如为法语字符串值追加 <code>res/values-fr/</code>）和用户的语言设置，对您的 UI 应用相应的语言字符串。</li>
<li>Android 支持许多不同的备用资源限定符。限定符是一种加入到资源目录名称中，用来定义这些资源适用的设备配置的简短字符串。 再举一例，您应该经常会根据设备的屏幕方向和尺寸为 Activity 创建不同的布局。 例如，当设备屏幕为纵向（长型）时，您可能想要一种垂直排列按钮的布局；但当屏幕为横向（宽型）时，应按水平方向排列按钮。 要想根据方向更改布局，您可以定义两种不同的布局，然后对每个布局的目录名称应用相应的限定符。 然后，系统会根据当前设备方向自动应用相应的布局。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/25/Activity的窗口管理机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="作茧自缚">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/25/Activity的窗口管理机制/" itemprop="url">Activity的窗口管理机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-25T03:33:06+08:00">
                2018-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">Android源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/25/Activity的窗口管理机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/02/25/Activity的窗口管理机制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://ouv36g1sw.bkt.clouddn.com/Activity%E7%BB%93%E6%9E%84%E5%9B%BE" alt="Activity窗口结构图"></p>
<blockquote>
<p>上图为Activity的窗口结构图，每一个Activity都包含了一个Window对象，而Window对象通常由PhoneWindow实现。DecorView是一个应用窗口的根容器，它本质上是一个FrameLayout。DecorView有唯一一个子View也就是LinearLayout，包含两个子元素FrameLayout，一个是装载了TitleView（ActionBar的容器），另一个是ContentView（窗口内容的容器）。我们平常用的setContentView就是设置ContentView的子View,内部实现为PhoneWindow中的setContentView()中初始化DecorView后的LayoutInflater.inflate(layoutResID, mContentParent);方法。上图还表达了每个Activity都与一个Window（具体来说是PhoneWindow）相关联，用户界面则由Window所承载。</p>
</blockquote>
<ul>
<li><strong>Activity：</strong>与用户交互的可视化组件。</li>
<li><strong>Window</strong>：是Activity中的顶级窗口查看和行为的一个抽象基类。该类的实例作为一个顶级View添加到WindowManager。提供了一套标准的UI方法。可以将之理解为一个载体，各种View在这个载体上显示。</li>
<li><strong>PhoneWindow：</strong><ul>
<li>WIndow的唯一实现类，可以通过该类具体去绘制窗口。</li>
<li>并且，该类内部包含了一个DecorView对象，DectorView对象是所有应用窗口(Activity界面)的根View。</li>
<li>PhoneWindow类是把DecorView对象进行一定的包装，将它作为应用窗口的根View，并提供一组通用的窗口操作接口。</li>
</ul>
</li>
<li><strong>DecorView：</strong><ul>
<li>DecorView是FrameLayout的子类，它可以被认为是Android视图树的根节点视图。</li>
<li>DecorView作为顶级View，一般情况下它内部包含一个竖直方向的LinearLayout，在这个LinearLayout里面有上下两个部分（具体情况和Android版本及主体有关），上面的是标题栏，下面的是内容栏。</li>
</ul>
</li>
<li><strong>ViewRoot以及ViewRootImpl：</strong><ul>
<li>ViewRoot对应ViewRootImpl类，它是连接WindowManagerService和DecorView的纽带，View的三大流程（测量measure，布局layout，绘制draw）均通过ViewRoot来完成。</li>
<li>ViewRoot与ViewRootImpl的功能是一样的，只不过是Android不同版本的不同称呼，ViewRoot在Android2.2之后就被ViewRootImpl替换了。</li>
<li>ViewRoot是WindowManagerGlobal工作的实际实现者，它还需要负责与WMS交互通信以调整窗口的位置大小，以及对来自WMS的事件（如窗口尺寸改变等）作出相应的处理。</li>
</ul>
</li>
<li><strong>WindowManager</strong>：一个继承自ViewManager的接口。ViewManager定义了三个函数，分别用于添加/删除一个控件，以及更新控件的布局。</li>
<li><strong>ViewManager：</strong>该接口的另一个实现者是ViewGroup，它是容器类控件的基类，用于将一组控件容纳到自身的区域中，这一组控件被称为子控件。ViewGroup可以根据子控件的布局参数（LayoutParams）在其自身的区域中对子控件进行布局。</li>
</ul>
<h3 id="PhoneWindow和DecorView的关系"><a href="#PhoneWindow和DecorView的关系" class="headerlink" title="PhoneWindow和DecorView的关系"></a>PhoneWindow和DecorView的关系</h3><ul>
<li><p>Activity的setContentView()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void setContentView(@LayoutRes int layoutResID) &#123;</span><br><span class="line">		/*</span><br><span class="line">         * 获取Activity中的Window,这里获取到的是在Activity中的attach方法里面吗，通过</span><br><span class="line">         * mWindow = new PhoneWindow(this, window, activityConfigCallback);获取需要的Window对象</span><br><span class="line">         */</span><br><span class="line">        getWindow().setContentView(layoutResID);</span><br><span class="line">        // 在ActionBarView中创建并初始化Actionbar</span><br><span class="line">        initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>PhoneWindow的setContentView()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void setContentView(int layoutResID) &#123;</span><br><span class="line">	// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span><br><span class="line">	// decor, when theme attributes and the like are crystalized. Do not check the feature</span><br><span class="line">	// before this happens.</span><br><span class="line">	if (mContentParent == null) &#123;</span><br><span class="line">		// 创建DecorView，并添加到mContentParent上</span><br><span class="line">		installDecor();</span><br><span class="line">		// FEATURE_CONTENT_TRANSITIONS:标记当前内容加载有没有使用过度动画(转场动画)。</span><br><span class="line">		// 如果内容已经加载过，并且不需要动画，则会调用removeAllViews。</span><br><span class="line">		// 添加完Content后如有设置了FEATURE_CONTENT_TRANSITIONS则添加Scene来过度启动。</span><br><span class="line">		// 否则mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">		// 将我们的资源文件通过LayoutInflater对象转换为View树，并且添加至mContentParent视图中。</span><br><span class="line">	&#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">		mContentParent.removeAllViews();</span><br><span class="line">	&#125;</span><br><span class="line">	// Content后如有设置了FEATURE_CONTENT_TRANSITIONS则添加Scene来过度启动</span><br><span class="line">	if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">		final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,getContext());</span><br><span class="line">		transitionTo(newScene);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">	   // 将资源文件通过LayoutInflater对象转换为View树,并添加到mContentParent上</span><br><span class="line">		mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">	&#125;</span><br><span class="line">	mContentParent.requestApplyInsets();</span><br><span class="line">	final Callback cb = getCallback();</span><br><span class="line">	if (cb != null &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">		cb.onContentChanged();</span><br><span class="line">	&#125;</span><br><span class="line">	mContentParentExplicitlySet = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>installDecor()创建DecorView</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">private void installDecor() &#123;</span><br><span class="line">    mForceDecorInstall = false;</span><br><span class="line">    if (mDecor == null) &#123;</span><br><span class="line">    	// 创建DecorView</span><br><span class="line">        mDecor = generateDecor(-1);</span><br><span class="line">        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">        mDecor.setIsRootNamespace(true);</span><br><span class="line">        if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) &#123;</span><br><span class="line">            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mDecor.setWindow(this);</span><br><span class="line">    &#125;</span><br><span class="line">    // 开始DecorView未加载到mContentParent，所以此时mContentParent=null</span><br><span class="line">    if (mContentParent == null) &#123;</span><br><span class="line">    	// 将mDecorView添加到Window上绑定布局		</span><br><span class="line">        mContentParent = generateLayout(mDecor);</span><br><span class="line"></span><br><span class="line">        // Set up decor part of UI to ignore fitsSystemWindows if appropriate.</span><br><span class="line">        mDecor.makeOptionalFitsSystemWindows();</span><br><span class="line"></span><br><span class="line">        final DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById(</span><br><span class="line">                R.id.decor_content_parent);</span><br><span class="line">  			</span><br><span class="line">        if (decorContentParent != null) &#123;</span><br><span class="line">            mDecorContentParent = decorContentParent;</span><br><span class="line">            mDecorContentParent.setWindowCallback(getCallback());</span><br><span class="line">            if (mDecorContentParent.getTitle() == null) &#123;</span><br><span class="line">                mDecorContentParent.setWindowTitle(mTitle);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final int localFeatures = getLocalFeatures();</span><br><span class="line">            for (int i = 0; i &lt; FEATURE_MAX; i++) &#123;</span><br><span class="line">                if ((localFeatures &amp; (1 &lt;&lt; i)) != 0) &#123;</span><br><span class="line">                    mDecorContentParent.initFeature(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mDecorContentParent.setUiOptions(mUiOptions);</span><br><span class="line"></span><br><span class="line">            if ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_ICON) != 0 ||</span><br><span class="line">                    (mIconRes != 0 &amp;&amp; !mDecorContentParent.hasIcon())) &#123;</span><br><span class="line">                mDecorContentParent.setIcon(mIconRes);</span><br><span class="line">            &#125; else if ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_ICON) == 0 &amp;&amp;</span><br><span class="line">                    mIconRes == 0 &amp;&amp; !mDecorContentParent.hasIcon()) &#123;</span><br><span class="line">                mDecorContentParent.setIcon(</span><br><span class="line">                        getContext().getPackageManager().getDefaultActivityIcon());</span><br><span class="line">                mResourcesSetFlags |= FLAG_RESOURCE_SET_ICON_FALLBACK;</span><br><span class="line">            &#125;</span><br><span class="line">            if ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_LOGO) != 0 ||</span><br><span class="line">                    (mLogoRes != 0 &amp;&amp; !mDecorContentParent.hasLogo())) &#123;</span><br><span class="line">                mDecorContentParent.setLogo(mLogoRes);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Invalidate if the panel menu hasn&apos;t been created before this.</span><br><span class="line">            // Panel menu invalidation is deferred avoiding application onCreateOptionsMenu</span><br><span class="line">            // being called in the middle of onCreate or similar.</span><br><span class="line">            // A pending invalidation will typically be resolved before the posted message</span><br><span class="line">            // would run normally in order to satisfy instance state restoration.</span><br><span class="line">            PanelFeatureState st = getPanelState(FEATURE_OPTIONS_PANEL, false);</span><br><span class="line">            if (!isDestroyed() &amp;&amp; (st == null || st.menu == null) &amp;&amp; !mIsStartingWindow) &#123;</span><br><span class="line">                invalidatePanelMenu(FEATURE_ACTION_BAR);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mTitleView = findViewById(R.id.title);</span><br><span class="line">            if (mTitleView != null) &#123;</span><br><span class="line">                if ((getLocalFeatures() &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) != 0) &#123;</span><br><span class="line">                    final View titleContainer = findViewById(R.id.title_container);</span><br><span class="line">                    if (titleContainer != null) &#123;</span><br><span class="line">                        titleContainer.setVisibility(View.GONE);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mTitleView.setVisibility(View.GONE);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mContentParent.setForeground(null);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mTitleView.setText(mTitle);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mDecor.getBackground() == null &amp;&amp; mBackgroundFallbackResource != 0) &#123;</span><br><span class="line">            mDecor.setBackgroundFallback(mBackgroundFallbackResource);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Only inflate or create a new TransitionManager if the caller hasn&apos;t</span><br><span class="line">        // already set a custom one.</span><br><span class="line">        // 设置转场动画</span><br><span class="line">        if (hasFeature(FEATURE_ACTIVITY_TRANSITIONS)) &#123;</span><br><span class="line">            if (mTransitionManager == null) &#123;</span><br><span class="line">                final int transitionRes = getWindowStyle().getResourceId(</span><br><span class="line">                        R.styleable.Window_windowContentTransitionManager,</span><br><span class="line">                        0);</span><br><span class="line">                if (transitionRes != 0) &#123;</span><br><span class="line">                    final TransitionInflater inflater = TransitionInflater.from(getContext());</span><br><span class="line">                    mTransitionManager = inflater.inflateTransitionManager(transitionRes,</span><br><span class="line">                            mContentParent);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mTransitionManager = new TransitionManager();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mEnterTransition = getTransition(mEnterTransition, null,</span><br><span class="line">                    R.styleable.Window_windowEnterTransition);</span><br><span class="line">            mReturnTransition = getTransition(mReturnTransition, USE_DEFAULT_TRANSITION,</span><br><span class="line">                    R.styleable.Window_windowReturnTransition);</span><br><span class="line">            mExitTransition = getTransition(mExitTransition, null,</span><br><span class="line">                    R.styleable.Window_windowExitTransition);</span><br><span class="line">            mReenterTransition = getTransition(mReenterTransition, USE_DEFAULT_TRANSITION,</span><br><span class="line">                    R.styleable.Window_windowReenterTransition);</span><br><span class="line">            mSharedElementEnterTransition = getTransition(mSharedElementEnterTransition, null,</span><br><span class="line">                    R.styleable.Window_windowSharedElementEnterTransition);</span><br><span class="line">            mSharedElementReturnTransition = getTransition(mSharedElementReturnTransition,</span><br><span class="line">                    USE_DEFAULT_TRANSITION,</span><br><span class="line">                    R.styleable.Window_windowSharedElementReturnTransition);</span><br><span class="line">            mSharedElementExitTransition = getTransition(mSharedElementExitTransition, null,</span><br><span class="line">                    R.styleable.Window_windowSharedElementExitTransition);</span><br><span class="line">            mSharedElementReenterTransition = getTransition(mSharedElementReenterTransition,</span><br><span class="line">                    USE_DEFAULT_TRANSITION,</span><br><span class="line">                    R.styleable.Window_windowSharedElementReenterTransition);</span><br><span class="line">            if (mAllowEnterTransitionOverlap == null) &#123;</span><br><span class="line">                mAllowEnterTransitionOverlap = getWindowStyle().getBoolean(</span><br><span class="line">                        R.styleable.Window_windowAllowEnterTransitionOverlap, true);</span><br><span class="line">            &#125;</span><br><span class="line">            if (mAllowReturnTransitionOverlap == null) &#123;</span><br><span class="line">                mAllowReturnTransitionOverlap = getWindowStyle().getBoolean(</span><br><span class="line">                        R.styleable.Window_windowAllowReturnTransitionOverlap, true);</span><br><span class="line">            &#125;</span><br><span class="line">            if (mBackgroundFadeDurationMillis &lt; 0) &#123;</span><br><span class="line">                mBackgroundFadeDurationMillis = getWindowStyle().getInteger(</span><br><span class="line">                        R.styleable.Window_windowTransitionBackgroundFadeDuration,</span><br><span class="line">                        DEFAULT_BACKGROUND_FADE_DURATION_MS);</span><br><span class="line">            &#125;</span><br><span class="line">            if (mSharedElementsUseOverlay == null) &#123;</span><br><span class="line">                mSharedElementsUseOverlay = getWindowStyle().getBoolean(</span><br><span class="line">                        R.styleable.Window_windowSharedElementsUseOverlay, true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建DecorView</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected DecorView generateDecor() &#123;</span><br><span class="line">	return new DecorView(getContext(), -1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将setContentView的内容赋值到mContentParent</p>
<ul>
<li><p>generateLayout会根据当前用户设置的主题去设置对应的Feature</p>
</li>
<li><p>根据对应的Feature来选择加载对应的布局文件，(Window.FEATURE_NO_TITLE)接下来通过getLocalFeatures来获取你设置的feature，进而选择加载对应的布局，因此需要在<strong>setContentView之前调用requesetFeature</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">protected ViewGroup generateLayout(DecorView decor) &#123;</span><br><span class="line">        // Apply data from current theme.</span><br><span class="line">        // 根据当前设置的主题来加载默认布局</span><br><span class="line">        TypedArray a = getWindowStyle();</span><br><span class="line">        // 如果你在theme中设置了window_windowNoTitle，则这里会调用到，其他方法同理，</span><br><span class="line">        // 这里是根据你在theme中的设置去设置的</span><br><span class="line">        if (a.getBoolean(R.styleable.Window_windowNoTitle, false)) &#123;</span><br><span class="line">            requestFeature(FEATURE_NO_TITLE);</span><br><span class="line">        &#125; else if (a.getBoolean(R.styleable.Window_windowActionBar, false)) &#123;</span><br><span class="line">            // Don&apos;t allow an action bar if there is no title.</span><br><span class="line">            requestFeature(FEATURE_ACTION_BAR);</span><br><span class="line">        &#125;</span><br><span class="line">        // 是否有设置全屏</span><br><span class="line">        if (a.getBoolean(R.styleable.Window_windowFullscreen, false)) &#123;</span><br><span class="line">            setFlags(FLAG_FULLSCREEN, FLAG_FULLSCREEN &amp; (~getForcedWindowFlags()));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...//省略其他加载资源</span><br><span class="line">       </span><br><span class="line">        /* </span><br><span class="line">         * 添加布局到DecorView，前面说到，DecorView是继承与FrameLayout，它本身也是一个</span><br><span class="line">         * ViewGroup，而我们前面创建它的时候，只是调用了new DecorView，此时里面并无什么东西。而下</span><br><span class="line">         * 面的步奏则是根据用户设置的Feature来创建相应的默认布局主题。举个例子，如果我在</span><br><span class="line">         * setContentView之前调用了 requestWindowFeature(Window.FEATURE_NO_TITLE)，这里则会通</span><br><span class="line">         * 过getLocalFeatures来获取你设置的feature，进而选择加载对应的布局，此时是加载没有标题栏</span><br><span class="line">         * 的主题，对应的就是R.layout.screen_simple</span><br><span class="line">         */</span><br><span class="line">        int layoutResource;</span><br><span class="line">        int features = getLocalFeatures();</span><br><span class="line">        // System.out.println(&quot;Features: 0x&quot; + Integer.toHexString(features));</span><br><span class="line">        if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) &#123;</span><br><span class="line">            layoutResource = R.layout.screen_swipe_dismiss;</span><br><span class="line">        &#125; ... //省略其他判断方法</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Embedded, so no decoration is needed.</span><br><span class="line">            layoutResource = R.layout.screen_simple;</span><br><span class="line">            // System.out.println(&quot;Simple!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mDecor.startChanging();</span><br><span class="line">        // 选择对应布局创建添加到DecorView中</span><br><span class="line">        View in = mLayoutInflater.inflate(layoutResource, null);</span><br><span class="line">        decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">        mContentRoot = (ViewGroup) in;</span><br><span class="line">        ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">        ...</span><br><span class="line">        return contentParent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
</li>
<li><p>通知界面改变</p>
<ul>
<li><p>调用Callback来通知界面发生改变。Callback是Window里面的一个接口，里面声明了当界面更改触摸时调用的各种方法。</p>
</li>
<li><p>而通知改变的回掉方法就是onContentChanged，在PhoneWindow里面并没有看到onContentChanged的实现类，而我们又知道Activity本身又是加载在Window上的，所以如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Activity extends ContextThemeWrapper</span><br><span class="line">        implements LayoutInflater.Factory2,</span><br><span class="line">        Window.Callback, KeyEvent.Callback,</span><br><span class="line">        OnCreateContextMenuListener, ComponentCallbacks2,</span><br><span class="line">        Window.OnWindowDismissedCallback &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Activity里面实现了Window.Callback接口而里面onContentChanged则是空的，因此可以重写改方法来监听布局的改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void onContentChanged() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
</li>
</ul>
<h3 id="DecorView的添加"><a href="#DecorView的添加" class="headerlink" title="DecorView的添加"></a>DecorView的添加</h3><ol>
<li><p>在Activity的启动过程中会执行<code>ActivityThread#performLaunchActivity</code>方法，其中调用Activity#attach。在attach()方法中实例化Activity持有的mWindow属性为Window的唯一实现类PhoneWindow。</p>
</li>
<li><p>在<code>ActivityThread#handleResumeActivity</code>中，通过<code>wm.addView(decor, l);</code>往 Window 添加 View。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final void handleResumeActivity(IBinder token,</span><br><span class="line">           boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123;</span><br><span class="line">	...</span><br><span class="line">	   if (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123;</span><br><span class="line">                   a.mWindowAdded = true;</span><br><span class="line">                   wm.addView(decor, l);//往 Window 添加 View。vm为该Activity的WindowManager</span><br><span class="line">               &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>WindowManager 是一个接口，因此 addView 的操作是有其子类去实现的，而 WindowManager 的实现类就是 WindowManagerImpl。然而WindowManagerImpl又将其交由WindowManagerGlobal实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123;</span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    // private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();</span><br><span class="line">    mGlobal.addView(view, params, mDisplay, mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>WindowManagerGlobal.addView 的过程</p>
<ol>
<li>创建ViewRootImpl实例;</li>
<li>在 addView 中创建 Window 对应的 ViewRootImpl 对象。并且往mViews、mRootsmParams、mDyingViews 中保存当前 View 的信息。最后调用 root.setView(view, wparams, panelParentView);</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void addView(View view, ViewGroup.LayoutParams params,</span><br><span class="line">        Display display, Window parentWindow) &#123;</span><br><span class="line">    //校验操作</span><br><span class="line"></span><br><span class="line">    final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line"></span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = null;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        int index = findViewLocked(view, false);</span><br><span class="line">        if (index &gt;= 0) &#123;</span><br><span class="line">            if (mDyingViews.contains(view)) &#123;</span><br><span class="line">                // Don&apos;t wait for MSG_DIE to make it&apos;s way through root&apos;s queue.</span><br><span class="line">                mRoots.get(index).doDie();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;View &quot; + view</span><br><span class="line">                        + &quot; has already been added to the window manager.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // The previous removeView() had not completed executing. Now it has.</span><br><span class="line">        &#125;</span><br><span class="line">        //创建 ViewRootImpl 对象。</span><br><span class="line">        root = new ViewRootImpl(view.getContext(), display);</span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line">        //保存到集合中</span><br><span class="line">        mViews.add(view);</span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        mParams.add(wparams);</span><br><span class="line">    &#125;</span><br><span class="line">    // 调用 View 的绘制代码</span><br><span class="line">    root.setView(view, wparams, panelParentView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>DecorView的真正显示</p>
<blockquote>
<p>现在 Window 对应的视图已经准备好了，但是仍为不可见的，在ActivityThread#handleResumeActivity 代码。这时会去调用 Activity#makeVisible()方法。ActivityThread#handleResumeActivity中 DecorView 被设置为 invisible 因此在这时Decor 会被设置为 View.VISIBLE。至此 View 就真正的显示出来了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// ActivityThread#handleResumeActivity</span><br><span class="line">r.activity.mVisibleFromServer = true;</span><br><span class="line">if (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">   r.activity.makeVisible();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Activity#makeVisible()</span><br><span class="line">void makeVisible() &#123;</span><br><span class="line">    if (!mWindowAdded) &#123;//判断 DecorView 是否被添加到 Window 中</span><br><span class="line">        ViewManager wm = getWindowManager();</span><br><span class="line">        wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">        mWindowAdded = true;</span><br><span class="line">    &#125;</span><br><span class="line">    mDecor.setVisibility(View.VISIBLE);//让 View 设置为可见</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="View的绘制"><a href="#View的绘制" class="headerlink" title="View的绘制"></a>View的绘制</h3><blockquote>
<p>View的绘制流程从ViewRoot或ViewRootImpl开始的，经过measure、layout和draw三个过程才能最终绘制一个View。</p>
</blockquote>
<h4 id="measure"><a href="#measure" class="headerlink" title="measure"></a>measure</h4><blockquote>
<p>测量视图的大小的。View系统的绘制流程会从ViewRoot的performTraversals()方法中开始，在其内部调用View的measure()方法。</p>
</blockquote>
<ul>
<li><p><strong>measure()</strong>方法接收两个参数，widthMeasureSpec和heightMeasureSpec，这两个值分别用于确定视图的宽度和高度的规格和大小。widthMeasureSpec和heightMeasureSpec由getRootMeasureSpec(windowSize, rootDimension)方法获得。注意方法中传入的参数，其中lp.width和lp.height在创建ViewGroup实例的时候就被赋值了，它们都等于MATCH_PARENT。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);  </span><br><span class="line">childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Figures out the measure spec for the root view in a window based on it&apos;s</span><br><span class="line"> * layout params.</span><br><span class="line"> *</span><br><span class="line"> * @param windowSize</span><br><span class="line"> *            The available width or height of the window</span><br><span class="line"> *</span><br><span class="line"> * @param rootDimension</span><br><span class="line"> *            The layout params for one dimension (width or height) of the</span><br><span class="line"> *            window.</span><br><span class="line"> *</span><br><span class="line"> * @return The measure spec to use to measure the root view.</span><br><span class="line"> */</span><br><span class="line">private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123;</span><br><span class="line">    int measureSpec;</span><br><span class="line">    switch (rootDimension) &#123;</span><br><span class="line"></span><br><span class="line">    case ViewGroup.LayoutParams.MATCH_PARENT:</span><br><span class="line">        // Window can&apos;t resize. Force root view to be windowSize.</span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">        break;</span><br><span class="line">    case ViewGroup.LayoutParams.WRAP_CONTENT:</span><br><span class="line">        // Window can resize. Set max size for root view.</span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        // Window wants to be an exact size. Force root view to be that size.</span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return measureSpec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>MeasureSpec</strong>：由specSize和specMode共同组成的，其中specSize记录的是大小，specMode记录的是规格。specMode一共有三种类型：</p>
<ul>
<li><strong>EXACTLY</strong>：表示父视图希望子视图的大小应该是由specSize的值来决定的，系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。</li>
<li><strong>AT_MOST</strong>：表父容器指定了一个可用大小即 SpecSize ,子视图最多只能是 specSize 中指定的大小，开发人员应该尽可能小得去设置这个视图，并且保证不会超过specSize。系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。</li>
<li><strong>UNSPECIFIED</strong>：表示开发人员可以将视图按照自己的意愿设置成任意的大小，没有任何限制。这种情况比较少见，不太会用到。</li>
</ul>
</li>
<li><p><strong>measure从父容器传递到子元素中</strong>所以 View 的 measure 是由ViewGroup的measureChildWithMargins() 方法传递而来，在该方法中measure子元素之前会通过 getChildMeasureSpec方法来得到子元素的MeasureSpec 。</p>
<ul>
<li><p><strong>measureChildWithMargins()</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected void measureChildWithMargins(View child,</span><br><span class="line">          int parentWidthMeasureSpec, int widthUsed,</span><br><span class="line">          int parentHeightMeasureSpec, int heightUsed) &#123;</span><br><span class="line">      final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line">      final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">              mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                      + widthUsed, lp.width);</span><br><span class="line">      final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">              mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                      + heightUsed, lp.height);</span><br><span class="line"></span><br><span class="line">      child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>getChildMeasureSpec()</strong>：根据父容器的 MeasureSpec 同时结合 View 本身的 LayoutParams 来确定子元素的 MeasureSpec ，参数中的 padding 是指父容器中已占空间的大小，因此子元素的可用大小位父容器的的尺寸减去 padding。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123;</span><br><span class="line">        int specMode = MeasureSpec.getMode(spec);</span><br><span class="line">        int specSize = MeasureSpec.getSize(spec);</span><br><span class="line"></span><br><span class="line">        int size = Math.max(0, specSize - padding);</span><br><span class="line"></span><br><span class="line">        int resultSize = 0;</span><br><span class="line">        int resultMode = 0;</span><br><span class="line"></span><br><span class="line">        switch (specMode) &#123;</span><br><span class="line">        // Parent has imposed an exact size on us</span><br><span class="line">        case MeasureSpec.EXACTLY:</span><br><span class="line">            if (childDimension &gt;= 0) &#123;</span><br><span class="line">                resultSize = childDimension;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                // Child wants to be our size. So be it.</span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                // Child wants to determine its own size. It can&apos;t be</span><br><span class="line">                // bigger than us.</span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        // Parent has imposed a maximum size on us</span><br><span class="line">        case MeasureSpec.AT_MOST:</span><br><span class="line">            if (childDimension &gt;= 0) &#123;</span><br><span class="line">                // Child wants a specific size... so be it</span><br><span class="line">                resultSize = childDimension;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                // Child wants to be our size, but our size is not fixed.</span><br><span class="line">                // Constrain child to not be bigger than us.</span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                // Child wants to determine its own size. It can&apos;t be</span><br><span class="line">                // bigger than us.</span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        // Parent asked to see how big we want to be</span><br><span class="line">        case MeasureSpec.UNSPECIFIED:</span><br><span class="line">            if (childDimension &gt;= 0) &#123;</span><br><span class="line">                // Child wants a specific size... let him have it</span><br><span class="line">                resultSize = childDimension;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                // Child wants to be our size... find out how big it should</span><br><span class="line">                // be</span><br><span class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;</span><br><span class="line">                resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                // Child wants to determine its own size.... find out how</span><br><span class="line">                // big it should be</span><br><span class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;</span><br><span class="line">                resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        //noinspection ResourceType</span><br><span class="line">        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/23/自定义View之measure源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="作茧自缚">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/23/自定义View之measure源码分析/" itemprop="url">自定义View之measure源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-23T20:30:15+08:00">
                2018-02-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/自定义View/" itemprop="url" rel="index">
                    <span itemprop="name">自定义View</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/23/自定义View之measure源码分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/02/23/自定义View之measure源码分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="measure方法概述"><a href="#measure方法概述" class="headerlink" title="measure方法概述"></a>measure方法概述</h2><ol>
<li>若该view与其父view对于是否使用视觉布局边界的策略不一致，那么将对widthMeasureSpec和heightMeasureSpec进行偏移量校正。</li>
<li>通过widthMeasureSpec和heightMeasureSpec计算出存储在mMeasureCache对象中量算值所需要的key。</li>
<li>判断缓存对象mMeasureCache是否存在，若不存在则创建缓存对象。</li>
<li>判断是否强制测量、与旧值是否相同、是否给定了精确大小、之前测量的到底。宽高与穿进来的宽高是否相同、是否需要重新布局。</li>
<li>在需要强制测量或者需要重新布局情况下，如果缓存中没有值或忽略缓存结果情况下传入值            <code>onMeasure(widthMeasureSpec, heightMeasureSpec)</code>进行测量，测量结束后 重置View的状态mPrivateFlags将其标记为在layout之前不必再进行量算的状态。如果缓存中有值或不忽略缓存结果情况下，获取缓存中的值并 调用<code>setMeasuredDimensionRaw</code>方法将当前量算的结果到成员变量中。</li>
<li>如果自定义的View重写了onMeasure方法，但是没 有调用setMeasuredDimension()方法,那么就会抛出异常。</li>
<li>在量算完成后将这次新传入的MeasureSpec赋值给它们。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * This is called to find out how big a view should be. The parent</span><br><span class="line"> * supplies constraint information in the width and height parameters.</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * The actual measurement work of a view is performed in</span><br><span class="line"> * &#123;@link #onMeasure(int, int)&#125;, called by this method. Therefore, only</span><br><span class="line"> * &#123;@link #onMeasure(int, int)&#125; can and must be overridden by subclasses.</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * @param widthMeasureSpec Horizontal space requirements as imposed by the</span><br><span class="line"> *        parent</span><br><span class="line"> * @param heightMeasureSpec Vertical space requirements as imposed by the</span><br><span class="line"> *        parent</span><br><span class="line"> *</span><br><span class="line"> * @see #onMeasure(int, int)</span><br><span class="line"> */</span><br><span class="line">public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">	// 判断是否使用视觉布局边界</span><br><span class="line">    boolean optical = isLayoutModeOptical(this);</span><br><span class="line">    // 如果该view与其父view对于是否使用视觉布局边界的策略不一致</span><br><span class="line">    if (optical != isLayoutModeOptical(mParent)) &#123;</span><br><span class="line">    	// Insets实例包含四个整数偏移量，这些偏移量描述了对矩形四个边的更改。</span><br><span class="line">    	/*</span><br><span class="line">         * getOpticalInsets()获取偏移量insets，如果该View存在background则调用该background的</span><br><span class="line">         * getOpticalInsets()方法获取偏移量，若不存在background则偏移量为Insets.None即为0.</span><br><span class="line">         */</span><br><span class="line">        Insets insets = getOpticalInsets();</span><br><span class="line">        int oWidth  = insets.left + insets.right;</span><br><span class="line">        int oHeight = insets.top  + insets.bottom;</span><br><span class="line">		// 该View使用视觉布局边界的话widthMeasureSpec、heightMeasureSpec中的宽和高数值size需减去偏移量</span><br><span class="line">        widthMeasureSpec  = MeasureSpec.adjust(widthMeasureSpec,  optical ? -oWidth  : oWidth);</span><br><span class="line">        heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Suppress sign extension for the low bytes</span><br><span class="line">    // 计算key值</span><br><span class="line">    long key = (long) widthMeasureSpec &lt;&lt; 32 | (long) heightMeasureSpec &amp; 0xffffffffL;</span><br><span class="line"></span><br><span class="line">    // mMeasureCache中缓存着View在不同widthMeasureSpec、heightMeasureSpec下量算过的结果</span><br><span class="line">    if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2);</span><br><span class="line">	</span><br><span class="line">	// 是否强制测量</span><br><span class="line">    final boolean forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;</span><br><span class="line"></span><br><span class="line">    // Optimize layout by avoiding an extra EXACTLY pass when the view is</span><br><span class="line">    // already measured as the correct size. In API 23 and below, this</span><br><span class="line">    // extra pass is required to make LinearLayout re-distribute weight.</span><br><span class="line">    </span><br><span class="line">    // 判断是否与旧值是否相同</span><br><span class="line">    final boolean specChanged = widthMeasureSpec != mOldWidthMeasureSpec</span><br><span class="line">            || heightMeasureSpec != mOldHeightMeasureSpec;</span><br><span class="line">            </span><br><span class="line">    // 判断是否给定了精确的大小</span><br><span class="line">    final boolean isSpecExactly = MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY</span><br><span class="line">            &amp;&amp; MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY;</span><br><span class="line">    </span><br><span class="line">    // 判断之前设置的measuredWidth、measuredHeight与现在传过来的数值是否相同</span><br><span class="line">    final boolean matchesSpecSize = getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec)</span><br><span class="line">            &amp;&amp; getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">            </span><br><span class="line">    // 若是需要重新测量、未给定精确度大小、measuredWidth、measuredHeight与现在数值不同则需要重新布局</span><br><span class="line">    final boolean needsLayout = specChanged</span><br><span class="line">            &amp;&amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize);</span><br><span class="line"></span><br><span class="line">	// 如果需要强制测量或者需要重新布局</span><br><span class="line">    if (forceLayout || needsLayout) &#123;</span><br><span class="line">        // first clears the measured dimension flag</span><br><span class="line">        // 通过按位操作，重置View的状态mPrivateFlags，将其标记为未量算状态</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line">        </span><br><span class="line">        // 对阿拉伯语、希伯来语等从右到左书写、布局的语言进行特殊处理</span><br><span class="line">        resolveRtlPropertiesIfNeeded();</span><br><span class="line"></span><br><span class="line">		/* 在View真正进行量算之前，View进一步确认能否从已有的缓存mMeasureCache中读取缓存过的量算结果 </span><br><span class="line">		 * 若是强制layout导致的量算，那么将cacheIndex设置为-1，即不从缓存中读取量算结果</span><br><span class="line">		 * 若不是强制layout导致的量算，那就用上面根据measureSpec计算出来的key值作为缓存索引cacheIndex。</span><br><span class="line">		 ＊／</span><br><span class="line">        int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key);</span><br><span class="line">        </span><br><span class="line">        // 是否能找到缓存过的量算结果或者是否忽略缓存结果</span><br><span class="line">        if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123;</span><br><span class="line">            // measure ourselves, this should set the measured dimension flag back</span><br><span class="line">            // 调用onMeasure方法，并把尺寸限制条件widthMeasureSpec和heightMeasureSpec传入进去</span><br><span class="line">            // onMeasure方法中将会进行实际的量算工作，并把量算的结果保存到成员变量中</span><br><span class="line">            onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">			// onMeasure执行完后通过位操作，</span><br><span class="line">			// 重置View的状态mPrivateFlags将其标记为在layout之前不必再进行量算的状态</span><br><span class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">			// 获取缓存中的值</span><br><span class="line">            long value = mMeasureCache.valueAt(cacheIndex);</span><br><span class="line">            // Casting a long to int drops the high 32 bits, no mask needed</span><br><span class="line">            // 调用setMeasuredDimensionRaw方法将当前量算的结果到成员变量中</span><br><span class="line">            setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value);</span><br><span class="line">            mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // flag not set, setMeasuredDimension() was not invoked, we raise</span><br><span class="line">        // an exception to warn the developer</span><br><span class="line">        /*</span><br><span class="line">         * 此处检查mPrivateFlags是否含有PFLAG_MEASURED_DIMENSION_SET状态即可判断setMeasuredDimension</span><br><span class="line">         * 是否被调用，因为setMeasuredDimension()方法中会将mPrivateFlags设置为</span><br><span class="line">         * PFLAG_MEASURED_DIMENSION_SET状态，即已量算状态，如果自定义的View重写了onMeasure方法，但是没</span><br><span class="line">         * 有调用setMeasuredDimension()方法,那么就会抛出异常</span><br><span class="line">         */</span><br><span class="line">        if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;View with id &quot; + getId() + &quot;: &quot;</span><br><span class="line">                    + getClass().getName() + &quot;#onMeasure() did not set the&quot;</span><br><span class="line">                    + &quot; measured dimension by calling&quot;</span><br><span class="line">                    + &quot; setMeasuredDimension()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // mOldWidthMeasureSpec和mOldHeightMeasureSpec保存着最近一次量算时的MeasureSpec，</span><br><span class="line">    // 在量算完成后将这次新传入的MeasureSpec赋值给它们</span><br><span class="line">    mOldWidthMeasureSpec = widthMeasureSpec;</span><br><span class="line">    mOldHeightMeasureSpec = heightMeasureSpec;</span><br><span class="line">    </span><br><span class="line">   // 缓存本次量算的结果，以key作为键，量算结果作为值缓存在变量mMeasureCache中</span><br><span class="line">    mMeasureCache.put(key, ((long) mMeasuredWidth) &lt;&lt; 32 |</span><br><span class="line">            (long) mMeasuredHeight &amp; 0xffffffffL); // suppress sign extension</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="onMesure方法概述"><a href="#onMesure方法概述" class="headerlink" title="onMesure方法概述"></a>onMesure方法概述</h2><p>###onMeasure方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected void onMeasure( int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    setMeasuredDimension( getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getDefaultSize获取默认宽高"><a href="#getDefaultSize获取默认宽高" class="headerlink" title="getDefaultSize获取默认宽高"></a>getDefaultSize获取默认宽高</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static int getDefaultSize (int size, int measureSpec) &#123;</span><br><span class="line">    int result = size;</span><br><span class="line">    int specMode = MeasureSpec. getMode(measureSpec);</span><br><span class="line">    int specSize = MeasureSpec. getSize(measureSpec);</span><br><span class="line">    switch (specMode) &#123;</span><br><span class="line">    case MeasureSpec. UNSPECIFIED:</span><br><span class="line">        result = size;</span><br><span class="line">        break;</span><br><span class="line">    case MeasureSpec. AT_MOST:</span><br><span class="line">    case MeasureSpec. EXACTLY:</span><br><span class="line">        result = specSize;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###为宽度获取建议最小值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected int getSuggestedMinimumWidth () &#123;</span><br><span class="line">    return (mBackground == null) ? mMinWidth : max(mMinWidth , mBackground.getMinimumWidth());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getMinimumWidth()&#123;</span><br><span class="line">    final int intrinsicWhidth = getIntrinsicWidtth();</span><br><span class="line">    retrun intrinsicWhidth &gt; 0 ? intrinsicWhidth : 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/10/自定义View之布局/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="作茧自缚">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/10/自定义View之布局/" itemprop="url">自定义View之布局</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-10T23:49:45+08:00">
                2018-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/自定义View/" itemprop="url" rel="index">
                    <span itemprop="name">自定义View</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/10/自定义View之布局/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/02/10/自定义View之布局/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="布局过程"><a href="#布局过程" class="headerlink" title="布局过程"></a>布局过程</h2><blockquote>
<p>布局过程，就是程序在运行时利用布局文件的代码来计算出实际尺寸的过程。</p>
</blockquote>
<h3 id="测量阶段measure"><a href="#测量阶段measure" class="headerlink" title="测量阶段measure()"></a>测量阶段<code>measure()</code></h3><h4 id="测量的过程"><a href="#测量的过程" class="headerlink" title="测量的过程"></a>测量的过程</h4><ul>
<li>从上到下递归地调用每个 View 或者 ViewGroup 的 measure() 方法，测量他们的尺寸并计算它们的位置；</li>
<li><code>measure()</code> 方法被父 View 调用，在 <code>measure()</code> 中做一些准备和优化工作后，调用 <code>onMeasure()</code> 来进行实际的自我测量。 <code>onMeasure()</code> 在<code>View</code> 和 <code>ViewGroup</code>所进行的操作并不相同：<ul>
<li><strong>View</strong>：<code>View</code> 在 <code>onMeasure()</code> 中会计算出自己的尺寸然后保存；</li>
<li><strong>ViewGroup</strong>：<code>ViewGroup</code> 在 <code>onMeasure()</code> 中会调用所有子 View 的 <code>measure()</code> 让它们进行自我测量，并根据子 View 计算出的期望尺寸来计算出它们的实际尺寸和位置然后保存。同时，它也会根据子 View 的尺寸和位置来计算出自己的尺寸然后保存；</li>
</ul>
</li>
</ul>
<h3 id="布局阶段layout"><a href="#布局阶段layout" class="headerlink" title="布局阶段layout()"></a>布局阶段<code>layout()</code></h3><ul>
<li>从上到下递归地调用每个 View 或者 ViewGroup 的 layout() 方法，把测得的它们的尺寸和位置赋值给它们。</li>
<li><code>layout()</code> 方法被父 View 调用，在 <code>layout()</code> 中它会保存父 View 传进来的自己的位置和尺寸，并且调用 <code>onLayout()</code> 来进行实际的内部布局。<code>onLayout()</code> 在 <code>View</code> 和 <code>ViewGroup</code>所进行的操作并不相同：<ul>
<li><strong>View</strong>：由于没有子 View，所以 <code>View</code> 的 <code>onLayout()</code> 什么也不做。</li>
<li><strong>ViewGroup</strong>：<code>ViewGroup</code> 在 <code>onLayout()</code> 中会调用自己的所有子 View 的 <code>layout()</code> 方法，把它们的尺寸和位置传给它们，让它们完成自我的内部布局。</li>
</ul>
</li>
</ul>
<h2 id="自定义布局的方式"><a href="#自定义布局的方式" class="headerlink" title="自定义布局的方式"></a>自定义布局的方式</h2><h3 id="重写-onMeasure-来修改已有的-View-的尺寸"><a href="#重写-onMeasure-来修改已有的-View-的尺寸" class="headerlink" title="重写 onMeasure() 来修改已有的 View 的尺寸"></a>重写 <code>onMeasure()</code> 来修改已有的 <code>View</code> 的尺寸</h3><ol>
<li>重写 <code>onMeasure()</code> 方法，并在里面调用 <code>super.onMeasure()</code>，触发原有的自我测量；</li>
<li>在 <code>super.onMeasure()</code> 的下面用 <code>getMeasuredWidth()</code> 和 <code>getMeasuredHeight()</code> 来获取到之前的测量结果，并使用自己的算法，根据测量结果计算出新的结果；</li>
<li>调用 <code>setMeasuredDimension()</code> 来保存新的结果。</li>
</ol>
<h3 id="重写-onMeasure-来全新定制自定义-View-的尺寸"><a href="#重写-onMeasure-来全新定制自定义-View-的尺寸" class="headerlink" title="重写 onMeasure() 来全新定制自定义 View 的尺寸"></a>重写 <code>onMeasure()</code> 来全新定制自定义 <code>View</code> 的尺寸</h3><h4 id="父-View-的尺寸限制"><a href="#父-View-的尺寸限制" class="headerlink" title="父 View 的尺寸限制"></a>父 View 的尺寸限制</h4><ol>
<li>由来：开发者的要求（布局文件中 <code>layout_</code> 打头的属性）经过父 View 处理计算后的更精确的要求；</li>
<li>限制的分类：<ol>
<li><code>UNSPECIFIED</code>：不限制</li>
<li><code>AT_MOST</code>：限制上限</li>
<li><code>EXACTLY</code>：限制固定值</li>
</ol>
</li>
</ol>
<h4 id="自定义方式"><a href="#自定义方式" class="headerlink" title="自定义方式"></a>自定义方式</h4><ol>
<li>重新 <code>onMeasure()</code>，并计算出 View 的尺寸；</li>
<li>使用 <code>resolveSize()</code> 来让子 View 的计算结果符合父 View 的限制（如果想用自己的方式来满足父 View 的限制也行）。</li>
</ol>
<h3 id="重写-onMeasure-和-onLayout-来全新定制自定义-ViewGroup-的内部布局"><a href="#重写-onMeasure-和-onLayout-来全新定制自定义-ViewGroup-的内部布局" class="headerlink" title="重写 onMeasure() 和 onLayout() 来全新定制自定义 ViewGroup 的内部布局"></a>重写 <code>onMeasure()</code> 和 <code>onLayout()</code> 来全新定制自定义 <code>ViewGroup</code> 的内部布局</h3><h4 id="定制-Layout-内部布局的方式"><a href="#定制-Layout-内部布局的方式" class="headerlink" title="定制 Layout 内部布局的方式"></a>定制 Layout 内部布局的方式</h4><ol>
<li>重写 <code>onMeasure()</code> 来计算内部布局</li>
<li>重写 <code>onLayout()</code> 来摆放子 View</li>
</ol>
<h4 id="重写-onMeasure-的三个步骤"><a href="#重写-onMeasure-的三个步骤" class="headerlink" title="重写 onMeasure() 的三个步骤"></a>重写 onMeasure() 的三个步骤</h4><ol>
<li>调用每个子 View 的 <code>measure()</code> 来计算子 View 的尺寸</li>
<li>计算子 View 的位置并保存子 View 的位置和尺寸</li>
<li>计算自己的尺寸并用 <code>setMeasuredDimension()</code> 保存</li>
</ol>
<h4 id="计算子-View-尺寸的关键"><a href="#计算子-View-尺寸的关键" class="headerlink" title="计算子 View 尺寸的关键"></a>计算子 View 尺寸的关键</h4><p>计算子 View 的尺寸，关键在于 <code>measure()</code> 方法的两个参数——也就是子 View 的两个 <code>MeasureSpec</code> 的计算。</p>
<h4 id="子-View-的-MeasureSpec-的计算方式："><a href="#子-View-的-MeasureSpec-的计算方式：" class="headerlink" title="子 View 的 MeasureSpec 的计算方式："></a>子 View 的 MeasureSpec 的计算方式：</h4><ul>
<li>结合开发者的要求（xml 中 <code>layout_</code> 打头的属性）和自己的可用空间（自己的尺寸上限 - 已用尺寸）</li>
<li>尺寸上限根据自己的  <code>MeasureSpec</code> 中的 mode 而定</li>
</ul>
<ul>
<li>EXACTLY / AT_MOST：尺寸上限为 <code>MeasureSpec</code> 中的 <code>size</code></li>
<li>UNSPECIFIED：尺寸无上限</li>
</ul>
<h4 id="重写-onLayout-的方式"><a href="#重写-onLayout-的方式" class="headerlink" title="重写 onLayout() 的方式"></a>重写 onLayout() 的方式</h4><p>在 <code>onLayout()</code> 里调用每个子 View 的 <code>layout()</code> ，让它们保存自己的位置和尺寸。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/09/自定义View之硬件加速/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="作茧自缚">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/09/自定义View之硬件加速/" itemprop="url">自定义View之硬件加速</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-09T19:55:32+08:00">
                2018-02-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/自定义View/" itemprop="url" rel="index">
                    <span itemprop="name">自定义View</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/09/自定义View之硬件加速/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/02/09/自定义View之硬件加速/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="本质和原理"><a href="#本质和原理" class="headerlink" title="本质和原理"></a>本质和原理</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>所谓硬件加速，指的是把某些计算工作交给专门的硬件来做，而不是和普通的计算工作一样交给 CPU 来处理。这样不仅减轻了 CPU 的压力，而且由于有了「专人」的处理，这份计算工作的速度也被加快了。这就是「硬件加速」。</li>
<li>对于 Android 来说，硬件加速有它专属的意思：在 Android 里，硬件加速专指把 View 中绘制的计算工作交给 GPU 来处理。进一步地再明确一下，这个「绘制的计算工作」指的就是把绘制方法中的那些 <code>Canvas.drawXXX()</code> 变成实际的像素这件事。</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li><p>未开启硬件加速：<code>Canvas</code> 绘制的工作方式是：把要绘制的内容写进一个 <code>Bitmap</code>，然后在之后的渲染过程中，这个 <code>Bitmap</code> 的像素内容被直接用于渲染到屏幕。这种绘制方式的主要计算工作在于把绘制操作转换为像素的过程（例如由一句 <code>Canvas.drawCircle()</code> 来获得一个具体的圆的像素信息），这个过程的计算是由 CPU 来完成的，过程如下图：</p>
<p><img src="http://ouv36g1sw.bkt.clouddn.com/%E6%9C%AA%E5%BC%80%E5%90%AF%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%E7%BB%98%E5%88%B6%E8%BF%87%E7%A8%8B" alt="未开启硬件加速的绘制过程"></p>
</li>
<li><p>开启硬件加速：只是把绘制的内容转换为 GPU 的操作保存了下来，然后就把它交给 GPU，最终由 GPU 来完成实际的显示工作。过程如下图：</p>
<p><img src="http://ouv36g1sw.bkt.clouddn.com/%E5%BC%80%E5%90%AF%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%E7%BB%98%E5%88%B6%E8%BF%87%E7%A8%8B" alt="开启硬件加速绘制过程"></p>
</li>
</ul>
<h2 id="Android中的应用"><a href="#Android中的应用" class="headerlink" title="Android中的应用"></a>Android中的应用</h2><ul>
<li>硬件加速开启后，绘制的计算工作由 CPU 转交给了 GPU。那么硬件加速能够让绘制变快，主要有三个原因：<ol>
<li>本来由 CPU 自己来做的事，分摊给了 GPU 一部分，自然可以提高效率；</li>
<li>相对于 CPU 来说，GPU 自身的设计本来就对于很多常见类型内容的计算（例如简单的圆形、简单的方形）具有优势；</li>
<li>由于绘制流程的不同，硬件加速在界面内容发生重绘的时候绘制流程可以得到优化，避免了一些重复操作，从而大幅提升绘制效率。</li>
</ol>
</li>
<li>硬件加速绘制变快的机制：<ul>
<li>在硬件加速关闭时，绘制内容会被 CPU 转换成实际的像素，然后直接渲染到屏幕。具体来说，这个「实际的像素」，它是由 <code>Bitmap</code> 来承载的。在界面中的某个 View 由于内容发生改变而调用 <code>invalidate()</code> 方法时，如果没有开启硬件加速，那么为了正确计算 <code>Bitmap</code> 的像素，这个 <code>View</code> 的父 View、父 View 的父 View 乃至一直向上直到最顶级 View，以及所有和它相交的兄弟 <code>View</code>，都需要被调用 <code>invalidate()</code>来重绘。一个 View 的改变使得大半个界面甚至整个界面都重绘一遍，这个工作量是非常大的。</li>
<li>而在硬件加速开启时，绘制的内容会被转换成 GPU 的操作保存下来（承载的形式称为 display list，对应的类也叫做 <code>DisplayList</code>），再转交给 GPU。由于所有的绘制内容都没有变成最终的像素，所以它们之间是相互独立的，那么在界面内容发生改变的时候，只要把发生了改变的 View 调用 <code>invalidate()</code>方法以更新它所对应的 GPU 操作就好，至于它的父 View 和兄弟 View，只需要保持原样。那么这个工作量就很小了。</li>
</ul>
</li>
</ul>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul>
<li><p>受到 GPU 绘制方式的限制，<code>Canvas</code> 的有些方法在硬件加速开启式会失效或无法正常工作。比如，在硬件加速开启时， <code>clipPath()</code> 在 API 18 及以上的系统中才有效。具体的 API 限制和 API 版本的关系如下图：</p>
<p><img src="http://ouv36g1sw.bkt.clouddn.com/Fmyy4PcPsSp0P6cpSXFErBvy8GPn.jpg" alt="硬件加速的限制"></p>
</li>
</ul>
<h2 id="View-Layer"><a href="#View-Layer" class="headerlink" title="View Layer"></a>View Layer</h2><blockquote>
<p>关闭硬件加速：<code>view.setLayerType(LAYER_TYPE_SOFTWARE, null);</code></p>
</blockquote>
<ul>
<li><p><code>setLayerType()</code> 方法本来作用并不是用来开关硬件加速的，只是当它的参数为 <code>LAYER_TYPE_SOFTWARE</code> 的时候，可以「顺便」把硬件加速关掉而已；并且除了这个方法之外，Android 并没有提供专门的 View 级别的硬件加速开关，所以它就「顺便」成了一个开关硬件加速的方法。</p>
</li>
<li><p><strong>View Layer</strong>，又称为离屏缓冲（Off-screen Buffer），它的作用是单独启用一块地方来绘制这个 View ，而不是使用软件绘制的 Bitmap 或者通过硬件加速的 GPU。这块「地方」可能是一块单独的 <code>Bitmap</code>，也可能是一块 OpenGL 的纹理（texture，OpenGL 的纹理可以简单理解为图像的意思），具体取决于硬件加速是否开启。采用什么来绘制 View 不是关键，关键在于当设置了 View Layer 的时候，它的绘制会被缓存下来，而且缓存的是最终的绘制结果，而不是像硬件加速那样只是把 GPU 的操作保存下来再交给 GPU 去计算。通过这样更进一步的缓存方式，View 的重绘效率进一步提高了：只要绘制的内容没有变，那么不论是 CPU 绘制还是 GPU 绘制，它们都不用重新计算，而只要只用之前缓存的绘制结果就可以了。基于这样的原理，在进行移动、旋转等（无需调用 <code>invalidate()</code>）的属性动画的时候开启 Hardware Layer 将会极大地提升动画的效率，因为在动画过程中 View 本身并没有发生改变，只是它的位置或角度改变了，而这种改变是可以由 GPU 通过简单计算就完成的，并不需要重绘整个 View。所以在这种动画的过程中开启 Hardware Layer，可以让本来就依靠硬件加速而变流畅了的动画变得更加流畅。实现方式大概是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">view.setLayerType(LAYER_TYPE_HARDWARE, null);  </span><br><span class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(view, &quot;rotationY&quot;, 180);</span><br><span class="line"></span><br><span class="line">animator.addListener(new AnimatorListenerAdapter() &#123;  </span><br><span class="line">    @Override</span><br><span class="line">    public void onAnimationEnd(Animator animation) &#123;</span><br><span class="line">        view.setLayerType(LAYER_TYPE_NONE, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">animator.start();  </span><br><span class="line">// 或者如果是使用 ViewPropertyAnimator，那么更简单：</span><br><span class="line">view.animate()  </span><br><span class="line">        .rotationY(90)</span><br><span class="line">        .withLayer(); // withLayer() 可以自动完成上面这段代码的复杂操作</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意：</strong></p>
<ul>
<li><p>这种方式不适用于基于自定义属性绘制的动画</p>
</li>
<li><p>除了用于关闭硬件加速和辅助属性动画这两项功能外，Layer 还可以用于给 View 增加一些绘制效果，例如设置一个 <code>ColorMatrixColorFilter</code> 来让 View 变成黑白的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ColorMatrix colorMatrix = new ColorMatrix();  </span><br><span class="line">colorMatrix.setSaturation(0);</span><br><span class="line"></span><br><span class="line">Paint paint = new Paint();  </span><br><span class="line">paint.setColorFilter(new ColorMatrixColorFilter(colorMatrix));</span><br><span class="line"></span><br><span class="line">view.setLayerType(LAYER_TYPE_HARDWARE, paint);</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于设置了 View Layer 后，View 在初次绘制时以及每次 <code>invalidate()</code> 后重绘时，需要进行两次的绘制工作（一次绘制到 Layer，一次从 Layer 绘制到显示屏），所以其实它的每次绘制的效率是被降低了的。所以一定要慎重使用 View Layer，在需要用到它的时候再去使用。</p>
</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>硬件加速指的是使用 GPU 来完成绘制的计算工作，代替 CPU。它从工作分摊和绘制机制优化这两个角度提升了绘制的速度。</p>
<p>硬件加速可以使用 <code>setLayerType()</code> 来关闭硬件加速，但这个方法其实是用来设置 View Layer 的：</p>
<ol>
<li>参数为 <code>LAYER_TYPE_SOFTWARE</code> 时，使用软件来绘制 View Layer，绘制到一个 Bitmap，并顺便关闭硬件加速；</li>
<li>参数为 <code>LAYER_TYPE_HARDWARE</code> 时，使用 GPU 来绘制 View Layer，绘制到一个 OpenGL texture（如果硬件加速关闭，那么行为和 <code>VIEW_TYPE_SOFTWARE</code> 一致）；</li>
<li>参数为 <code>LAYER_TYPE_NONE</code> 时，关闭 View Layer。</li>
</ol>
<p>View Layer 可以加速无 <code>invalidate()</code> 时的刷新效率，但对于需要调用 <code>invalidate()</code> 的刷新无法加速。</p>
<p>View Layer 绘制所消耗的实际时间是比不使用 View Layer 时要高的，所以要慎重使用。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/07/自定View之属性动画/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="作茧自缚">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/07/自定View之属性动画/" itemprop="url">自定View之属性动画</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-07T21:55:19+08:00">
                2018-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/自定义View/" itemprop="url" rel="index">
                    <span itemprop="name">自定义View</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/07/自定View之属性动画/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/02/07/自定View之属性动画/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ViewPropertyAnimator"><a href="#ViewPropertyAnimator" class="headerlink" title="ViewPropertyAnimator"></a>ViewPropertyAnimator</h2><blockquote>
<p><code>View</code> 的每个方法都对应了 <code>ViewPropertyAnimator</code> 的两个方法，其中一个是带有 <code>-By</code> 后缀的，例如，<code>View.setTranslationX()</code> 对应了 <code>ViewPropertyAnimator.translationX()</code> 和 <code>ViewPropertyAnimator.translationXBy()</code> 这两个方法。其中带有 <code>-By()</code> 后缀的是增量版本的方法，例如，<code>translationX(100)</code> 表示用动画把 <code>View</code> 的 <code>translationX</code> 值渐变为 <code>100</code>，而 <code>translationXBy(100)</code> 则表示用动画把 <code>View</code> 的 <code>translationX</code> 值渐变地增加 <code>100</code></p>
</blockquote>
<h3 id="ViewPropertyAnimator介绍"><a href="#ViewPropertyAnimator介绍" class="headerlink" title="ViewPropertyAnimator介绍"></a>ViewPropertyAnimator介绍</h3><ul>
<li>专门针对View对象动画而操作的类。</li>
<li>支持链式操作，提供了更简洁调用设置多个属性动画方式，这些动画可以同时进行的。</li>
<li>拥有更好的性能，多个属性动画是一次同时变化，只执行一次UI刷新（也就是只调用一次invalidate,而n个ObjectAnimator就会进行n次属性变化，就有n次invalidate）。</li>
<li>每个属性提供两种类型方法设置。</li>
<li>该类只能通过View的animate()获取其实例对象的引用</li>
</ul>
<h3 id="ViewPropertyAnimator使用方式"><a href="#ViewPropertyAnimator使用方式" class="headerlink" title="ViewPropertyAnimator使用方式"></a>ViewPropertyAnimator使用方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">view.animate()  </span><br><span class="line">        .scaleX(1)</span><br><span class="line">        .scaleY(1)</span><br><span class="line">        .alpha(1);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>View.animate()</code>之后配合下图种的<code>translationX()</code>、<code>translationY()</code>、<code>rotation()</code>、<code>alpha()</code>等方法。</li>
</ul>
<p><img src="http://ouv36g1sw.bkt.clouddn.com/ViewPropertyAnimator%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95" alt="ViewPropertyAnimator中的方法"></p>
<h2 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h2><h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><ul>
<li><p>如果是自定义控件，需要添加 <code>setter</code> / <code>getter</code> 方法，<code>setter</code>方法中需要在修改属性的值之后主动的通知界面重绘，也就是使用<code>invalidate()</code>方法，它会把之前绘制的内容标记位失效，在下一帧到来时View不会延用上一帧的内容，而是会自动调用<code>draw()</code>方法来重新绘制内容，这样才会刷新内容；</p>
</li>
<li><p>用 <code>ObjectAnimator.ofXXX(目标对象,属性名,目标值 )</code> 创建 <code>ObjectAnimator</code> 对象，它会根据填写的属性名拼接成相应的setxx方法；</p>
</li>
<li><p>用 <code>start()</code> 方法执行动画。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class ProgressView extends View &#123;</span><br></pre></td></tr></table></figure>
<pre><code>float progress = 0;
Paint paint = new Paint();
RectF acres = new RectF();
public void setProgress(float progress){
    this.progress = progress;
    invalidate();
}
public float getProgress() {
    return progress;
}
</code></pre></li>
</ul>
<pre><code>public ProgressView(Context context) {
    super(context);
}

@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    paint.setColor(Color.parseColor(&quot;#FFFFFFF&quot;));
    canvas.drawArc(acres, 135, progress * 2.7f, false, paint);
}

/**
 * ObjectAnimator mObjectAnimator = ObjectAnimator.ofFloat(this,&quot;progress&quot;,0,65);
 * mObjectAnimator.start();
 */
</code></pre><p>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 通用功能：</span><br><span class="line"></span><br><span class="line">- setDuration(int duration) 设置动画时长</span><br><span class="line">- setInterpolator(Interpolator interpolator) 设置 Interpolator（设置插值器）</span><br><span class="line"></span><br><span class="line">### 插值器Interpolator：</span><br><span class="line"></span><br><span class="line">&gt; 根据时动画的时间完成度计算所对应的动画完成程度，可以说是一个速度设置器</span><br><span class="line"></span><br><span class="line">- **匀速**：LinearInterpolator；</span><br><span class="line"></span><br><span class="line">- **持续加速**：AccelerateInterpolator，主要用在离场效果中，比如某个物体从界面中飞离，就可以用这种效果。它给人的感觉就会是「从零起步，加速飞走了」。到了最后动画骤停的时候，物体已经飞出用户视野，看不到了，所以并不会察觉到这个骤停的；</span><br><span class="line"></span><br><span class="line">- **持续减速直到 0**：DecelerateInterpolator，主要用于入场效果，比如某个物体从界面的外部飞入界面后停在某处；</span><br><span class="line"></span><br><span class="line">- **蓄力**：AnticipateInterpolator先回拉一下再进行正常动画轨迹。效果看起来有点像投掷物体或跳跃等动作前的蓄力。平移动画，那么就是位置上的回拉；如果是放大动画，那么就是先缩小一下再放大；其他类型的动画同理；</span><br><span class="line"></span><br><span class="line">- **回弹**：OvershootInterpolator，动画会超过目标值一些，然后再弹回来；</span><br><span class="line"></span><br><span class="line">- **蓄力+回弹**：AnticipateOvershootInterpolator；</span><br><span class="line"></span><br><span class="line">- **正/余弦曲线**：CycleInterpolator可以自定义曲线的周期，所以动画可以不到终点就结束，也可以到达终点后回弹，回弹的次数由曲线的周期决定，曲线的周期由 `CycleInterpolator()` 构造方法的参数决定；</span><br><span class="line"></span><br><span class="line">- **自定义动画完成度 / 时间完成度曲线**：PathInterpolator，定制的方式是使用一个 `Path` 对象来绘制出你要的动画完成度 / 时间完成度曲线；</span><br><span class="line"></span><br><span class="line">- **贝塞尔加速**：FastOutLinearInInterpolator，和`AccelerateInterpolator` 一样，都是一个持续加速的运动路线。只不过 `FastOutLinearInInterpolator` 的曲线公式是用的贝塞尔曲线，而 `AccelerateInterpolator` 用的是指数曲线。具体来说，它俩最主要的区别是 `FastOutLinearInInterpolator` 的初始阶段加速度比 `AccelerateInterpolator` 要快一些；</span><br><span class="line"></span><br><span class="line">  ![加速的AccelerateInterpolator与FastOutLinearInInterpolator的速度模型图](http://ouv36g1sw.bkt.clouddn.com/%E5%8A%A0%E9%80%9F%E7%9A%84AccelerateInterpolator%E4%B8%8EFastOutLinearInInterpolator%E7%9A%84%E9%80%9F%E5%BA%A6%E6%A8%A1%E5%9E%8B%E5%9B%BE)</span><br><span class="line"></span><br><span class="line">- **贝塞尔先加速再减速**：FastOutSlowInInterpolator，同样也是先加速再减速的还有前面说过的 `AccelerateDecelerateInterpolator`，不过它们的效果是明显不一样的。`FastOutSlowInInterpolator` 用的是贝塞尔曲线，`AccelerateDecelerateInterpolator` 用的是正弦 / 余弦曲线。具体来讲， `FastOutSlowInInterpolator` 的前期加速度要**快得多**。</span><br><span class="line"></span><br><span class="line">  ![先加速在减速的AccelerateDecelerateInterpolator与FastOutSlowInInterpolator速度模型图](http://ouv36g1sw.bkt.clouddn.com/%E5%85%88%E5%8A%A0%E9%80%9F%E5%9C%A8%E5%87%8F%E9%80%9F%E7%9A%84AccelerateDecelerateInterpolator%E4%B8%8EFastOutSlowInInterpolator%E9%80%9F%E5%BA%A6%E6%A8%A1%E5%9E%8B%E5%9B%BE)</span><br><span class="line"></span><br><span class="line">- **贝塞尔持续减速**：LinearOutSlowInInterpolator，和 `DecelerateInterpolator` 比起来，同为减速曲线，主要区别在于 `LinearOutSlowInInterpolator` 的初始速度更高。对于人眼的实际感觉，区别其实也不大，不过还是能看出来一些的。</span><br><span class="line"></span><br><span class="line">  ![持续减速的DecelerateInterpolator与LinearOutSlowInInterpolator的速度模型图](http://ouv36g1sw.bkt.clouddn.com/%E6%8C%81%E7%BB%AD%E5%87%8F%E9%80%9F%E7%9A%84DecelerateInterpolator%E4%B8%8ELinearOutSlowInInterpolator%E7%9A%84%E9%80%9F%E5%BA%A6%E6%A8%A1%E5%9E%8B%E5%9B%BE)</span><br><span class="line"></span><br><span class="line">### 设置监听器</span><br><span class="line"></span><br><span class="line">&gt; 给动画设置监听器，可以在关键时刻得到反馈，从而做出适合的操作</span><br><span class="line"></span><br><span class="line">- ViewPropertyAnimator.setListener() / ObjectAnimator.addListener()</span><br><span class="line"></span><br><span class="line">  - 动画开始时回掉：` onAnimationStart(Animator animation)`</span><br><span class="line">  - 动画结束时回掉：` onAnimationEnd(Animator animation)`</span><br><span class="line">  - 动画取消时回掉：` onAnimationCancel(Animator animation)`</span><br><span class="line">  - 动画重复执行是回掉：`onAnimationRepeat(Animator animation)`当动画通过 `setRepeatMode()` / `setRepeatCount()` 或 `repeat()` 方法重复执行时，这个方法被调用。由于 `ViewPropertyAnimator` 不支持重复，所以这个方法对 `ViewPropertyAnimator` 相当于无效。</span><br><span class="line"></span><br><span class="line">- ViewPropertyAnimator.setUpdateListener() / ObjectAnimator.addUpdateListener()</span><br><span class="line"></span><br><span class="line">  - 和 上面的两个方法一样，这两个方法虽然名称和可设置的监听器数量不一样，但本质其实都一样的，它们的参数都是 `AnimatorUpdateListener`。但是它只有一个回调方法：`onAnimationUpdate(ValueAnimator animation)`</span><br><span class="line">  - 当动画的属性更新时回掉：`onAnimationUpdate(ValueAnimator animation)`，方法的参数是一个 `ValueAnimator`，`ValueAnimator` 是 `ObjectAnimator` 的父类，也是 `ViewPropertyAnimator` 的内部实现，所以这个参数其实就是 `ViewPropertyAnimator` 内部的那个 `ValueAnimator`，或者对于 `ObjectAnimator` 来说就是它自己本身。</span><br><span class="line"></span><br><span class="line">- ObjectAnimator.addPauseListener()</span><br><span class="line"></span><br><span class="line">- ViewPropertyAnimator.withStartAction/EndAction()</span><br><span class="line"></span><br><span class="line">  这两个方法是 `ViewPropertyAnimator` 的独有方法。它们和 `set/addListener()` 中回调的 `onAnimationStart()` / `onAnimationEnd()` 相比起来的不同主要有两点：</span><br><span class="line"></span><br><span class="line">  - `withStartAction()` / `withEndAction()` 是一次性的，在动画执行结束后就自动弃掉了，就算之后再重用 `ViewPropertyAnimator` 来做别的动画，用它们设置的回调也不会再被调用。而 `set/addListener()` 所设置的 `AnimatorListener` 是持续有效的，当动画重复执行时，回调总会被调用。</span><br><span class="line">  - `withEndAction()` 设置的回调只有在动画正常结束时才会被调用，而在动画被取消时不会被执行。这点和 `AnimatorListener.onAnimationEnd()` 的行为是不一致的。</span><br><span class="line"></span><br><span class="line">### 估值器TypeEvaluator</span><br><span class="line"></span><br><span class="line">&gt; 对指定的某个类型的参数设定一个算法来计算动画完成度与参数的关系</span><br><span class="line">&gt;</span><br><span class="line">&gt; 估值器用来确定在动画过程中每时每刻动画的执行程度值，从动画完成度转变为实际属性值。</span><br></pre></td></tr></table></figure></p>
<p>public interface TypeEvaluator<t> {  </t></p>
<pre><code>/**  
 * @param fraction   The fraction from the starting to the ending values  
 *                      表示当前这段数值变化值得比例
 * @param startValue The start value.  表示当前这段数值变化的开始值
 * @param endValue   The end value.  表示当前这段数据变化的结束值
 * @return A linear interpolation between the start and end values, given the  
 *         &lt;code&gt;fraction&lt;/code&gt; parameter.  返回插值器
 */  
public T evaluate(float fraction, T startValue, T endValue);  
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 类型</span><br><span class="line"></span><br><span class="line">- ArgbEvaluator：可用于执行表示ARGB颜色的整数值之间的类型插值</span><br><span class="line">- FloatArrayEvaluator</span><br><span class="line">- FloatEvaluator</span><br><span class="line">- IntArrayEvaluator</span><br><span class="line">- IntEvaluator</span><br><span class="line">- PointFEvaluator</span><br><span class="line">- RectEvaluator</span><br><span class="line"></span><br><span class="line">#### 自定义 Evaluator</span><br></pre></td></tr></table></figure>
<p>// 自定义 HslEvaluator<br>private class HsvEvaluator implements TypeEvaluator<integer> {<br>   float[] startHsv = new float[3];<br>   float[] endHsv = new float[3];<br>   float[] outHsv = new float[3];</integer></p>
<p>   @Override<br>   public Integer evaluate(float fraction, Integer startValue, Integer endValue) {<br>       // 把 ARGB 转换成 HSV<br>       Color.colorToHSV(startValue, startHsv);<br>       Color.colorToHSV(endValue, endHsv);</p>
<pre><code>// 计算当前动画完成度（fraction）所对应的颜色值
if (endHsv[0] - startHsv[0] &gt; 180) {
    endHsv[0] -= 360;
} else if (endHsv[0] - startHsv[0] &lt; -180) {
    endHsv[0] += 360;
}
outHsv[0] = startHsv[0] + (endHsv[0] - startHsv[0]) * fraction;
if (outHsv[0] &gt; 360) {
    outHsv[0] -= 360;
} else if (outHsv[0] &lt; 0) {
    outHsv[0] += 360;
}
outHsv[1] = startHsv[1] + (endHsv[1] - startHsv[1]) * fraction;
outHsv[2] = startHsv[2] + (endHsv[2] - startHsv[2]) * fraction;

// 计算当前动画完成度（fraction）所对应的透明度
int alpha = startValue &gt;&gt; 24 + (int) ((endValue &gt;&gt; 24 - startValue &gt;&gt; 24) * fraction);

// 把 HSV 转换回 ARGB 返回
return Color.HSVToColor(alpha, outHsv);
</code></pre><p>   }<br>}</p>
<p>ObjectAnimator animator = ObjectAnimator.ofInt(view, “color”, 0xff00ff00);<br>// 使用自定义的 HslEvaluator<br>animator.setEvaluator(new HsvEvaluator());<br>animator.start();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### PropertyValuesHolder 同一个动画中改变多个属性</span><br><span class="line"></span><br><span class="line">- PropertyValuesHolder：它是一个属性值的批量存放地，如果有多个属性需要修改，可以把它们放在不同的 `PropertyValuesHolder` 中，然后使用 `ofPropertyValuesHolder()` 统一放进 `Animator`。这样你就不用为每个属性单独创建一个 `Animator` 分别执行了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 可能同一个动画中会需要改变多个属性，例如在改变透明度的同时改变尺寸。如果使用 `ViewPropertyAnimator`，可以直接用连写的方式来在一个动画中同时改变多个属性，但是对于ObjectAnimator无法这么使用，但是可以依靠 `PropertyValuesHolder` 来同时在一个动画中改变多个属性。这些属性如果放在同一个动画中，需要共享动画的开始时间、结束时间、Interpolator 等等一系列的设定。</span><br></pre></td></tr></table></figure></p>
<p>PropertyValuesHolder holder1 = PropertyValuesHolder.ofFloat(“scaleX”, 1);<br>PropertyValuesHolder holder2 = PropertyValuesHolder.ofFloat(“scaleY”, 1);<br>PropertyValuesHolder holder3 = PropertyValuesHolder.ofFloat(“alpha”, 1);</p>
<p>ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(view, holder1, holder2, holder3)<br>animator.start();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### AnimatorSet多个动画配合执行</span><br><span class="line"></span><br><span class="line">- 有时候需要在一个动画中改变多个属性，还会需要多个动画配合工作，比如，在内容的大小从 0 放大到 100% 大小后开始移动。</span><br></pre></td></tr></table></figure></p>
<p>ObjectAnimator animator1 = ObjectAnimator.ofFloat(…);<br>animator1.setInterpolator(new LinearInterpolator());<br>ObjectAnimator animator2 = ObjectAnimator.ofInt(…);<br>animator2.setInterpolator(new DecelerateInterpolator());<br>AnimatorSet animatorSet = new AnimatorSet();<br>// 两个动画依次执行<br>animatorSet.playSequentially(animator1, animator2);<br>animatorSet.start();  </p>
<p>// 或者<br>// 使用 AnimatorSet.play(animatorA).with/before/after(animatorB)<br>// 的方式来精确配置各个 Animator 之间的关系<br>animatorSet.play(animator1).with(animator2);<br>animatorSet.play(animator1).before(animator2);<br>animatorSet.play(animator1).after(animator2);<br>animatorSet.start();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### PropertyValuesHolders.ofKeyframe() 把同一个属性拆分</span><br><span class="line"></span><br><span class="line">- 除了合并多个属性和调配多个动画，还可以在 `PropertyValuesHolder` 的基础上更进一步，通过设置 `Keyframe` （关键帧），把同一个动画属性拆分成多个阶段。例如，你可以让一个进度增加到 100% 后再「反弹」回来。</span><br></pre></td></tr></table></figure></p>
<p>// 在 0% 处开始<br>Keyframe keyframe1 = Keyframe.ofFloat(0, 0);<br>// 时间经过 50% 的时候，动画完成度 100%<br>Keyframe keyframe2 = Keyframe.ofFloat(0.5f, 100);<br>// 时间见过 100% 的时候，动画完成度倒退到 80%，即反弹 20%<br>Keyframe keyframe3 = Keyframe.ofFloat(1, 80);<br>PropertyValuesHolder holder = PropertyValuesHolder.ofKeyframe(“progress”, keyframe1, keyframe2, keyframe3);</p>
<p>ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(view, holder);<br>animator.start();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## ValueAnimator</span><br><span class="line"></span><br><span class="line">&gt; 除了 ViewPropertyAnimator 和 ObjectAnimator，还有第三个选择是 ValueAnimator。ValueAnimator 并不常用，因为它的功能太基础了。ValueAnimator 是 ObjectAnimator 的父类，实际上，ValueAnimator 就是一个不能指定目标对象版本的 ObjectAnimator。ObjectAnimator 是自动调用目标对象的 setter 方法来更新目标属性的值，以及很多的时候还会以此来改变目标对象的 UI，而 ValueAnimator 只是通过渐变的方式来改变一个独立的数据，这个数据不是属于某个对象的，至于在数据更新后要做什么事，全都由你来定，你可以依然是去调用某个对象的 setter 方法（别这么为难自己），也可以做其他的事，不管要做什么，都是要你自己来写的，ValueAnimator 不会帮你做。功能最少、最不方便，但有时也是束缚最少、最灵活。比如有的时候，你要给一个第三方控件做动画，你需要更新的那个属性没有 setter 方法，只能直接修改，这样的话 ObjectAnimator 就不灵了啊。怎么办？这个时候你就可以用 ValueAnimator，在它的 onUpdate() 里面更新这个属性的值，并且手动调用 invalidate()。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 所以，ViewPropertyAnimator、ObjectAnimator、ValueAnimator 这三种 Animator，它们其实是一种递进的关系：从左到右依次变得更加难用，也更加灵活。但我要说明一下，它们的性能是一样的，因为 ViewPropertyAnimator 和 ObjectAnimator 的内部实现其实都是 ValueAnimator，ObjectAnimator 更是本来就是 ValueAnimator 的子类，它们三个的性能并没有差别。它们的差别只是使用的便捷性以及功能的灵活性。所以在实际使用时候的选择，只要遵循一个原则就行：尽量用简单的。能用 View.animate() 实现就不用 ObjectAnimator，能用 ObjectAnimator 就不用 ValueAnimator。</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">作茧自缚</p>
              <p class="site-description motion-element" itemprop="description">格物致知</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">作茧自缚</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>
  <a href="https://github.com/xuqinzz"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://zhizhi.disqus.com/count.js" async></script>
    

    

  




	





  














  





  

  

  

  
  

  

  

  

  
<script type="text/javascript">
    //微信二维码点击背景关闭
    $('body').delegate('.-mob-share-weixin-qrcode-bg','click', function(){
         $(".-mob-share-weixin-qrcode-close").trigger("click");
    }); 
</script>

</body>
</html>
