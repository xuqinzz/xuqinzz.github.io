<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="c5yB2B-3tswoQK7D0ZfZDqbSGvVzLxh-kwnbxyeTdaU" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="guide," />










<meta name="description" content="Providing Resources提供资源 App应该始终外部化应用资源，如图像和代码中的字符串资源，这样有利于单独维护这些资源。并且应该将资源分组到专门命名的资源目录中，以便为特定的设备提供备用资源。在运行时，Android 会根据当前配置使用适当的资源。例如，您可能需要根据屏幕尺寸提供不同的 UI 布局，或者根据语言设置提供不同的字符串。  资源类型目录 项目 res/ 目录内支持的资源目">
<meta name="keywords" content="guide">
<meta property="og:type" content="article">
<meta property="og:title" content="API Guide之App Resources">
<meta property="og:url" content="http://yoursite.com/2018/03/20/API-Guide之App-Resources/index.html">
<meta property="og:site_name" content="跬步">
<meta property="og:description" content="Providing Resources提供资源 App应该始终外部化应用资源，如图像和代码中的字符串资源，这样有利于单独维护这些资源。并且应该将资源分组到专门命名的资源目录中，以便为特定的设备提供备用资源。在运行时，Android 会根据当前配置使用适当的资源。例如，您可能需要根据屏幕尺寸提供不同的 UI 布局，或者根据语言设置提供不同的字符串。  资源类型目录 项目 res/ 目录内支持的资源目">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://ouv36g1sw.bkt.clouddn.com/Android%20%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E6%9C%80%E4%BD%B3%E5%8C%B9%E9%85%8D%E8%B5%84%E6%BA%90%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE">
<meta property="og:updated_time" content="2018-04-21T17:29:58.849Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="API Guide之App Resources">
<meta name="twitter:description" content="Providing Resources提供资源 App应该始终外部化应用资源，如图像和代码中的字符串资源，这样有利于单独维护这些资源。并且应该将资源分组到专门命名的资源目录中，以便为特定的设备提供备用资源。在运行时，Android 会根据当前配置使用适当的资源。例如，您可能需要根据屏幕尺寸提供不同的 UI 布局，或者根据语言设置提供不同的字符串。  资源类型目录 项目 res/ 目录内支持的资源目">
<meta name="twitter:image" content="http://ouv36g1sw.bkt.clouddn.com/Android%20%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E6%9C%80%E4%BD%B3%E5%8C%B9%E9%85%8D%E8%B5%84%E6%BA%90%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/03/20/API-Guide之App-Resources/"/>




<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #ffffff; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #ffffff, 0 0 5px #ffffff; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #ffffff;    /*上边框颜色*/
        border-left-color: #ffffff;    /*左边框颜色*/
    }
</style>
  <title>API Guide之App Resources | 跬步</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-113549877-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">跬步</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程表
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/20/API-Guide之App-Resources/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="作茧自缚">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="跬步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">API Guide之App Resources</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-20T00:47:23+08:00">
                2018-03-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/guide/" itemprop="url" rel="index">
                    <span itemprop="name">guide</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/20/API-Guide之App-Resources/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/03/20/API-Guide之App-Resources/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Providing-Resources提供资源"><a href="#Providing-Resources提供资源" class="headerlink" title="Providing Resources提供资源"></a>Providing Resources提供资源</h1><blockquote>
<p>App应该始终外部化应用资源，如图像和代码中的字符串资源，这样有利于单独维护这些资源。并且应该将资源分组到专门命名的资源目录中，以便为特定的设备提供备用资源。在运行时，Android 会根据当前配置使用适当的资源。例如，您可能需要根据屏幕尺寸提供不同的 UI 布局，或者根据语言设置提供不同的字符串。</p>
</blockquote>
<h2 id="资源类型目录"><a href="#资源类型目录" class="headerlink" title="资源类型目录"></a>资源类型目录</h2><ul>
<li>项目 <code>res/</code> 目录内支持的资源目录（表1）。</li>
</ul>
<table>
<thead>
<tr>
<th>目录</th>
<th>资源类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>animator/</code></td>
<td>用于定义<a href="https://developer.android.google.cn/guide/topics/graphics/prop-animation.html" target="_blank" rel="noopener">属性动画</a>的 XML 文件。</td>
</tr>
<tr>
<td><code>anim/</code></td>
<td>定义<a href="https://developer.android.google.cn/guide/topics/graphics/view-animation.html#tween-animation" target="_blank" rel="noopener">渐变动画</a>的 XML 文件。（属性动画也可以保存在此目录中，但是为了区分这两种类型，属性动画首选 <code>animator/</code> 目录。）</td>
</tr>
<tr>
<td><code>color/</code></td>
<td>用于定义颜色状态列表的 XML 文件。请参阅<a href="https://developer.android.google.cn/guide/topics/resources/color-list-resource.html" target="_blank" rel="noopener">颜色状态列表资源</a></td>
</tr>
<tr>
<td><code>drawable/</code></td>
<td>位图文件（<code>.png</code>、<code>.9.png</code>、<code>.jpg</code>、<code>.gif</code>）或编译为以下可绘制对象资源子类型的 XML 文件：位图文件九宫格（可调整大小的位图）状态列表形状动画可绘制对象其他可绘制对象请参阅 <a href="https://developer.android.google.cn/guide/topics/resources/drawable-resource.html" target="_blank" rel="noopener">可绘制对象资源</a>。</td>
</tr>
<tr>
<td><code>mipmap/</code></td>
<td>适用于不同启动器图标密度的可绘制对象文件。如需了解有关使用 <code>mipmap/</code> 文件夹管理启动器图标的详细信息，请参阅<a href="https://developer.android.google.cn/tools/projects/index.html#mipmap" target="_blank" rel="noopener">管理项目概览</a>。</td>
</tr>
<tr>
<td><code>layout/</code></td>
<td>用于定义用户界面布局的 XML 文件。 请参阅<a href="https://developer.android.google.cn/guide/topics/resources/layout-resource.html" target="_blank" rel="noopener">布局资源</a>。</td>
</tr>
<tr>
<td><code>menu/</code></td>
<td>用于定义应用菜单（如选项菜单、上下文菜单或子菜单）的 XML 文件。请参阅<a href="https://developer.android.google.cn/guide/topics/resources/menu-resource.html" target="_blank" rel="noopener">菜单资源</a>。</td>
</tr>
<tr>
<td><code>raw/</code></td>
<td>要以原始形式保存的任意文件。要使用原始 <code>InputStream</code> 打开这些资源，请使用资源 ID（即 <code>R.raw.*filename*</code>）调用 <code>Resources.openRawResource()</code>。但是，如需访问原始文件名和文件层次结构，则可以考虑将某些资源保存在 <code>assets/</code> 目录下（而不是 <code>res/raw/</code>）。<code>assets/</code> 中的文件没有资源 ID，因此您只能使用 <code>AssetManager</code> 读取这些文件。</td>
</tr>
<tr>
<td><code>values/</code></td>
<td>包含字符串、整型数和颜色等简单值的 XML 文件。其他 <code>res/</code> 子目录中的 XML 资源文件是根据 XML 文件名定义单个资源，而 <code>values/</code> 目录中的文件可描述多个资源。对于此目录中的文件，<code>&lt;resources&gt;</code> 元素的每个子元素均定义一个资源。例如，<code>&lt;string&gt;</code> 元素创建 <code>R.string</code> 资源，<code>&lt;color&gt;</code> 元素创建 <code>R.color</code> 资源。由于每个资源均用其自己的 XML 元素定义，因此您可以根据自己的需要命名文件，并将不同的资源类型放在一个文件中。但是，为了清晰起见，您可能需要将独特的资源类型放在不同的文件中。 例如，对于可在此目录中创建的资源，下面给出了相应的文件名约定：arrays.xml，用于资源数组（<a href="https://developer.android.google.cn/guide/topics/resources/more-resources.html#TypedArray" target="_blank" rel="noopener">类型化数组</a>）。colors.xml：<a href="https://developer.android.google.cn/guide/topics/resources/more-resources.html#Color" target="_blank" rel="noopener">颜色值</a>。dimens.xml：<a href="https://developer.android.google.cn/guide/topics/resources/more-resources.html#Dimension" target="_blank" rel="noopener">尺寸值</a>。strings.xml：<a href="https://developer.android.google.cn/guide/topics/resources/string-resource.html" target="_blank" rel="noopener">字符串值</a>。styles.xml：<a href="https://developer.android.google.cn/guide/topics/resources/style-resource.html" target="_blank" rel="noopener">样式</a>。请参阅<a href="https://developer.android.google.cn/guide/topics/resources/string-resource.html" target="_blank" rel="noopener">字符串资源</a>、<a href="https://developer.android.google.cn/guide/topics/resources/style-resource.html" target="_blank" rel="noopener">样式资源</a>和<a href="https://developer.android.google.cn/guide/topics/resources/more-resources.html" target="_blank" rel="noopener">更多资源类型</a>。</td>
</tr>
<tr>
<td><code>xml/</code></td>
<td>可以在运行时通过调用 <code>Resources.getXML()</code> 读取的任意 XML 文件。各种 XML 配置文件（如<a href="https://developer.android.google.cn/guide/topics/search/searchable-config.html" target="_blank" rel="noopener">可搜索配置</a>）都必须保存在此处。</td>
</tr>
</tbody>
</table>
<h2 id="提供备用资源"><a href="#提供备用资源" class="headerlink" title="提供备用资源"></a>提供备用资源</h2><blockquote>
<p>几乎每个应用都应提供备用资源以支持特定的设备配置。</p>
</blockquote>
<ul>
<li>为一组资源指定特定于配置的备用资源：</li>
</ul>
<ol>
<li><p>在<code>res/</code>中创建一个以<code>&lt;resources_name&gt;-&lt;config_qualifier&gt;</code>形式命名的新目录。</p>
<ul>
<li><em>&lt;resources_name&gt;</em> 是相应默认资源的目录名称（如表 1 中所定义）。</li>
<li><em><qualifier></qualifier></em> 是指定要使用这些资源的各个配置的名称（如表 2 中所定义）。</li>
</ul>
<p>您可以追加多个 <em><qualifier></qualifier></em>。以短划线将其分隔。</p>
<p><strong>注意</strong>：追加多个限定符时，必须按照表 2 中列出的相同顺序放置它们。如果限定符的顺序错误，则该资源将被忽略。</p>
</li>
<li><p>将相应的备用资源保存在此新目录下。这些资源文件的名称必须与默认资源文件完全一样。</p>
<p>例如，以下是一些默认资源和备用资源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">res/</span><br><span class="line">    drawable/   </span><br><span class="line">        icon.png</span><br><span class="line">        background.png    </span><br><span class="line">    drawable-hdpi/  </span><br><span class="line">        icon.png</span><br><span class="line">        background.png</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>hdpi</code> 限定符表示该目录中的资源适用于屏幕密度较高的设备。其中每个可绘制对象目录中的图像已针对特定的屏幕密度调整大小，但是文件名完全相同。 这样一来，用于引用 <code>icon.png</code> 或 <code>background.png</code> 图像的资源 ID 始终相同，但是 Android 会通过将设备配置信息与资源目录名称中的限定符进行比较，选择最符合当前设备的各个资源版本。</p>
<p>Android 支持若干配置限定符，您可以通过使用短划线分隔每个限定符，向一个目录名称添加多个限定符。表 2 按优先顺序列出了有效的配置限定符；如果对资源目录使用多个限定符，则必须按照表中列出的顺序将它们添加到目录名称。</p>
</li>
</ol>
<ul>
<li>配置限定符名称(表2)</li>
</ul>
<table>
<thead>
<tr>
<th>配置</th>
<th>限定符值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>MCC 和 MNC</td>
<td>示例：<code>mcc310`</code>mcc310-mnc004<code></code>mcc208-mnc00`等等</td>
<td>移动国家代码 (MCC)，（可选）后跟设备 SIM 卡中的移动网络代码 (MNC)。例如，<code>mcc310</code> 是指美国的任一运营商，<code>mcc310-mnc004</code> 是指美国的 Verizon 公司，<code>mcc208-mnc00</code> 是指法国的 Orange 公司。如果设备使用无线电连接（GSM 手机），则 MCC 和 MNC 值来自 SIM 卡。也可以单独使用 MCC（例如，将国家/地区特定的合法资源包括在应用中）。如果只需根据语言指定，则改用“语言和区域”限定符（稍后进行介绍）。 如果决定使用 MCC 和 MNC 限定符，请谨慎执行此操作并测试限定符是否按预期工作。另请参阅配置字段 <code>mcc</code> 和 <code>mnc</code>，这两个字段分别表示当前的移动国家代码和移动网络代码。</td>
</tr>
<tr>
<td>语言和区域</td>
<td>示例：<code>en`</code>fr<code></code>en-rUS`等</td>
<td>语言通过由两个字母组成的 <a href="http://www.loc.gov/standards/iso639-2/php/code_list.php" target="_blank" rel="noopener">ISO 639-1</a> 语言代码定义，可以选择后跟两个字母组成的 <a href="http://www.iso.org/iso/en/prods-services/iso3166ma/02iso-3166-code-lists/list-en1.html" target="_blank" rel="noopener">ISO 3166-1-alpha-2</a> 区域码（前带小写字母“<code>r</code>”）。这些代码不区分大小写；<code>r</code> 前缀用于区分区域码。 不能单独指定区域。如果用户更改系统设置中的语言，它有可能在应用生命周期中发生改变。 如需了解这会在运行期间给应用带来哪些影响，请参阅<a href="https://developer.android.google.cn/guide/topics/resources/runtime-changes.html" target="_blank" rel="noopener">处理运行时变更</a>。有关针对其他语言本地化应用的完整指南，请参阅<a href="https://developer.android.google.cn/guide/topics/resources/localization.html" target="_blank" rel="noopener">本地化</a>。另请参阅 <code>locale</code> 配置字段，该字段表示当前的语言区域。</td>
</tr>
<tr>
<td>布局方向</td>
<td><code>ldrtl`</code>ldltr`</td>
<td>应用的布局方向。<code>ldrtl</code> 是指“布局方向从右到左”。<code>ldltr</code> 是指“布局方向从左到右”，这是默认的隐式值。它适用于布局、图片或值等任何资源。例如，若要针对阿拉伯语提供某种特定布局，并针对任何其他“从右到左”语言（如波斯语或希伯来语）提供某种通用布局，则可编码如下：<code>res/    layout/           main.xml  (Default layout)    layout-ar/          main.xml  (Specific layout for Arabic)    layout-ldrtl/          main.xml  (Any &quot;right-to-left&quot; language, except                  for Arabic, because the &quot;ar&quot; language qualifier                  has a higher precedence.)</code><strong>注</strong>：要为应用启用从右到左的布局功能，必须将 <a href="https://developer.android.google.cn/guide/topics/manifest/application-element.html#supportsrtl" target="_blank" rel="noopener"><code>supportsRtl</code></a> 设置为 <code>&quot;true&quot;</code>，并将 <a href="https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element.html#target" target="_blank" rel="noopener"><code>targetSdkVersion</code></a> 设置为 17 或更高版本。<em>此项为 API 级别 17 中新增配置。</em></td>
</tr>
<tr>
<td>smallestWidth</td>
<td><code>sw&lt;N&gt;dp</code>示例：<code>sw320dp`</code>sw600dp<code></code>sw720dp`等等</td>
<td>屏幕的基本尺寸，由可用屏幕区域的最小尺寸指定。 具体来说，设备的 smallestWidth 是屏幕可用高度和宽度的最小尺寸（您也可以将其视为屏幕的“最小可能宽度”）。无论屏幕的当前方向如何，您均可使用此限定符确保应用 UI 的可用宽度至少为 <code>&lt;N&gt;</code>dp。例如，如果布局要求屏幕区域的最小尺寸始终至少为 600dp，则可使用此限定符创建布局资源 <code>res/layout-sw600dp/</code>。仅当可用屏幕的最小尺寸至少为 600dp 时，系统才会使用这些资源，而不考虑 600dp 所代表的边是用户所认为的高度还是宽度。smallestWidth 是设备的固定屏幕尺寸特性；<strong>设备的 smallestWidth 不会随屏幕方向的变化而改变</strong>。设备的 smallestWidth 将屏幕装饰元素和系统 UI 考虑在内。例如，如果设备的屏幕上有一些永久性 UI 元素占据沿 smallestWidth 轴的空间，则系统会声明 smallestWidth 小于实际屏幕尺寸，因为这些屏幕像素不适用于您的 UI。 因此，使用的值应该是<em>布局所需要</em>的实际最小尺寸（通常，无论屏幕的当前方向如何，此值都是布局支持的“最小宽度”）。以下是一些可用于普通屏幕尺寸的值：320，适用于屏幕配置如下的设备：240x320 ldpi（QVGA 手机）320x480 mdpi（手机）480x800 hdpi（高密度手机）480，适用于 480x800 mdpi 之类的屏幕（平板电脑/手机）。600，适用于 600x1024 mdpi 之类的屏幕（7 英寸平板电脑）。720，适用于 720x1280 mdpi 之类的屏幕（10 英寸平板电脑）。应用为多个资源目录提供不同的 smallestWidth 限定符值时，系统会使用最接近（但未超出）设备 smallestWidth 的值。<em>此项为 API 级别 13 中新增配置。</em>另请参阅 <a href="https://developer.android.google.cn/guide/topics/manifest/supports-screens-element.html#requiresSmallest" target="_blank" rel="noopener"><code>android:requiresSmallestWidthDp</code></a> 属性和 <code>smallestScreenWidthDp</code> 配置字段，前者声明与应用兼容的最小 smallestWidth；后者存放设备的 smallestWidth 值。如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅<a href="https://developer.android.google.cn/guide/practices/screens_support.html" target="_blank" rel="noopener">支持多种屏幕</a>开发者指南。</td>
</tr>
<tr>
<td>可用宽度</td>
<td><code>w&lt;N&gt;dp</code>示例：<code>w720dp</code>等</td>
<td>指定资源应该使用的最小可用屏幕宽度，以 <code>dp</code> 为单位，由 <code>&lt;N&gt;</code> 值定义。在横向和纵向之间切换时，为了匹配当前实际宽度，此配置值也会随之发生变化。应用为多个资源目录提供不同的此配置值时，系统会使用最接近（但未超出）设备当前屏幕宽度的值。 此处的值考虑到了屏幕装饰元素，因此如果设备显示屏的左边缘或右边缘上有一些永久性 UI 元素，考虑到这些 UI 元素，它会使用小于实际屏幕尺寸的宽度值，这样会减少应用的可用空间。<em>此项为 API 级别 13 中新增配置。</em>另请参阅 <code>screenWidthDp</code> 配置字段，该字段存放当前屏幕宽度。如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅<a href="https://developer.android.google.cn/guide/practices/screens_support.html" target="_blank" rel="noopener">支持多种屏幕</a>开发者指南。</td>
</tr>
<tr>
<td>可用高度</td>
<td><code>h&lt;N&gt;dp</code>示例：<code>h720dp</code>等</td>
<td>指定资源应该使用的最小可用屏幕高度，以“dp”为单位，由 <code>&lt;N&gt;</code> 值定义。 在横向和纵向之间切换时，为了匹配当前实际高度，此配置值也会随之发生变化。应用为多个资源目录提供不同的此配置值时，系统会使用最接近（但未超出）设备当前屏幕高度的值。 此处的值考虑到了屏幕装饰元素，因此如果设备显示屏的上边缘或下边缘有一些永久性 UI 元素，考虑到这些 UI 元素，同时为减少应用的可用空间，它会使用小于实际屏幕尺寸的高度值。 非固定的屏幕装饰元素（例如，全屏时可隐藏的手机状态栏）并不在考虑范围内，标题栏或操作栏等窗口装饰也不在考虑范围内，因此应用必须准备好处理稍小于其所指定值的空间。<em>此项为 API 级别 13 中新增配置。</em>另请参阅 <code>screenHeightDp</code> 配置字段，该字段存放当前屏幕宽度。如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅<a href="https://developer.android.google.cn/guide/practices/screens_support.html" target="_blank" rel="noopener">支持多种屏幕</a>开发者指南。</td>
</tr>
<tr>
<td>屏幕尺寸</td>
<td><code>small`</code>normal<code>large</code>xlarge`</td>
<td><code>small</code>：尺寸类似于低密度 QVGA 屏幕的屏幕。小屏幕的最小布局尺寸约为 320x426 dp 单位。例如，QVGA 低密度屏幕和 VGA 高密度屏幕。<code>normal</code>：尺寸类似于中等密度 HVGA 屏幕的屏幕。标准屏幕的最小布局尺寸约为 320x470 dp 单位。例如，WQVGA 低密度屏幕、HVGA 中等密度屏幕、WVGA 高密度屏幕。<code>large</code>：尺寸类似于中等密度 VGA 屏幕的屏幕。 大屏幕的最小布局尺寸约为 480x640 dp 单位。 例如，VGA 和 WVGA 中等密度屏幕。<code>xlarge</code>：明显大于传统中等密度 HVGA 屏幕的屏幕。超大屏幕的最小布局尺寸约为 720x960 dp 单位。在大多数情况下，屏幕超大的设备体积过大，不能放进口袋，最常见的是平板式设备。 <em>API 级别 9 中的新增配置。**</em>注<strong>：使用尺寸限定符并不表示资源仅适用于该尺寸的屏幕。 如果没有为备用资源提供最符合当前设备配置的限定符，则系统可能使用其中<a href="https://developer.android.google.cn/guide/topics/resources/providing-resources.html#BestMatch" target="_blank" rel="noopener">最匹配</a>的资源。</strong>注意<strong>：如果所有资源均使用大于当前屏幕的尺寸限定符，则系统</strong>不*<em>会使用这些资源，并且应用在运行时将会崩溃（例如，如果所有布局资源均用 <code>xlarge</code> 限定符标记，但设备是标准尺寸的屏幕）。</em>此项为 API 级别 4 中新增配置。*如需了解详细信息，请参阅<a href="https://developer.android.google.cn/guide/practices/screens_support.html" target="_blank" rel="noopener">支持多种屏幕</a>。另请参阅 <code>screenLayout</code> 配置字段，该字段表示屏幕是小尺寸、标准尺寸还是大尺寸。</td>
</tr>
<tr>
<td>屏幕纵横比</td>
<td><code>long`</code>notlong`</td>
<td><code>long</code>：宽屏，如 WQVGA、WVGA、FWVGA<code>notlong</code>：非宽屏，如 QVGA、HVGA 和 VGA<em>此项为 API 级别 4 中新增配置。</em>它完全基于屏幕的纵横比（宽屏较宽），而与屏幕方向无关。另请参阅 <code>screenLayout</code> 配置字段，该字段指示屏幕是否为宽屏。</td>
</tr>
<tr>
<td>圆形屏幕</td>
<td><code>round`</code>notround`</td>
<td><code>round</code>：圆形屏幕，例如圆形可穿戴式设备<code>notround</code>：方形屏幕，例如手机或平板电脑<em>此项为 API 级别 23 中新增配置。</em>另请参阅 <code>isScreenRound()</code> 配置方法，其指示屏幕是否为宽屏。</td>
</tr>
<tr>
<td>屏幕方向</td>
<td><code>port`</code>land`</td>
<td><code>port</code>：设备处于纵向（垂直）<code>land</code>：设备处于横向（水平）如果用户旋转屏幕，它有可能在应用生命周期中发生改变。 如需了解这会在运行期间给应用带来哪些影响，请参阅<a href="https://developer.android.google.cn/guide/topics/resources/runtime-changes.html" target="_blank" rel="noopener">处理运行时变更</a>。另请参阅 <code>orientation</code> 配置字段，该字段指示当前的设备方向。</td>
</tr>
<tr>
<td>UI 模式</td>
<td><code>car`</code>desk<code></code>televisionappliancewatch  `</td>
<td><code>car</code>：设备正在车载手机座上显示<code>desk</code>：设备正在桌面手机座上显示<code>television</code>：设备正在电视上显示，为用户提供“十英尺”体验，其 UI 位于远离用户的大屏幕上，主要面向方向键或其他非指针式交互<code>appliance</code>：设备用作不带显示屏的装置<code>watch</code>：设备配有显示屏，戴在手腕上<em>此项为 API 级别 8 中新增配置，API 13 中新增电视配置，API 20 中新增手表配置。</em>如需了解应用在设备插入手机座或从中移除时的响应方式，请阅读<a href="https://developer.android.google.cn/training/monitoring-device-state/docking-monitoring.html" target="_blank" rel="noopener">确定并监控插接状态和类型</a>。如果用户将设备放入手机座中，它有可能在应用生命周期中发生改变。 可以使用 <code>UiModeManager</code> 启用或禁用其中某些模式。如需了解这会在运行期间给应用带来哪些影响，请参阅<a href="https://developer.android.google.cn/guide/topics/resources/runtime-changes.html" target="_blank" rel="noopener">处理运行时变更</a>。</td>
</tr>
<tr>
<td>夜间模式</td>
<td><code>night`</code>notnight`</td>
<td><code>night</code>：夜间<code>notnight</code>：白天<em>此项为 API 级别 8 中新增配置。</em>如果夜间模式停留在自动模式（默认），它有可能在应用生命周期中发生改变。在这种情况下，该模式会根据当天的时间进行调整。 可以使用 <code>UiModeManager</code> 启用或禁用此模式。如需了解这会在运行期间给应用带来哪些影响，请参阅<a href="https://developer.android.google.cn/guide/topics/resources/runtime-changes.html" target="_blank" rel="noopener">处理运行时变更</a>。</td>
</tr>
<tr>
<td>屏幕像素密度 (dpi)</td>
<td><code>ldpi</code>…<code>nodpi`</code>tvdpi<code></code>anydpi`</td>
<td><code>ldpi</code>：低密度屏幕；约为 120dpi。<code>mdpi</code>：中等密度（传统 HVGA）屏幕；约为 160dpi。<code>hdpi</code>：高密度屏幕；约为 240dpi。<code>xhdpi</code>：超高密度屏幕；约为 320dpi。<em>此项为 API 级别 8 中新增配置</em><code>xxhdpi</code>：超超高密度屏幕；约为 480dpi。<em>此项为 API 级别 16 中新增配置</em><code>xxxhdpi</code>：超超超高密度屏幕使用（仅限启动器图标，请参阅“支持多种屏幕”中的<a href="https://developer.android.google.cn/guide/practices/screens_support.html#xxxhdpi-note" target="_blank" rel="noopener">注释</a>）；约为 640dpi。 <em>此项为 API 级别 18 中新增配置</em><code>nodpi</code>：它可用于您不希望缩放以匹配设备密度的位图资源。<code>tvdpi</code>：密度介于 mdpi 和 hdpi 之间的屏幕；约为 213dpi。它并不是“主要”密度组， 主要用于电视，而大多数应用都不需要它。对于大多数应用而言，提供 mdpi 和 hdpi 资源便已足够，系统将根据需要对其进行缩放。<em>此项为 API 级别 13 中新增配置</em><code>anydpi</code>：此限定符适合所有屏幕密度，其优先级高于其他限定符。 这对于<a href="https://developer.android.google.cn/training/material/drawables.html#VectorDrawables" target="_blank" rel="noopener">矢量可绘制对象</a>很有用。 <em>此项为 API 级别 21 中新增配置</em>六个主要密度之间的缩放比为 3:4:6:8:12:16（忽略 tvdpi 密度）。因此，9x9 (ldpi) 位图相当于 12x12 (mdpi)、18x18 (hdpi)、24x24 (xhdpi) 位图，依此类推。如果您认为图像资源在电视或其他某些设备上呈现的效果不够好，而想尝试使用 tvdpi 资源，则缩放比例为 1.33*mdpi。例如，mdpi 屏幕的 100px x 100px 图像应该相当于 tvdpi 的133px x 133px。<strong>注</strong>：使用密度限定符并不表示资源仅适用于该密度的屏幕。 如果没有为备用资源提供最符合当前设备配置的限定符，则系统可能使用其中<a href="https://developer.android.google.cn/guide/topics/resources/providing-resources.html#BestMatch" target="_blank" rel="noopener">最匹配</a>的资源。如需了解有关如何处理不同屏幕密度以及 Android 如何缩放位图以适应当前密度的详细信息，请参阅<a href="https://developer.android.google.cn/guide/practices/screens_support.html" target="_blank" rel="noopener">支持多种屏幕</a>。</td>
</tr>
<tr>
<td></td>
<td><code>notouch`</code>finger`</td>
<td><code>notouch</code>：设备没有触摸屏。<code>finger</code>：设备有一个专供用户通过手指直接与其交互的触摸屏。另请参阅 <code>touchscreen</code> 配置字段，该字段指示设备上的触摸屏类型。</td>
</tr>
<tr>
<td>键盘可用性</td>
<td><code>keysexposed`</code>keyshidden<code></code>keyssoft`</td>
<td><code>keysexposed</code>：设备具有可用的键盘。如果设备启用了软键盘（不无可能），那么即使硬键盘没有展示给用户，哪怕设备没有硬键盘，也可以使用此限定符。 如果没有提供或已经禁用软键盘，则只有在显示硬键盘时才会使用此限定符。<code>keyshidden</code>：设备具有可用的硬键盘，但它处于隐藏状态，且设备没有启用软键盘。<code>keyssoft</code>：设备已经启用软键盘（无论是否可见）。如果提供了 <code>keysexposed</code> 资源，但未提供 <code>keyssoft</code> 资源，那么只要系统已经启用软键盘，就会使用<code>keysexposed</code> 资源，而不考虑键盘是否可见。如果用户打开硬键盘，它有可能在应用生命周期中发生改变。 如需了解这会在运行期间给应用带来哪些影响，请参阅<a href="https://developer.android.google.cn/guide/topics/resources/runtime-changes.html" target="_blank" rel="noopener">处理运行时变更</a>。另请参阅配置字段 <code>hardKeyboardHidden</code> 和 <code>keyboardHidden</code>，这两个字段分别指示硬键盘的可见性和任何一种键盘（包括软键盘）的可见性。</td>
</tr>
<tr>
<td>主要文本输入法</td>
<td><code>nokeys`</code>qwerty<code></code>12key`</td>
<td><code>nokeys</code>：设备没有用于文本输入的硬按键。<code>qwerty</code>：设备具有标准硬键盘（无论是否对用户可见）。<code>12key</code>：设备具有 12 键硬键盘（无论是否对用户可见）。另请参阅 <code>keyboard</code> 配置字段，该字段指示可用的主要文本输入法。</td>
</tr>
<tr>
<td>导航键可用性</td>
<td><code>navexposed`</code>navhidden`</td>
<td><code>navexposed</code>：导航键可供用户使用。<code>navhidden</code>：导航键不可用（例如，位于密封盖子后面）。如果用户显示导航键，它有可能在应用生命周期中发生改变。 如需了解这会在运行期间给应用带来哪些影响，请参阅<a href="https://developer.android.google.cn/guide/topics/resources/runtime-changes.html" target="_blank" rel="noopener">处理运行时变更</a>。另请参阅 <code>navigationHidden</code> 配置字段，该字段指示导航键是否处于隐藏状态。</td>
</tr>
<tr>
<td>主要非触摸导航方法</td>
<td><code>nonav`</code>dpad<code>trackball</code>wheel`</td>
<td><code>nonav</code>：除了使用触摸屏以外，设备没有其他导航设施。<code>dpad</code>：设备具有用于导航的方向键。<code>trackball</code>：设备具有用于导航的轨迹球。<code>wheel</code>：设备具有用于导航的方向盘（不常见）。另请参阅 <code>navigation</code> 配置字段，该字段指示可用的导航方法类型。</td>
</tr>
<tr>
<td>平台版本（API 级别）</td>
<td>示例：<code>v3`</code>v4<code></code>v7`等等</td>
<td>设备支持的 API 级别。例如，<code>v1</code> 对应于 API 级别 1（带有 Android 1.0 或更高版本系统的设备），<code>v4</code> 对应于 API 级别 4（带有 Android 1.6 或更高版本系统的设备）。如需了解有关这些值的详细信息，请参阅 <a href="https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element.html#ApiLevels" target="_blank" rel="noopener">Android API 级别</a>文档。</td>
</tr>
</tbody>
</table>
<h2 id="限定符命名规则"><a href="#限定符命名规则" class="headerlink" title="限定符命名规则"></a>限定符命名规则</h2><ul>
<li>用配置限定符名称的规则：<ul>
<li>可以为单组资源指定多个限定符，并使用短划线分隔。例如，<code>drawable-en-rUS-land</code> 适用于横排美国英语设备。</li>
<li>这些限定符必须遵循表 2中列出的顺序。例如：<ul>
<li>错误：<code>drawable-hdpi-port/</code></li>
<li>正确：<code>drawable-port-hdpi/</code></li>
</ul>
</li>
</ul>
</li>
<li>不能嵌套备用资源目录。例如，您不能拥有 <code>res/drawable/drawable-en/</code>。</li>
<li>值不区分大小写。在处理之前，资源编译器会将目录名称转换为小写，以避免不区分大小写的文件系统出现问题。 名称中使用的任何大写字母只是为了便于认读。</li>
<li>对于每种限定符类型，仅支持一个值。例如，若要对西班牙语和法语使用相同的可绘制对象文件，则您肯定不能拥有名为 <code>drawable-rES-rFR/</code> 的目录，而是需要两个包含相应文件的资源目录，如 <code>drawable-rES/</code> 和 <code>drawable-rFR/</code>。然而，实际上您无需将相同的文件都复制到这两个位置。相反，您可以创建指向资源的别名。 请参阅下面的<a href="https://developer.android.google.cn/guide/topics/resources/providing-resources.html#AliasResources" target="_blank" rel="noopener">创建别名资源</a>。</li>
</ul>
<h2 id="创建别名资源"><a href="#创建别名资源" class="headerlink" title="创建别名资源"></a>创建别名资源</h2><blockquote>
<p>如果想将某一资源用于多种设备配置（但是不想作为默认资源提供），则无需将同一资源放入多个备用资源目录中。 而是可以（在某些情况下）创建备用资源，充当保存在默认资源目录下的资源的别名。（<strong>注</strong>：并非所有资源都会提供相应机制让您创建指向其他资源的别名。 特别是，<code>xml/</code> 目录中的动画资源、菜单资源、原始资源以及其他未指定资源均不提供此功能。）</p>
<p>例如，假设您有一个应用图标 <code>icon.png</code>，并且需要不同语言区域的独特版本。 但是，加拿大英语和加拿大法语这两种语言区域需要使用同一版本。 您可能会认为需要将相同的图像复制到加拿大英语和加拿大法语对应的资源目录中，但事实并非如此。 相反，可以将用于二者的图像另存为 <code>icon_ca.png</code>（除 <code>icon.png</code> 以外的任何名称），并将其放入默认 <code>res/drawable/</code> 目录中。然后，在 <code>res/drawable-en-rCA/</code> 和 <code>res/drawable-fr-rCA/</code> 中创建 <code>icon.xml</code> 文件，使用 <code>&lt;bitmap&gt;</code> 元素引用 <code>icon_ca.png</code> 资源。这样，您只需存储 PNG 文件的一个版本和两个指向该版本的小型 XML 文件。（XML 文件示例如下。）</p>
</blockquote>
<ul>
<li><h4 id="可绘制对象"><a href="#可绘制对象" class="headerlink" title="可绘制对象"></a>可绘制对象</h4><ul>
<li><p>要创建指向现有可绘制对象的别名，请使用 <bitmap> 元素。例如：</bitmap></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;bitmap xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:src=&quot;@drawable/icon_ca&quot; /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果将此文件另存为 <code>icon.xml</code>（例如，在备用资源目录中，另存为 <code>res/drawable-en-rCA/</code>），则会编译到可作为 <code>R.drawable.icon</code> 引用的资源中，但实际上它是 <code>R.drawable.icon_ca</code> 资源（保存在 <code>res/drawable/</code> 中）的别名。</p>
</li>
</ul>
</li>
<li><h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><ul>
<li><p>要创建指向现有布局的别名，请使用包装在 <code>&lt;merge&gt;</code> 中的 <code>&lt;include&gt;</code> 元素。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;merge&gt;</span><br><span class="line">    &lt;include layout=&quot;@layout/main_ltr&quot;/&gt;</span><br><span class="line">&lt;/merge&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果将此文件另存为 <code>main.xml</code>，则会编译到可作为 <code>R.layout.main</code> 引用的资源中，但实际上它是 <code>R.layout.main_ltr</code> 资源的别名。</p>
</li>
</ul>
</li>
<li><h4 id="字符串和其他简单值"><a href="#字符串和其他简单值" class="headerlink" title="字符串和其他简单值"></a>字符串和其他简单值</h4><ul>
<li><p>要创建指向现有字符串的别名，只需将所需字符串的资源 ID 用作新字符串的值即可。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;string name=&quot;hello&quot;&gt;Hello&lt;/string&gt;</span><br><span class="line">    &lt;string name=&quot;hi&quot;&gt;@string/hello&lt;/string&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://developer.android.google.cn/guide/topics/resources/more-resources.html" target="_blank" rel="noopener">其他简单值</a>的原理相同。 例如，颜色：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;color name=&quot;red&quot;&gt;#f00&lt;/color&gt;</span><br><span class="line">    &lt;color name=&quot;highlight&quot;&gt;@color/red&lt;/color&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="利用资源提供最佳设备兼容性"><a href="#利用资源提供最佳设备兼容性" class="headerlink" title="利用资源提供最佳设备兼容性"></a>利用资源提供最佳设备兼容性</h2><blockquote>
<p>要使应用支持多种设备配置，则务必为应用使用的每种资源类型提供默认资源，这一点非常重要。\</p>
<p>例如，如果应用支持多种语言，请始终包含不带<a href="https://developer.android.google.cn/guide/topics/resources/providing-resources.html#LocaleQualifier" target="_blank" rel="noopener">语言和区域限定符</a>的 <code>values/</code> 目录（用于保存字符串）。相反，如果您将所有字符串放入带有语言和区域限定符的目录中，则在语言设置不支持您的字符串的设备上运行应用时，应用将会崩溃。 但是，只要提供默认 <code>values/</code> 资源，应用就会正常运行（即使用户不理解该语言，这也总比崩溃要好）。</p>
<p>如果根据屏幕方向提供不同的布局资源，则应选择一个方向作为默认方向。 例如，不要在 <code>layout-land/</code> 和 <code>layout-port/</code> 中分别提供横向和纵向的布局资源，而是保留其中之一作为默认设置，例如：<code>layout/</code> 用于横向，<code>layout-port/</code> 用于纵向。</p>
<p>提供默认资源至关重要，这不仅仅因为应用可能在超出预期的配置上运行，也因为新版 Android 有时会添加旧版本不支持的配置限定符。若要使用新的资源限定符，又希望维持对旧版 Android 的代码兼容性，则当旧版 Android 运行应用时，如果不提供默认资源，应用将会崩溃，这是因为它无法使用以新限定符命名的资源。例如，如果将 <a href="https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element.html#min" target="_blank" rel="noopener"><code>minSdkVersion</code></a> 设置为 4，并使用<a href="https://developer.android.google.cn/guide/topics/resources/providing-resources.html#NightQualifier" target="_blank" rel="noopener">夜间模式</a>（<code>night</code> 或 <code>notnight</code>，API 级别 8 中新增配置）限定所有可绘制对象资源，则 API 级别 4 设备无法访问可绘制对象资源，而且会崩溃。在这种情况下，您可能希望 <code>notnight</code> 成为默认资源，为此，您应排除该限定符，使可绘制对象资源位于 <code>drawable/</code> 或 <code>drawable-night/</code> 中。</p>
<p>因此，为了提供最佳设备兼容性，请始终为应用正确运行所必需的资源提供默认资源。 然后，使用配置限定符为特定的设备配置创建备用资源。</p>
<p>这条规则有一个例外：如果应用的 <a href="https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element.html#min" target="_blank" rel="noopener"><code>minSdkVersion</code></a> 为 4 或更高版本，则在提供带<a href="https://developer.android.google.cn/guide/topics/resources/providing-resources.html#DensityQualifier" target="_blank" rel="noopener">屏幕密度</a>限定符的备用可绘制对象资源时，不需要默认可绘制对象资源。 即使没有默认可绘制对象资源，Android 也可以从备用屏幕密度中找到最佳匹配项并根据需要缩放位图。 但是，为了在所有类型的设备上提供最佳体验，您应该为所有三种类型的密度提供备用可绘制对象。</p>
</blockquote>
<h2 id="Android-如何查找最佳匹配资源"><a href="#Android-如何查找最佳匹配资源" class="headerlink" title="Android 如何查找最佳匹配资源"></a>Android 如何查找最佳匹配资源</h2><ul>
<li><p>当请求要为其提供备用资源的资源时，Android 会根据当前的设备配置选择要在运行时使用的备用资源。为演示 Android 如何选择备用资源，假设以下可绘制对象目录分别包含相同图像的不同版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">drawable/</span><br><span class="line">drawable-en/</span><br><span class="line">drawable-fr-rCA/</span><br><span class="line">drawable-en-port/</span><br><span class="line">drawable-en-notouch-12key/</span><br><span class="line">drawable-port-ldpi/</span><br><span class="line">drawable-port-notouch-12key/</span><br></pre></td></tr></table></figure>
</li>
<li><p>同时，通过将设备配置与可用的备用资源进行比较，Android 从 <code>drawable-en-port</code> 中选择可绘制对象。假设设备配置如下：</p>
<ul>
<li>语言区域 = <code>en-GB</code> </li>
<li>屏幕方向 = <code>port</code> </li>
<li>屏幕像素密度 = <code>hdpi</code> </li>
<li>触摸屏类型 = <code>notouch</code> </li>
<li>主要文本输入法 = <code>12key</code></li>
</ul>
</li>
<li><p>系统使用以下逻辑决定要使用的资源：</p>
<ol>
<li><p>淘汰与设备配置冲突的资源文件。</p>
</li>
<li><p>选择列表中（下一个）优先级最高的限定符。（先从 MCC 开始，然后下移。）</p>
<p><img src="http://ouv36g1sw.bkt.clouddn.com/Android%20%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E6%9C%80%E4%BD%B3%E5%8C%B9%E9%85%8D%E8%B5%84%E6%BA%90%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE" alt="Android 如何查找最佳匹配资源的流程图"></p>
</li>
<li><p>是否有资源目录包括此限定符?</p>
<ul>
<li>若无，请返回到第 2 步，看看下一个限定符。（在该示例中，除非达到语言限定符，否则答案始终为“否”。）</li>
<li>若有，请继续执行第 4 步。</li>
</ul>
</li>
<li><p>淘汰不含此限定符的资源目录。在该示例中，系统会淘汰所有不含语言限定符的目录。(<strong>例外：</strong>如果涉及的限定符是屏幕像素密度，则 Android 会选择最接近设备屏幕密度的选项。通常，Android 倾向于缩小大型原始图像，而不是放大小型原始图像。请参阅<a href="https://developer.android.google.cn/guide/practices/screens_support.html" target="_blank" rel="noopener">支持多种屏幕</a>)。</p>
</li>
<li><p>返回并重复第 2 步、第 3 步和第 4 步，直到只剩下一个目录为止。在此示例中，屏幕方向是下一个判断是否匹配的限定符。因此，未指定屏幕方向的资源被淘汰：</p>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>尽管对所请求的每个资源均执行此程序，但是系统仍会对某些方面做进一步优化。 例如，系统一旦知道设备配置，即会淘汰可能永远无法匹配的备用资源。 比如说，如果配置语言是英语（“en”），则系统绝不会将语言限定符设置为非英语的任何资源目录包含在选中的资源池中（不过，仍会将不带语言限定符的资源目录包含在该池中）。</p>
<p>根据屏幕尺寸限定符选择资源时，如果没有更好的匹配资源，则系统将使用专为小于当前屏幕的屏幕而设计的资源（例如，如有必要，大尺寸屏幕将使用标准尺寸的屏幕资源）。 但是，如果唯一可用的资源大于当前屏幕，则系统<strong>不会</strong>使用这些资源，并且如果没有其他资源与设备配置匹配，应用将会崩溃（例如，如果所有布局资源均用 <code>xlarge</code> 限定符标记，但设备是标准尺寸的屏幕）。</p>
<p><strong>注</strong>：限定符的优先顺序（<a href="https://developer.android.google.cn/guide/topics/resources/providing-resources.html#table2" target="_blank" rel="noopener">表 2</a> 中）比与设备完全匹配的限定符数量更加重要。例如，在上面的第 4 步中，列表剩下的最后选项包括三个与设备完全匹配的限定符（方向、触摸屏类型和输入法），而 <code>drawable-en</code> 只有一个匹配参数（语言）。但是，语言的优先顺序高于其他两个限定符，因此<code>drawable-port-notouch-12key</code> 被淘汰。</p>
</blockquote>
<h1 id="Accessing-Resources访问资源"><a href="#Accessing-Resources访问资源" class="headerlink" title="Accessing Resources访问资源"></a>Accessing Resources访问资源</h1><blockquote>
<p>在应用中提供资源后（<a href="https://developer.android.google.cn/guide/topics/resources/providing-resources.html" target="_blank" rel="noopener">提供资源</a>中对此做了阐述），可通过引用其资源 ID 来应用该资源。 所有资源 ID 都在您项目的 <code>R</code> 类中定义，后者由 <code>aapt</code> 工具自动生成。</p>
<p>编译应用时，<code>aapt</code> 会生成 <code>R</code> 类，其中包含您的 <code>res/</code> 目录中所有资源的资源 ID。 每个资源类型都有对应的 <code>R</code>子类（例如，<code>R.drawable</code> 对应于所有可绘制对象资源），而该类型的每个资源都有对应的静态整型数（例如，<code>R.drawable.icon</code>）。这个整型数就是可用来检索资源的资源 ID。</p>
<p>尽管资源 ID 是在 <code>R</code> 类中指定的，但应该永远都不需要在其中查找资源 ID。</p>
</blockquote>
<ul>
<li>资源 ID 始终由以下部分组成：<ul>
<li><strong>资源类型</strong>：每个资源都被分到一个“类型”组中，例如 <code>string</code>、<code>drawable</code> 和 <code>layout</code>。</li>
<li><strong>资源名称</strong>，它是不包括扩展名的文件名；或是 XML <code>android:name</code> 属性中的值，如果资源是简单值的话（例如字符串）。</li>
</ul>
</li>
<li>访问资源的方法有两种：<ul>
<li><strong>在代码中：</strong>使用来自 <code>R</code> 类的某个子类的静态整型数，如：<code>R.string.hello</code></li>
<li><strong>在 XML 中：</strong>使用同样与您 <code>R</code> 类中定义的资源 ID 对应的特殊 XML 语法，如<code>@string/hello</code>。</li>
</ul>
</li>
</ul>
<p>##在代码中访问资源</p>
<ul>
<li><strong>语法</strong>：[&lt;package_name&gt;.]R.&lt;resource_type&gt;.&lt;resource_name&gt;<ul>
<li><em>&lt;package_name&gt;</em> 是资源所在包的名称（如果引用的资源来自您自己的资源包，则不需要）。</li>
<li><em>&lt;resource_type&gt;</em> 是资源类型的 <code>R</code> 子类。</li>
<li><em>&lt;resource_name&gt;</em> 是不带扩展名的资源文件名，或 XML 元素中的 <code>android:name</code> 属性值（如果资源是简单值）</li>
</ul>
</li>
<li><strong>用例</strong>：<code>getWindow().setBackgroundDrawableResource(R.drawable.my_background_image) ;</code></li>
</ul>
<h2 id="在-XML-中访问资源"><a href="#在-XML-中访问资源" class="headerlink" title="在 XML 中访问资源"></a>在 XML 中访问资源</h2><ul>
<li><p>利用对现有资源的引用为某些 XML 属性和元素定义值。</p>
</li>
<li><p><strong>语法：</strong>@[&lt;package_name&gt;:]&lt;resource_type&gt;/&lt;resource_name&gt;</p>
<ul>
<li><code>&lt;package_name&gt;</code> 是资源所在包的名称（如果引用的资源来自相同的包，则不需要）</li>
<li><code>&lt;resource_type&gt;</code> 是资源类型的 <code>R</code> 子类</li>
<li><code>&lt;resource_name&gt;</code> 是不带扩展名的资源文件名，或 XML 元素中的 <code>android:name</code> 属性值（如果资源是简单值）。</li>
</ul>
</li>
<li><p><strong>用例：</strong>在某些情况下，您必须使用资源作为 XML 中的值（例如，对小部件应用可绘制图像），但您也可以在 XML 中任何接受简单值的地方使用资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">   &lt;color name=&quot;opaque_red&quot;&gt;#f00&lt;/color&gt;</span><br><span class="line">   &lt;string name=&quot;hello&quot;&gt;Hello!&lt;/string&gt;</span><br><span class="line">&lt;/resources&gt;</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;EditText xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;fill_parent&quot;</span><br><span class="line">    android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">    android:textColor=&quot;@color/opaque_red&quot;</span><br><span class="line">    android:text=&quot;@string/hello&quot; /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>引用样式属性：</strong>通过样式属性资源在当前应用的风格主题中引用某个属性的值。 通过引用样式属性，可以不采用为 UI 元素提供硬编码值这种方式，而是通过为 UI 元素设置样式，使其匹配当前风格主题提供的标准变型来定制这些元素的外观。引用样式属性的实质作用是，“在当前风格主题中使用此属性定义的样式”。要引用样式属性，名称语法几乎与普通资源格式完全相同，只不过将 at 符号 (<code>@</code>) 改为问号 (<code>?</code>)，资源类型部分为可选项。 例如：</p>
<p><code>?&lt;package_name&gt;:/&lt;resource_name&gt;</code></p>
</li>
</ul>
<ul>
<li><h2 id="访问平台资源"><a href="#访问平台资源" class="headerlink" title="访问平台资源"></a>访问平台资源</h2><blockquote>
<p>Android 包含许多标准资源，例如样式、风格主题和布局。要访问这些资源，可以通过 <code>android</code> 包名称限定您的资源引用。例如，将 Android 提供的布局资源用于 <code>ListAdapter</code> 中的列表项：<code>setListAdapter(new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, myarray));</code></p>
</blockquote>
<h1 id="Handing-Runtime-Change处理运行时变更"><a href="#Handing-Runtime-Change处理运行时变更" class="headerlink" title="Handing Runtime Change处理运行时变更"></a>Handing Runtime Change处理运行时变更</h1><blockquote>
<p>有些设备配置可能会在运行时发生变化（例如屏幕方向、键盘可用性及语言）。发生这种变化时，Android 会重启正在运行的 <code>Activity</code>（先后调用 <code>onDestroy()</code> 和 <code>onCreate()</code>）。重启行为旨在通过利用与新设备配置匹配的备用资源自动重新加载您的应用，来帮助它适应新配置。</p>
<p>Activity必须通过常规的Activity生命周期恢复以前的状态，在Activity生命周期中，Android 会在销毁 Activity 之前调用 <code>onSaveInstanceState()</code>以保存有关应用的相关状态的数据。然后可以在 <code>onCreate()</code> 或 <code>onRestoreInstanceState()</code> 期间恢复 Activity 状态。</p>
<p>重启应用并恢复大量数据不仅成本高昂，而且用户体验并不好，所以可以选用以下方式进行配置变更：</p>
<ol>
<li><strong>在配置变更期间保留对象：</strong>允许 Activity 在配置变更时重启，但是要将有状态对象传递给 Activity 的新实例。</li>
<li><strong>自行处理配置变更：</strong>阻止系统在某些配置变更期间重启 Activity，但要在配置确实发生变化时接收回调，这样，就能够根据需要手动更新 Activity。</li>
</ol>
</blockquote>
<h2 id="在配置变更期保留对象"><a href="#在配置变更期保留对象" class="headerlink" title="在配置变更期保留对象"></a>在配置变更期保留对象</h2><blockquote>
<p>如果重启 Activity 需要恢复大量数据、重新建立网络连接或执行其他密集操作，那么因配置变更而引起的完全重启可能会给用户留下应用运行缓慢的体验。并且通过<code>onSaveInstanceState()</code> 回调为您保存的 <code>Bundle</code>，可能无法完全恢复 Activity 状态，因为它并非设计用于携带大型对象(例如位图等)，而且其中数据必须先序列化，在进行反序列化，这可能会消耗大量的内存使得配置变更时运行缓慢。 在这种情况下，如果 Activity 因配置变更而重启，则可通过保留 <code>Fragment</code> 来减轻重新初始化 Activity 的负担。此片段可能包含要保留的有状态对象的引用。</p>
</blockquote>
<ul>
<li><p>当 Android 系统因配置变更而关闭 Activity 时，不会销毁您已标记为要保留的 Activity 的片段。 可以将此类片段添加到 Activity 以保留有状态的对象。要在运行时配置变更期间将有状态的对象保留在片段中，请执行以下操作：</p>
<ol>
<li><p>扩展 <code>Fragment</code> 类并声明对有状态对象的引用。</p>
</li>
<li><p>在创建片段后调用 <code>setRetainInstance(boolean)</code>。</p>
</li>
<li><p>将片段添加到 Activity。</p>
</li>
<li><p>重启 Activity 后，使用 <code>FragmentManager</code> 检索片段。</p>
</li>
<li><p>代码示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class RetainedFragment extends Fragment &#123;</span><br><span class="line"></span><br><span class="line">    // data object we want to retain</span><br><span class="line">    private MyDataObject data;</span><br><span class="line"></span><br><span class="line">    // this method is only called once for this fragment</span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        // retain this fragment</span><br><span class="line">        setRetainInstance(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(MyDataObject data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyDataObject getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，使用 FragmentManager 将片段添加到 Activity。在运行时配置变更期间再次启动 Activity 时，可以获得片段中的数据对象。 例如，按如下方式定义 Activity：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class MyActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">    private RetainedFragment dataFragment;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.main);</span><br><span class="line"></span><br><span class="line">        // find the retained fragment on activity restarts</span><br><span class="line">        FragmentManager fm = getFragmentManager();</span><br><span class="line">        dataFragment = (DataFragment) fm.findFragmentByTag(“data”);</span><br><span class="line"></span><br><span class="line">        // create the fragment and data the first time</span><br><span class="line">        if (dataFragment == null) &#123;</span><br><span class="line">            // add the fragment</span><br><span class="line">            dataFragment = new DataFragment();</span><br><span class="line">            fm.beginTransaction().add(dataFragment, “data”).commit();</span><br><span class="line">            // load the data from the web</span><br><span class="line">            dataFragment.setData(loadMyData());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // the data is available in dataFragment.getData()</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// onCreate() 添加了一个片段或恢复了对它的引用。onCreate() 还将有状态的对象存储在片段实例内部。</span><br><span class="line">// onDestroy() 对所保留的片段实例内的有状态对象进行更新</span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        // store the data in the fragment</span><br><span class="line">        dataFragment.setData(collectMyLoadedData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>注意：**尽管您可以存储任何对象，但是切勿传递与 <code>Activity</code> 绑定的对象，例如，<code>Drawable</code>、<code>Adapter</code>、<code>View</code> 或其他任何与 <code>Context</code> 关联的对象。否则，它将泄漏原始 Activity 实例的所有视图和资源。 （泄漏资源意味着应用将继续持有这些资源，但是无法对其进行垃圾回收，因此可能会丢失大量内存。）</p>
</li>
</ol>
</li>
</ul>
<h2 id="自行变更配置"><a href="#自行变更配置" class="headerlink" title="自行变更配置"></a>自行变更配置</h2><ul>
<li>自行处理配置变更可能导致备用资源的使用更为困难，因为系统不会为您自动应用这些资源。 只能在必须避免 Activity 因配置变更而重启这一万般无奈的情况下，才考虑采用自行处理配置变更这种方法，而且对于大多数应用并不建议使用此方法。</li>
</ul>
</li>
</ul>
<ul>
<li><p>要声明由 Activity 处理配置变更，请在清单文件中编辑相应的<activity>元素，以包含 <a href="https://developer.android.google.cn/guide/topics/manifest/activity-element.html#config" target="_blank" rel="noopener"><code>android:configChanges</code></a> 属性以及代表要处理的配置的值。<a href="https://developer.android.google.cn/guide/topics/manifest/activity-element.html#config" target="_blank" rel="noopener"><code>android:configChanges</code></a> 属性的文档中列出了该属性的可能值（最常用的值包括 <code>&quot;orientation&quot;</code> 和 <code>&quot;keyboardHidden&quot;</code>，分别用于避免因屏幕方向和可用键盘改变而导致重启）。可以在该属性中声明多个配置值，方法是用管道 <code>|</code> 字符分隔这些配置值。例如：</activity></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=&quot;.MyActivity&quot;</span><br><span class="line">          android:configChanges=&quot;orientation|keyboardHidden&quot;</span><br><span class="line">          android:label=&quot;@string/app_name&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>当其中一个配置发生变化时，<code>MyActivity</code> 不会重启。相反，<code>MyActivity</code> 会收到对 <code>onConfigurationChanged()</code> 的调用。向此方法传递<code>Configuration</code> 对象指定新设备配置。可以通过读取 <code>Configuration</code> 中的字段，确定新配置，然后通过更新界面中使用的资源进行适当的更改。调用此方法时，Activity 的 <code>Resources</code> 对象会相应地进行更新，以根据新配置返回资源，就能够在系统不重启 Activity 的情况下轻松重置 UI 的元素。</p>
<blockquote>
<p><strong>注意：</strong>从 Android 3.2（API 级别 13）开始，当设备在纵向和横向之间切换时，<strong>“屏幕尺寸”也会发生变化</strong>。因此，在开发针对 API 级别 13 或更高版本（正如 <a href="https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element.html#min" target="_blank" rel="noopener"><code>minSdkVersion</code></a> 和 <a href="https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element.html#target" target="_blank" rel="noopener"><code>targetSdkVersion</code></a> 属性中所声明）的应用时，若要避免由于设备方向改变而导致运行时重启，则除了 <code>&quot;orientation&quot;</code> 值以外，还必须添加 <code>&quot;screenSize&quot;</code> 值。 即必须声明 <code>android:configChanges=&quot;orientation|screenSize&quot;</code>。</p>
</blockquote>
</li>
<li><p><code>Configuration</code> 对象代表所有当前配置，而不仅仅是已经变更的配置。不用关注配置具体发生了哪些变更，就可以轻松地重新分配所有资源，为正在处理的配置提供备用资源。 例如，由于 <code>Resources</code> 对象现已更新，因此您可以通过 <code>setImageResource()</code> 重置任何 <code>ImageView</code>，并且使用适合于新配置的资源。</p>
<blockquote>
<p><strong>注意：</strong>在声明由 Activity 处理配置变更时，应重置要为其提供备用资源的所有元素。 如果声明由 Activity 处理方向变更，而且有些图像应该在横向和纵向之间切换，则必须在 <code>onConfigurationChanged()</code> 期间将每个资源重新分配给每个元素。</p>
</blockquote>
</li>
</ul>
<p>#App Manifest File应用清单</p>
<blockquote>
<p>每个应用的根目录中都必须包含一个 <code>AndroidManifest.xml</code> 文件（且文件名精确无误）。 清单文件向 Android 系统提供应用的必要信息，系统必须具有这些信息方可运行应用的任何代码。</p>
<p>清单文件作用：</p>
<ul>
<li>为应用的 Java 软件包命名。软件包名称充当应用的唯一标识符。</li>
<li>描述应用的各个组件，包括构成应用的 Activity、服务、广播接收器和内容提供程序。它还为实现每个组件的类命名并发布其功能，例如它们可以处理的 <code>Intent</code> 消息。这些声明向 Android 系统告知有关组件以及可以启动这些组件的条件的信息。</li>
<li>确定托管应用组件的进程。</li>
<li>声明应用必须具备哪些权限才能访问 API 中受保护的部分并与其他应用交互。还声明其他应用与该应用组件交互所需具备的权限</li>
<li>列出 <code>Instrumentation</code> 类，这些类可在应用运行时提供分析和其他信息。这些声明只会在应用处于开发阶段时出现在清单中，在应用发布之前将移除。</li>
<li>声明应用所需的最低 Android API 级别</li>
<li>列出应用必须链接到的库</li>
</ul>
</blockquote>
<h2 id="清单文件结构"><a href="#清单文件结构" class="headerlink" title="清单文件结构"></a>清单文件结构</h2><ul>
<li><code>&lt;action&gt;</code></li>
<li><code>&lt;activity&gt;</code></li>
<li><code>&lt;activity-alias&gt;</code></li>
<li><code>&lt;application&gt;</code></li>
<li><code>&lt;category&gt;</code></li>
<li><code>&lt;data&gt;</code></li>
<li><code>&lt;grant-uri-permission&gt;</code></li>
<li><code>&lt;instrumentation&gt;</code></li>
<li><code>&lt;intent-filter&gt;</code></li>
<li><code>&lt;manifest&gt;</code></li>
<li><code>&lt;meta-data&gt;</code></li>
<li><code>&lt;permission&gt;</code></li>
<li><code>&lt;permission-group&gt;</code></li>
<li><code>&lt;permission-tree&gt;</code></li>
<li><code>&lt;provider&gt;</code></li>
<li><code>&lt;receiver&gt;</code></li>
<li><code>&lt;service&gt;</code></li>
<li><code>&lt;supports-screens&gt;</code></li>
<li><code>&lt;uses-configuration&gt;</code></li>
<li><code>&lt;uses-feature&gt;</code></li>
<li><code>&lt;uses-library&gt;</code></li>
<li><code>&lt;uses-permission&gt;</code></li>
<li><code>&lt;uses-sdk&gt;</code></li>
</ul>
<p>##文件约定</p>
<ul>
<li><p><strong>元素：</strong></p>
<ul>
<li>只有 <code>&lt;manifest&gt;</code> 和 <code>&lt;application&gt;</code> 元素是必需的，它们都必须存在并且只能出现一次。其他大部分元素可以出现多次或者根本不出现。但清单文件中必须至少存在其中某些元素才有用。</li>
<li>如果一个元素包含某些内容，也就包含其他元素。所有值均通过属性进行设置，而不是通过元素内的字符数据设置。</li>
<li>同一级别的元素通常不分先后顺序。例如，<code>&lt;activity&gt;</code>、<code>&lt;provider&gt;</code> 和 <code>&lt;service&gt;</code> 元素可以按任何顺序混合在一起。这条规则有两个主要例外：<ul>
<li><code>&lt;activity-alias&gt;</code> 元素必须跟在别名所指的 <code>&lt;activity&gt;</code> 之后。</li>
<li><code>&lt;application&gt;</code> 元素必须是 <code>&lt;manifest&gt;</code> 元素内最后一个元素。换言之，<code>&lt;/manifest&gt;</code> 结束标记必须紧接在 <code>&lt;/application&gt;</code> 结束标记后。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>属性：</strong></p>
<ul>
<li>从某种意义上说，所有属性都是可选的。但是，必须指定某些属性，元素才可实现其目的。请使用本文档作为参考。对于真正可选的属性，它将指定默认值或声明缺乏规范时将执行何种操作。</li>
<li>除了根 <code>&lt;manifest&gt;</code> 元素的一些属性外，所有属性名称均以 <code>android:</code> 前缀开头。例如，<code>android:alwaysRetainTaskState</code>。由于该前缀是通用的，因此在按名称引用属性时，本文档通常会将其忽略。</li>
</ul>
</li>
<li><p><strong>声明类名：</strong></p>
<ul>
<li><p>许多元素对应于 Java 对象，包括应用本身的元素（<code>&lt;application&gt;</code> 元素）及其主要组件：Activity (<code>&lt;activity&gt;</code>)、服务 (<code>&lt;service&gt;</code>)、广播接收器 (<code>&lt;receiver&gt;</code>) 以及内容提供程序 (<code>&lt;provider&gt;</code>)。</p>
</li>
<li><p>若针对组件类（<code>Activity</code>、<code>Service</code> 和 <code>BroadcastReceiver`</code>ContentProvider<code>）几乎一直采用的方式来定义子类，则该子类需通过</code>name<code>属性来声明。该名称必须包含完整的软件包名称。例如，</code>Service` 子类可能会声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest . . . &gt;</span><br><span class="line">    &lt;application . . . &gt;</span><br><span class="line">        &lt;service android:name=&quot;com.example.project.SecretService&quot; . . . &gt;</span><br><span class="line">            . . .</span><br><span class="line">        &lt;/service&gt;</span><br><span class="line">        . . .</span><br><span class="line">    &lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果字符串的第一个字符是句点，则应用的软件包名称（如 <code>&lt;manifest&gt;</code> 元素的 <code>package</code> 属性所指定）将附加到该字符串。以下赋值与上述方法相同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest package=&quot;com.example.project&quot; . . . &gt;</span><br><span class="line">    &lt;application . . . &gt;</span><br><span class="line">        &lt;service android:name=&quot;.SecretService&quot; . . . &gt;</span><br><span class="line">            . . .</span><br><span class="line">        &lt;/service&gt;</span><br><span class="line">        . . .</span><br><span class="line">    &lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当启动组件时，Android 系统会创建已命名子类的实例。如果未指定子类，则会创建基类的实例。</p>
</li>
</ul>
</li>
<li><p><strong>多个值：</strong>如果可以指定多个值，则几乎总是在重复此元素，而不是列出单个元素内的多个值。</p>
</li>
<li><p><strong>资源值：</strong>某些属性的值可以显示给用户，例如，Activity 的标签和图标。这些属性的值应该本地化，并通过资源或主题进行设置。资源值用以下格式表示：<code>@[&lt;i&gt;package&lt;/i&gt;:]&lt;i&gt;type&lt;/i&gt;/&lt;i&gt;name&lt;/i&gt;。</code>如果资源与应用在同一个软件包中，可以省略<em>软件包</em>名称。</p>
</li>
<li><p><strong>字符串值：</strong>如果属性值为字符串，则必须使用双反斜杠 (\) 转义字符，例如，使用 \n 表示换行符或使用 \uxxxx 表示 Unicode 字符。</p>
</li>
</ul>
<h2 id="文件功能"><a href="#文件功能" class="headerlink" title="文件功能"></a>文件功能</h2><ul>
<li><p><strong>Intent过滤器</strong></p>
<ul>
<li>应用核心组件（例如其 Activity、服务和广播接收器）由 <em>intent</em> 激活。Intent 是一系列用于描述所需操作的信息（<code>Intent</code> 对象），其中包括要执行操作的数据、应执行操作的组件类别以及其他相关说明。Android 系统会查找合适的组件来响应 intent，根据需要启动组件的新实例，并将其传递到 <code>Intent</code> 对象。</li>
<li>组件将通过 <em>intent 过滤器</em>公布它们可响应的 intent 类型。由于Android 系统在启动某组件之前必须了解该组件可以处理的 intent，因此 intent 过滤器在清单中被指定为 <code>&lt;intent-filter&gt;</code> 元素。一个组件可有任意数量的过滤器，其中每个过滤器描述一种不同的功能。</li>
<li>显式命名目标组件的 intent 将激活该组件，因此过滤器不起作用。不按名称指定目标的 intent 只有在能够通过组件的一个过滤器时才可激活该组件。</li>
</ul>
</li>
<li><p><strong>图标和标签</strong></p>
<ul>
<li>对于可以显示给用户的小图标和文本标签，大量元素具有 <code>icon</code> 和 <code>label</code> 属性。此外，对于同样可以显示在屏幕上的较长说明文本，某些元素还具有 <code>description</code> 属性。例如，<code>&lt;permission&gt;</code> 元素具有所有这三个属性。因此，当系统询问用户是否授权给请求获得权限的应用时，权限图标、权限名称以及所需信息的说明均会呈现给用户。</li>
<li>无论何种情况下，在包含元素中设置的图标和标签都将成为所有容器子元素的默认 <code>icon</code> 和 <code>label</code> 设置。因此，在 <code>&lt;application&gt;</code> 元素中设置的图标和标签是每个应用组件的默认图标和标签。同样，为组件（例如 <code>&lt;activity&gt;</code> 元素）设置的图标和标签是组件每个 <code>&lt;intent-filter&gt;</code> 元素的默认设置。如果 <code>&lt;application&gt;</code> 元素设置标签，但是 Activity 及其 intent 过滤器不执行此操作，则应用标签将被视为 Activity 和 intent 过滤器的标签。</li>
<li>在实现过滤器公布的功能时，只要向用户呈现组件，系统便会使用为 intent 过滤器设置的图标和标签表示该组件。例如，具有 <code>android.intent.action.MAIN</code> 和 <code>android.intent.category.LAUNCHER</code> 设置的过滤器将 Activity 公布为可启动应用的功能，即，公布为应显示在应用启动器中的功能。在过滤器中设置的图标和标签显示在启动器中。</li>
</ul>
</li>
<li><p><strong>权限</strong></p>
<ul>
<li><p>权限是一种限制，用于限制对部分代码或设备上数据的访问。施加限制是为了保护可能被误用以致破坏或损害用户体验的关键数据和代码。每种权限均由一个唯一的标签标识。标签通常指示受限制的操作。以下是 Android 定义的一些权限：</p>
<ul>
<li><code>android.permission.CALL_EMERGENCY_NUMBERS</code></li>
<li><code>android.permission.READ_OWNER_DATA</code></li>
<li><code>android.permission.SET_WALLPAPER</code></li>
<li><code>android.permission.DEVICE_POWER</code></li>
</ul>
</li>
<li><p>如果应用需要访问受权限保护的功能，则必须在清单中使用 <code>&lt;uses-permission&gt;</code> 元素声明应用需要该权限。将应用安装到设备上之后，安装程序会通过检查签署应用证书的颁发机构并（在某些情况下）询问用户，确定是否授予请求的权限。如果授予权限，则应用能够使用受保护的功能。否则，其访问这些功能的尝试将会失败，并且不会向用户发送任何通知。</p>
</li>
<li><p>应用也可以使用权限保护自己的组件。它可以采用由 Android 定义（如 <code>android.Manifest.permission</code> 中所列）或由其他应用声明的任何权限。它也可以定义自己的权限。</p>
<p>​</p>
</li>
</ul>
</li>
<li><p><strong>库</strong></p>
<ul>
<li>每个应用均链接到默认的 Android 库，该库中包括用于开发应用（以及通用类，如 Activity、服务、intent、视图、按钮、应用、ContentProvider）的基本软件包。</li>
<li>某些软件包驻留在自己的库中。如果应用使用来自其中任一软件包的代码，则必须明确要求其链接到这些软件包。清单必须包含单独的 <code>&lt;uses-library&gt;</code> 元素来命名其中每个库。库名称可在软件包的文档中找到。</li>
</ul>
</li>
</ul>
<h1 id="App-Permissions应用权限"><a href="#App-Permissions应用权限" class="headerlink" title="App Permissions应用权限"></a>App Permissions应用权限</h1><blockquote>
<p>为了维护系统和用户的安全，Android需要应用程序在使用特定系统数据和功能之前声明所需的权限。根据区域的敏感程度，系统可能会自动授予权限，或者可能会要求用户批准该请求。</p>
</blockquote>
<h2 id="权限概述"><a href="#权限概述" class="headerlink" title="权限概述"></a>权限概述</h2><blockquote>
<p>权限需要许可的目的是保护Android用户的隐私。 Android应用程序必须请求访问敏感用户数据（如联系人和短信）以及某些系统功能（如相机和互联网）的权限。根据功能的不同，系统可能会自动授予权限，或者可能会提示用户批准请求。这里介绍的内容包括：如何向用户显示权限，安装时间和运行时权限请求之间的区别，权限的执行方式以及权限和权限组的权限类型。</p>
</blockquote>
<h3 id="权限许可"><a href="#权限许可" class="headerlink" title="权限许可"></a>权限许可</h3><ul>
<li>应用必须在清单文件中使用<code>&lt;uses-prmission&gt;</code>标签声明所需要的权限，若应用在其清单中列出了正常权限（即，对用户的隐私或设备操作不构成风险的权限），系统会自动将这些权限授予给应用。但是若应用在其清单中列出了危险权限（即可能影响用户隐私或设备正常运行的权限），如SEND_SMS权限，则用户必须明确同意授予这些权限。</li>
<li>危险权限获取<ul>
<li>运行时请求授予危险权限（Android6.0及以上）：<ul>
<li>如果设备运行的是Android 6.0（API级别23）或更高版本，并且该应用的targetSdkVersion为23或更高，则安装时用户不会收到任何应用权限的通知。应用程序必须要求用户在运行时授予危险权限。当应用程序请求权限时，用户会看到一个系统对话框，告诉用户您的应用尝试访问哪个权限组。该对话框包含拒绝和允许按钮。</li>
<li>如果用户拒绝权限请求，则在应用下次请求权限时，该对话框将包含一个复选框，该复选框在选中后表示用户不会再次被要求提供权限。如果用户选中永不再问框并点击拒绝，如果稍后尝试请求相同的权限，则系统将不再提示用户。</li>
<li>即使用户向应用程序授予您所请求的权限，但是用户还可以选择在系统设置中逐个启用和禁用权限，因此还是应该始终在运行时检查并请求权限以防止运行时错误（SecurityException）。</li>
</ul>
</li>
<li>安装时获取权限（Android5.1.1及以下）<ul>
<li>如果设备运行Android 5.1.1（API级别22）或更低，或者应用程序的targetSdkVersion为22或更低，则系统会自动要求用户在安装时为应用授予所有危险权限。</li>
<li>在安装时用户如果拒绝授予这些危险权限那么将无法安装应用，如果应用程序更新包含对额外权限的需求，则会在更新应用程序之前提示用户接受这些新权限。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="硬件权限"><a href="#硬件权限" class="headerlink" title="硬件权限"></a>硬件权限</h3><ul>
<li><p>访问某些硬件功能（例如蓝牙或相机）需要应用程序许可。但并非所有的Android设备都具备这些硬件功能。因此，如果应用请求CAMERA权限，则还必须在清单中包含<uses-feature>标记以声明该功能是否实际需要。</uses-feature></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-feature android:name=&quot;android.hardware.camera&quot; android:required=&quot;false&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>如果您为该功能声明了android：required =“false”，则Google Play允许应用安装在没有此功能的设备上。然后，必须通过调用PackageManager.hasSystemFeature（）来检查当前设备是否在运行时具有该功能，并在不可用时正常禁用该功能。</p>
</li>
<li><p>如果您提供<uses-feature>标记，那么当Google Play发现应用请求相应的权限时，它会假定应用需要此功能。因此，它会在没有此功能的设备上过滤您的应用，就像您在<uses-feature>标记中声明了android：required =“true”一样。</uses-feature></uses-feature></p>
</li>
</ul>
<h3 id="声明权限"><a href="#声明权限" class="headerlink" title="声明权限"></a>声明权限</h3><blockquote>
<p>权限不仅用于请求系统功能。应用程序提供的服务可以执行自定义权限，以限定可使用它们的对象。</p>
</blockquote>
<ul>
<li><strong>Activity权限声明：</strong>在应用清单文件<activity>标签中使用android：permission权限属性，限定可以启动该Activity的Activity。在Context.startActivity()和Activity.startActivityForResult()中检查权限。如果调用者没有所需的权限，则会在调用时调抛出SecurityException；</activity></li>
<li><strong>Service权限声明：</strong>在应用清单文件<service>标签中使用android：permission权限属性，限定可以启动或绑定到关联的Service的对象。在Context.startService()，Context.stopService()和Context.bindService()中检查权限。如果调用者没有所需的权限，则会在调用时调抛出SecurityException；</service></li>
<li><strong>Braodcast权限声明：</strong><ul>
<li>在应用清单文件<receiver>标签中使用android：permission权限属性，限定可以将广播发送到关联的BroadcastReceiver的对象。在Context.sendBroadcast()返回后检查权限，因为系统试图将提交的广播传送给指定的接收者。因此，权限不足导致的调用失败不会导致异常并抛回给调用者。</receiver></li>
<li>以同样的方式，可以向Context.registerReceiver()提供权限，以限制向以代码注册的接收者进行广播的广播。换句话说，当调用Context.sendBroadcast（）可以使用权限来限制哪些广播接收器可以接收广播。在接收者和广播者都需要获得权限时，必须通过权限检查才能将意图传递到关联的目标。</li>
</ul>
</li>
<li><strong>Content Provider权限声明：</strong><ul>
<li>在应用清单文件<provider>标签中使用android：permission权限属性，限定可以访问ContentProvider中的数据的对象（内容提供者有一个重要的额外的安全机制也就是URI权限）。与其他组件不同，应用可以设置两个单独的权限属性：android:readPermission限制谁可以从提供者读取，而android: writePermission限制谁可以写入它。如果提供者受到读写权限的保护，只保留写权限并不意味着可以从提供者读取。</provider></li>
<li>当首次检索提供程序时（如果没有任何权限，会引发SecurityException）并在对提供程序执行时检查权限。使用ContentResolver.query()需要保持读取权限;使用ContentResolver.insert()，ContentResolver.update()，ContentResolver.delete()需要写入权限。在所有这些情况下，不保留所需的权限会导致SecurityException从。</li>
</ul>
</li>
<li><strong>URI权限 ：</strong><ul>
<li>目前权限机制并不能完全满足Content Provider的需求。内容提供者希望通过读写权限来保护自己，而客户端也需要将特定的URI传递给其他应用程序供他们操作。例如电子邮件程序中的附件，因为设计到敏感的用户数据，访问电子邮件受到权限保护。但是，如果将图像附件的URI提供给图像查看器，则该图像查看器不再具有打开附件的权限，因为它没有理由持有访问所有电子邮件的权限。</li>
<li>此问题的解决方案是每个URI权限：在启动活动或将结果返回给活动时，调用者可以设置Intent.FLAG_GRANT_READ_URI_PERMISSION和/或Intent.FLAG_GRANT_WRITE_URI_PERMISSION。这允许接收活动权限访问意图中的特定数据URI，而不管其是否具有访问与意图相对应的内容提供者中的数据的任何权限。</li>
<li>这种机制允许一种通用的能力风格模型，在这种模型中，用户交互（例如打开附件或从列表中选择联系人）驱动临时授予细化权限。这可能是将应用程序所需的权限仅限于与其行为直接相关的权限的关键工具。要构建使其他应用程序对您的应用程序负责的最安全的实现，应该以这种方式使用细化的权限，并使用android:grantUriPermissions属性或<grant-uri-permissions>标签声明您的应用程序的支持。</grant-uri-permissions></li>
</ul>
</li>
<li><strong>其他权限声明：</strong><ul>
<li>任何调用服务时都可以强制任意细化权限。这是通过Context.checkCallingPermission()方法完成的。使用所需的权限字符串进行调用，并返回一个整数，指示该权限是否已授予当前经常调用。请注意，只有当您执行从另一个进程调用的调用时（通常是通过从服务发布的IDL接口或以其他方式向另一个进程发送的调用），才可以使用它。</li>
<li>还有许多其他有用的方法来检查权限。如果应用拥有另一个进程的进程ID（PID），则可以使用Context.checkPermission()方法检查针对该PID的权限。如果拥有其他应用的软件包名称，则可以使用PackageManager.checkPermission()方法来确定该特定软件包是否已被授予特定权限。</li>
</ul>
</li>
</ul>
<h3 id="权限自动调整"><a href="#权限自动调整" class="headerlink" title="权限自动调整"></a>权限自动调整</h3><ul>
<li>随着Android的更新，系统可能会某些API增加的限制，因此应用可能需要获取之前不需要的权限。由于应用之前对这些API的访问是不需要相应权限直接访问的，因此Android会将新的权限直接添加到清单文件，以避免在新版本的Android系统中应用的崩溃。Android会根据targetSdkVersion属性的值来确定应用是否需要添加权限。</li>
<li>如果应用自动添加了权限，那么即使您的应用实际上不需要它们，Google Play上的应用列表也会列出这些附加权限。为了避免这种情况并移除不需要的权限，请始终将targetSdkVersion更新为尽可能高。可在Build.VERSION_CODES文档中看到每个版本添加了哪些权限。</li>
</ul>
<h3 id="权限保护级别"><a href="#权限保护级别" class="headerlink" title="权限保护级别"></a>权限保护级别</h3><blockquote>
<p>权限分为几个保护级别。保护级别影响是否需要运行时权限请求。有三个保护级别会影响第三方应用程序：正常，签名和危险权限。</p>
</blockquote>
<ul>
<li><strong>普通权限</strong><ul>
<li>普通权限包括应用程序需要访问应用程序沙箱外的数据或资源，该访问操作对用户的隐私或其他应用程序的风险很小。例如，设置时区的权限是普通权限。</li>
<li>如果应用程序在其清单中声明它需要正常许可，系统会在安装时自动授予应用程序该许可权。系统不会提示用户授予正常权限，并且用户无法撤消这些权限。</li>
<li>从Android8.1开始一下权限为普通权限：<ul>
<li><code>ACCESS_LOCATION_EXTRA_COMMANDS</code></li>
<li><code>ACCESS_NETWORK_STATE</code></li>
<li><code>ACCESS_NOTIFICATION_POLICY</code></li>
<li><code>ACCESS_WIFI_STATE</code></li>
<li><code>BLUETOOTH</code></li>
<li><code>BLUETOOTH_ADMIN</code></li>
<li><code>BROADCAST_STICKY</code></li>
<li><code>CHANGE_NETWORK_STATE</code></li>
<li><code>CHANGE_WIFI_MULTICAST_STATE</code></li>
<li><code>CHANGE_WIFI_STATE</code></li>
<li><code>DISABLE_KEYGUARD</code></li>
<li><code>EXPAND_STATUS_BAR</code></li>
<li><code>GET_PACKAGE_SIZE</code></li>
<li><code>INSTALL_SHORTCUT</code></li>
<li><code>INTERNET</code></li>
<li><code>KILL_BACKGROUND_PROCESSES</code></li>
<li><code>MANAGE_OWN_CALLS</code></li>
<li><code>MODIFY_AUDIO_SETTINGS</code></li>
<li><code>NFC</code></li>
<li><code>READ_SYNC_SETTINGS</code></li>
<li><code>READ_SYNC_STATS</code></li>
<li><code>RECEIVE_BOOT_COMPLETED</code></li>
<li><code>REORDER_TASKS</code></li>
<li><code>REQUEST_COMPANION_RUN_IN_BACKGROUND</code></li>
<li><code>REQUEST_COMPANION_USE_DATA_IN_BACKGROUND</code></li>
<li><code>REQUEST_DELETE_PACKAGES</code></li>
<li><code>REQUEST_IGNORE_BATTERY_OPTIMIZATIONS</code></li>
<li><code>REQUEST_INSTALL_PACKAGES</code></li>
<li><code>SET_ALARM</code></li>
<li><code>SET_WALLPAPER</code></li>
<li><code>SET_WALLPAPER_HINTS</code></li>
<li><code>TRANSMIT_IR</code></li>
<li><code>USE_FINGERPRINT</code></li>
<li><code>VIBRATE</code></li>
<li><code>WAKE_LOCK</code></li>
<li><code>WRITE_SYNC_SETTINGS</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>签名权限</strong><ul>
<li>系统在安装时授予这些应用的权限，但仅当试图使用权限的应用程序由与定义权限的应用程序相同的证书签名时。</li>
<li>从Android 8.1（API级别27）开始，第三方应用程序可以使用的以下权限分类为PROTECTION_SIGNATURE：<ul>
<li><code>BIND_ACCESSIBILITY_SERVICE</code></li>
<li><code>BIND_AUTOFILL_SERVICE</code></li>
<li><code>BIND_CARRIER_SERVICES</code></li>
<li><code>BIND_CHOOSER_TARGET_SERVICE</code></li>
<li><code>BIND_CONDITION_PROVIDER_SERVICE</code></li>
<li><code>BIND_DEVICE_ADMIN</code></li>
<li><code>BIND_DREAM_SERVICE</code></li>
<li><code>BIND_INCALL_SERVICE</code></li>
<li><code>BIND_INPUT_METHOD</code></li>
<li><code>BIND_MIDI_DEVICE_SERVICE</code></li>
<li><code>BIND_NFC_SERVICE</code></li>
<li><code>BIND_NOTIFICATION_LISTENER_SERVICE</code></li>
<li><code>BIND_PRINT_SERVICE</code></li>
<li><code>BIND_SCREENING_SERVICE</code></li>
<li><code>BIND_TELECOM_CONNECTION_SERVICE</code></li>
<li><code>BIND_TEXT_SERVICE</code></li>
<li><code>BIND_TV_INPUT</code></li>
<li><code>BIND_VISUAL_VOICEMAIL_SERVICE</code></li>
<li><code>BIND_VOICE_INTERACTION</code></li>
<li><code>BIND_VPN_SERVICE</code></li>
<li><code>BIND_VR_LISTENER_SERVICE</code></li>
<li><code>BIND_WALLPAPER</code></li>
<li><code>CLEAR_APP_CACHE</code></li>
<li><code>MANAGE_DOCUMENTS</code></li>
<li><code>READ_VOICEMAIL</code></li>
<li><code>REQUEST_INSTALL_PACKAGES</code></li>
<li><code>SYSTEM_ALERT_WINDOW</code></li>
<li><code>WRITE_SETTINGS</code></li>
<li><code>WRITE_VOICEMAIL</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>危险权限</strong><ul>
<li>危险权限涵盖应用程序需要涉及用户私人信息的数据或资源的区域，或者可能会影响用户的存储数据或其他应用程序的操作。例如，阅读用户联系人的权限是危险的权限。如果一个应用程序声明它需要一个危险的权限，用户必须明确授予该应用程序的权限。在用户批准权限之前，应用无法提供取决于该权限的功能。要使用危险权限，应用必须提示用户在运行时授予权限。</li>
</ul>
</li>
<li><strong>特殊权限</strong><ul>
<li>有几个权限不具有正常和危险的权限。 SYSTEM_ALERT_WINDOW和WRITE_SETTINGS特别敏感，所以大多数应用程序不应该使用它们。如果应用程序需要这些权限之一，则必须在清单中声明权限，并发送请求用户授权的意图。系统通过向用户显示详细的管理屏幕来响应意图。</li>
</ul>
</li>
</ul>
<h3 id="权限组"><a href="#权限组" class="headerlink" title="权限组"></a>权限组</h3><blockquote>
<p>根据权限与之相关的功能权限被组织到权限组中。在此系统下，权限请求在组级别处理，并且单个权限组对应于应用清单中的多个权限声明。例如，SMS组包含READ_SMS和RECEIVE_SMS声明。以这种方式分组权限使用户能够做出更有意义和更明智的选择。</p>
</blockquote>
<ul>
<li><p>所有危险的Android权限都属于权限组。不管保护级别如何，任何权限都可以属于权限组。但是，如果权限是危险的，权限组只会影响用户体验。</p>
</li>
<li><p>如果设备运行的是Android 6.0（API级别23），并且该应用的targetSdkVersion为23或更高，则当您的应用请求危险权限时，以下系统行为适用：</p>
<ul>
<li>如果应用程序当前没有权限组的权限，系统会向描述该应用程序想要访问的权限组的用户显示权限请求对话框。该对话框没有描述该组内的特定权限。例如，如果某个应用程序请求READ_CONTACTS权限，则系统对话框只是表示应用程序需要访问该设备的联系人。如果用户同意，系统只给予应用程序许可。</li>
<li>如果应用程序已被授予同一权限组中的另一个危险权限，系统会立即授予权限，而不会与用户进行任何交互。例如，如果一个应用程序先前已经请求并被授予了READ_CONTACTS权限，并且它然后请求了WRITE_CONTACTS，则系统立即授予该权限而不向用户显示权限对话框。</li>
<li><strong>警告：</strong>未来版本的Android SDK可能会将特定权限从一个组移到另一个组。因此，不要将您的应用的逻辑基于这些权限组的结构。例如，从Android 8.1（API级别27）开始，READ_CONTACTS与WRITE_CONTACTS处于相同的权限组。如果应用程序请求READ_CONTACTS权限，然后请求WRITE_CONTACTS权限，请不要假定系统可以自动授予WRITE_CONTACTS权限。</li>
</ul>
</li>
<li><p>如果设备运行Android 5.1（API级别22）或更低，或者应用程序的targetSdkVersion为22或更低，则系统会要求用户在安装时授予权限。系统再一次告诉用户应用程序需要什么权限组，而不是个人权限。例如，当应用程序请求READ_CONTACTS时，安装对话框会列出联系人组。当用户接受时，只有READ_CONTACTS权限被授予应用程序。</p>
</li>
<li><p>危险的权限和权限组</p>
<p>| Permission Group | Permissions                                                  |<br>| —————- | :———————————————————– |<br>| <code>CALENDAR</code>       | <code>READ_CALENDAR</code>                                                                                                                                      <code>WRITE_CALENDAR</code> |<br>| <code>CAMERA</code>         | <code>CAMERA</code>                                                     |<br>| <code>CONTACTS</code>       | <code>READ_CONTACTS</code>                                                                                                                                       <code>WRITE_CONTACTS</code>                                                                                                                                             <code>GET_ACCOUNTS</code> |<br>| <code>LOCATION</code>       | <code>ACCESS_FINE_LOCATION</code>                                                                                                                      <code>ACCESS_COARSE_LOCATION</code> |<br>| <code>MICROPHONE</code>     | <code>RECORD_AUDIO</code>                                               |<br>| <code>PHONE</code>          | <code>READ_PHONE_STATE</code>                                                                                                                <code>READ_PHONE_NUMBERS</code>                                                                                                                 <code>CALL_PHONE</code>                                                                                                                     <code>ANSWER_PHONE_CALLS</code> (<em>must request at  runtime</em>)                                                                   <code>READ_CALL_LOG</code>                                                                                                                                                            <code>WRITE_CALL_LOG</code>                                                                                                                                                      <code>ADD_VOICEMAIL</code>                                                                                                                                <code>USE_SIP</code>                                                                                                                        <code>PROCESS_OUTGOING_CALLS</code>                                                                                                   <code>ANSWER_PHONE_CALLS</code> |<br>| <code>SENSORS</code>        | <code>BODY_SENSORS</code>                                               |<br>| <code>SMS</code>            | <code>SEND_SMS</code>                                                                                                                                 <code>RECEIVE_SMS</code>                                                                                                                                <code>READ_SMS</code>                                                                                                                                                    <code>RECEIVE_WAP_PUSH</code>                                                                                                                   <code>RECEIVE_MMS</code> |<br>| <code>STORAGE</code>        | <code>READ_EXTERNAL_STORAGE`</code>WRITE_EXTERNAL_STORAGE`              |</p>
</li>
</ul>
<h3 id="查看应用程序的权限"><a href="#查看应用程序的权限" class="headerlink" title="查看应用程序的权限"></a>查看应用程序的权限</h3><ul>
<li><p>可以使用Settings应用程序和shell命令adb shell pm列表权限查看系统中当前定义的所有权限。要使用设置应用，请转到设置&gt;应用。选择一个应用并向下滚动以查看该应用使用的权限。对于开发人员，adb’-s’选项以类似于用户看到它们的方式显示权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell pm list permissions -s</span><br><span class="line">All Permissions:</span><br><span class="line"></span><br><span class="line">Network communication: view Wi-Fi state, create Bluetooth connections, full</span><br><span class="line">internet access, view network state</span><br><span class="line"></span><br><span class="line">Your location: access extra location provider commands, fine (GPS) location,</span><br><span class="line">mock location sources for testing, coarse (network-based) location</span><br><span class="line"></span><br><span class="line">Services that cost you money: send SMS messages, directly call phone numbers</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以使用adb -g选项在模拟器或测试设备上安装应用程序时自动授予所有权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell install -g MyApp.apk</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="在运行时请求权限"><a href="#在运行时请求权限" class="headerlink" title="在运行时请求权限"></a>在运行时请求权限</h2><blockquote>
<p>从 Android 6.0（API 级别 23）开始，用户开始在应用运行时向其授予权限，而不是在应用安装时授予。此方法可以简化应用安装过程，因为用户在安装或更新应用时不需要授予权限。它还让用户可以对应用的功能进行更多控制；例如，用户可以选择为相机应用提供相机访问权限，而不提供设备位置的访问权限。用户可以随时进入应用的“Settings”屏幕调用权限。</p>
</blockquote>
<ul>
<li>系统权限分为两类：正常权限和危险权限<ul>
<li>正常权限不会直接给用户隐私权带来风险。如果应用在其清单中列出了正常权限，系统将自动授予该权限。</li>
<li>危险权限会授予应用访问用户机密数据的权限。如果列出了危险权限，则用户必须明确批准您的应用使用这些权限。</li>
</ul>
</li>
<li>在所有版本的 Android 中，您应用都需要在其应用清单中同时声明它需要的正常权限和危险权限，如声明权限中所述。不过，该声明的影响因系统版本和应用的目标 SDK 级别的不同而有所差异：<ul>
<li>如果设备运行的是 Android 5.1 或更低版本，或者应用的目标 SDK 为 22 或更低：如果您在清单中列出了危险权限，则用户必须在安装应用时授予此权限；如果他们不授予此权限，系统根本不会安装应用。</li>
<li>如果设备运行的是 Android 6.0 或更高版本，或者应用的目标 SDK 为 23 或更高：应用必须在清单中列出权限，并且它必须在运行时请求其需要的每项危险权限。用户可以授予或拒绝每项权限，且即使用户拒绝权限请求，应用仍可以继续运行有限的功能。</li>
<li>如果设备运行的是 Android 5.1 或更低版本，或者应用的目标 SDK 为 22 或更低：如果您清单中列出了危险权限，则用户必须在安装应用时授予此权限；如果他们不授予此权限，系统根本不会安装应用。</li>
<li>如果设备运行的是 Android 6.0 或更高版本，或者应用的目标 SDK 为 23 或更高：应用必须在清单中列出权限，<em>并且</em>它必须在运行时请求其需要的每项危险权限。用户可以授予或拒绝每项权限，且即使用户拒绝权限请求，应用仍可以继续运行有限的功能。</li>
</ul>
</li>
</ul>
<h3 id="检查权限"><a href="#检查权限" class="headerlink" title="检查权限"></a>检查权限</h3><ul>
<li><p>如果应用需要危险权限，则每次执行需要这一权限的操作时您都必须检查自己是否具有该权限。用户始终可以自由调用此权限。</p>
</li>
<li><p>要检查您是否具有某项权限，请调用 <code>ContextCompat.checkSelfPermission()</code> 方法。例如，以下代码段显示了如何检查 Activity 是否具有在日历中进行写入的权限：</p>
<p><code>int permissionCheck =ContextCompat.checkSelfPermission(thisActivity,Manifest.permission.WRITE_CALENDAR);</code></p>
<p>如果应用具有此权限，方法将返回 <code>PackageManager.PERMISSION_GRANTED</code>，并且应用可以继续操作。如果应用不具有此权限，方法将返回 <code>PERMISSION_DENIED</code>，且应用必须明确向用户要求权限</p>
</li>
</ul>
<h3 id="请求权限"><a href="#请求权限" class="headerlink" title="请求权限"></a>请求权限</h3><blockquote>
<p>如果应用需要应用清单中列出的危险权限，那么，它必须要求用户授予该权限。Android 为您提供了多种权限请求方式。调用这些方法将显示一个标准的 Android 对话框，不过，能对它们进行自定义。</p>
</blockquote>
<ul>
<li><p><strong>向用户解释需要权限的原因</strong></p>
<ul>
<li>在某些情况下，可能需要让用户了解您的应用为什么需要某项权限。例如，如果用户启动一个摄影应用，用户对应用要求使用相机的权限可能不会感到吃惊，但用户可能无法理解为什么此应用想要访问用户的位置或联系人。在请求权限之前，不妨为用户提供一个解释。请记住，不需要通过解释来说服用户；如果提供太多解释，用户可能发现应用令人失望并将其移除。</li>
<li>可以采用的一个方法是仅在用户已拒绝某项权限请求时提供解释。如果用户继续尝试使用需要某项权限的功能，但继续拒绝权限请求，则可能表明用户不理解应用为什么需要此权限才能提供相关功能。对于这种情况，比较好的做法是显示解释。</li>
<li>为了帮助查找用户可能需要解释的情形，Android 提供了一个实用程序方法，即 <code>shouldShowRequestPermissionRationale()</code>。如果应用之前请求过此权限但用户拒绝了请求，此方法将返回 <code>true</code>。如果用户在过去拒绝了权限请求，并在权限请求系统对话框中选择了 <strong>Don’t ask again</strong> 选项，此方法将返回 <code>false</code>。如果设备规范禁止应用具有该权限，此方法也会返回 <code>false</code>。</li>
</ul>
</li>
<li><p><strong>请求需要的权限</strong></p>
<ul>
<li><p>如果应用尚无所需的权限，则应用必须调用一个 <code>requestPermissions()</code> 方法，以请求权限。应用将传递其所需的权限，以及指定用于识别此权限请求的整型请求代码。此方法异步运行：它会立即返回，并且在用户响应对话框之后，系统会使用结果调用应用的回调方法，将应用传递的相同请求代码传递到 <code>requestPermissions()</code>。</p>
</li>
<li><p>例如，以下代码可以检查应用是否具备读取用户联系人的权限，并根据需要请求该权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Here, thisActivity is the current activity</span><br><span class="line">if (ContextCompat.checkSelfPermission(thisActivity,</span><br><span class="line">                Manifest.permission.READ_CONTACTS)</span><br><span class="line">        != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line"></span><br><span class="line">    // Should we show an explanation?</span><br><span class="line">    if (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity,</span><br><span class="line">            Manifest.permission.READ_CONTACTS)) &#123;</span><br><span class="line"></span><br><span class="line">        // Show an expanation to the user *asynchronously* -- don&apos;t block</span><br><span class="line">        // this thread waiting for the user&apos;s response! After the user</span><br><span class="line">        // sees the explanation, try again to request the permission.</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        // No explanation needed, we can request the permission.</span><br><span class="line"></span><br><span class="line">        ActivityCompat.requestPermissions(thisActivity,</span><br><span class="line">                new String[]&#123;Manifest.permission.READ_CONTACTS&#125;,</span><br><span class="line">                MY_PERMISSIONS_REQUEST_READ_CONTACTS);</span><br><span class="line"></span><br><span class="line">        // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an</span><br><span class="line">        // app-defined int constant. The callback method gets the</span><br><span class="line">        // result of the request.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注</strong>：当您的应用调用 <code>requestPermissions()</code> 时，系统将向用户显示一个标准对话框。应用无法配置或更改此对话框。如果需要为用户提供任何信息或解释，您应在调用 <code>requestPermissions()</code> 之前进行，如解释应用为什么需要权限中所述。</p>
</li>
</ul>
</li>
<li><p><strong>处理权限请求响应</strong></p>
<ul>
<li><p>当应用请求权限时，系统将向用户显示一个对话框。当用户响应时，系统将调用应用的 <code>onRequestPermissionsResult()</code> 方法，向其传递用户响应。应用必须重写改方法，以了解是否已获得相应权限。回调会将您传递的相同请求代码传递给 <code>requestPermissions()</code>。例如，如果应用请求 <code>READ_CONTACTS</code> 访问权限，则它可能采用以下回调方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onRequestPermissionsResult(int requestCode,</span><br><span class="line">        String permissions[], int[] grantResults) &#123;</span><br><span class="line">    switch (requestCode) &#123;</span><br><span class="line">        case MY_PERMISSIONS_REQUEST_READ_CONTACTS: &#123;</span><br><span class="line">            // If request is cancelled, the result arrays are empty.</span><br><span class="line">            if (grantResults.length &gt; 0</span><br><span class="line">                &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line"></span><br><span class="line">                // permission was granted, yay! Do the</span><br><span class="line">                // contacts-related task you need to do.</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                // permission denied, boo! Disable the</span><br><span class="line">                // functionality that depends on this permission.</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // other &apos;case&apos; lines to check for other</span><br><span class="line">        // permissions this app might request</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>系统显示的对话框说明了您的应用需要访问的权限组；它不会列出具体权限。例如，如果请求 <code>READ_CONTACTS</code> 权限，系统对话框只显示应用需要访问设备的联系人。用户只需要为每个权限组授予一次权限。如果应用请求该组中的任何其他权限（已在您的应用清单中列出），系统将自动授予应用这些权限。当请求此权限时，系统会调用 <code>onRequestPermissionsResult()</code> 回调方法，并传递 <code>PERMISSION_GRANTED</code>，如果用户已通过系统对话框明确同意您的权限请求，系统将采用相同方式操作。</p>
</li>
<li><p><strong>注</strong>：应用仍需要明确请求其需要的每项权限，即使用户已向应用授予该权限组中的其他权限。此外，权限分组在将来的 Android 版本中可能会发生变化。您的代码不应依赖特定权限属于或不属于相同组这种假设。</p>
<p>例如，假设应用清单中列出了 <code>READ_CONTACTS</code> 和 <code>WRITE_CONTACTS</code>。如果请求 <code>READ_CONTACTS</code> 且用户授予了此权限，那么，当请求 <code>WRITE_CONTACTS</code> 时，系统将立即授予您该权限，不会与用户交互。如果用户拒绝了某项权限请求，应用应采取适当的操作。例如，应用可能显示一个对话框，解释它为什么无法执行用户已经请求但需要该权限的操作。当系统要求用户授予权限时，用户可以选择指示系统不再要求提供该权限。这种情况下，无论应用在什么时候使用 <code>requestPermissions()</code> 再次要求该权限，系统都会立即拒绝此请求。系统会调用<code>onRequestPermissionsResult()</code> 回调方法，并传递 <code>PERMISSION_DENIED</code>，如果用户再次明确拒绝了应用的请求，系统将采用相同方式操作。这意味着当您调用 <code>requestPermissions()</code> 时，应用不能假设已经发生与用户的任何直接交互。</p>
</li>
</ul>
</li>
</ul>
<h2 id="权限请求示例"><a href="#权限请求示例" class="headerlink" title="权限请求示例"></a>权限请求示例</h2><blockquote>
<p>权限请求保护设备中可用的敏感信息，并且只能在访问信息对于您的应用的运行是必需的时才使用。权限请求示例提供了有关如何在不需要访问此类信息的情况下实现相同（或更好）功能的提示;</p>
</blockquote>
<h3 id="使用Android权限的原则"><a href="#使用Android权限的原则" class="headerlink" title="使用Android权限的原则"></a>使用Android权限的原则</h3><ol>
<li><strong>只使用应用程序工作所需的权限：</strong>因为可能有另一种方法可以满足您的需求（系统意图，标识符，电话背景），而无需依赖敏感信息。</li>
<li><strong>注意jar包所需要的权限：</strong>当你使用一个库时，应该清楚它所需要的权限以及权限的用途然后获取它所需要的权限。</li>
<li><strong>权限透明原则：</strong>进行权限请求时，应当告知用户获取权限的原因。使此信息与权限请求一起提供，包括安装，运行时或更新权限对话。</li>
<li><strong>确保系统访问清晰：</strong>当访问敏感功能（例如相机或麦克风）时，应在收集数据时提供连续请求以便清楚地向用户显示。</li>
</ol>
<h3 id="Android6-0的权限变更"><a href="#Android6-0的权限变更" class="headerlink" title="Android6.0的权限变更"></a>Android6.0的权限变更</h3><blockquote>
<p>Android 6.0 引入了一个新的权限策略，它允许应用程序在运行时向用户请求权限，而不是在安装之前。当应用程序实际需要受服务保护的服务或数据时，应用程序支持使用新的策略进行权限请求。虽然这不会（必然）改变整体应用程序行为，但它确实会引起敏感用户数据处理方式相关的一些更改。</p>
</blockquote>
<ul>
<li><strong>权限请求增加提示</strong>：在运行时，会在应用程序对话框中提示用户所使用的功能会涵盖那些权限以及权限组组。用户对请求权限的对话框中的提示很敏感，更重要的是，如果要求的权限与应用的目的不匹配，应该向用户提供详细的解释，说明为什么要求获取该权限;只要有可能，应该在请求时提供请求的解释，并在用户拒绝请求时在后续对话框中提供解释。</li>
<li><strong>授予权限的灵活性更大</strong>：用户可以在请求和设置时拒绝权限的授权，但当用户的操作或使用的功能因此而中断时。应用可以监控有多少用户拒绝权限，以便在重构时避免使用该权限，或者对为什么应用需要获得改权限才能正常工作提供更好的解释。还应该确保应用处理在用户拒绝权限请求或关闭设置中的权限时创建的异常。</li>
<li><strong>增加了操作负担</strong>：要求用户单独授予权限的访问权限，而不是一组权限。这对于最小化请求的权限数量非常重要，因为它增加了用户授予权限的操作负担，并增加了至少拒绝一个请求的可能性。</li>
</ul>
<h3 id="避免请求不必要的权限"><a href="#避免请求不必要的权限" class="headerlink" title="避免请求不必要的权限"></a>避免请求不必要的权限</h3><blockquote>
<p>每当您要求获得权限时，都会强制用户做出决定。应用应该尽量减少请求获取权限。如果用户运行的是Android 6.0（API级别23）或更高版本，则每次用户尝试一些需要权限的程序功能时，应用程序都必须使用权限请求中断用户的工作。如果用户正在运行早期版本的Android，则用户必须在安装应用程序时授予每个应用程序的权限;如果列表太长或看起来不合适，用户可能决定根本不安装您的应用程序。出于这些原因，应该尽量减少应用程序需要的权限数量。</p>
</blockquote>
<ul>
<li><strong>优先使用Intent</strong><ul>
<li>在很多情况下，应用可以选择两种方式执行任务。应用程序可以获取权限自己执行任务，也可以使用意图让另一个应用程序执行任务，这样就不必获取权限。<ul>
<li>例如，假设应用需要能够使用设备相机拍照。应用可以请求CAMERA权限，该权限允许应用直接访问摄像头。然后，应用将使用相机API来控制相机并拍摄照片。这种方法中应用完全控制摄影过程，并让摄像头UI整合到应用中。</li>
<li>但是，如果应用对访问用户数据的需求不频繁 ， 换句话说，每次需要访问数据时，用户都都会看到一个请求权限的对话框，这会严重影响用户的体验。应用可以使用基于意图的请求。 Android提供了一些应用程序可以在不需要权限的情况下使用的系统意图，因为用户选择在发出基于意图的请求时与应用程序共享什么（如果有的话）。例如，MediaStore.ACTION_IMAGE_CAPTURE或MediaStore.ACTION_VIDEO_CAPTURE的intent操作类型可用于获取图像或视频，而无需直接使用Camera对象（需要权限）。在这种情况下，每次捕获图像时，系统意图都会代表应用请求用户的许可。</li>
</ul>
</li>
<li>直接使用权限和使用Intent的优缺点：<ul>
<li><strong>使用权限：</strong><ul>
<li>执行操作时，应用可全面控制用户体验。但是，如此广泛的控制会增加代码的复杂性，因为需要设计合适的UI。</li>
<li>系统会在运行时或安装时提示用户授予一次权限（具体取决于用户的Android版本）。之后，应用可以执行操作，而无需用户进行额外的交互。但是，如果用户未授予权限（或稍后撤销权限），则应用程序将失去执行操作的能力。</li>
</ul>
</li>
<li><strong>使用Intent：</strong><ul>
<li>应用不必为操作设计UI。处理意图的应用程序提供UI。</li>
<li>用户可以使用他们的首选应用程序来完成任务。例如，用户可以选择最喜欢的照片应用拍照。</li>
<li>如果用户没有该操作的默认应用程序，系统会提示用户选择一个应用程序。如果用户没有指定默认处理程序，则每次执行操作时可能需要经过额外的对话框。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>不要让用户陷于频繁的请求处理</strong><ul>
<li>如果用户运行Android 6.0（API级别23）或更高版本，则用户必须在运行应用程序时授予您的应用程序权限。如果您一次性向用户提出大量权限请求，您可能会压倒用户并导致他们退出应用。</li>
<li>开发者应该根据需求去请求权限。在某些情况下，一个或多个权限可能对应用程序绝对是必不可少的。应用程序启动后立即要求提供所有这些权限可能很有意义。例如，如果制作摄影应用程序，该应用程序需要访问设备摄像头。当用户第一次启动应用程序时，用户会被要求获得使用相机的权限并不感到惊讶。但是，如果同一个应用程序还具有与用户的联系人共享照片的功能，那么在首次启动时，可能不应要求提供READ_CONTACTS权限。相反，请等到用户尝试使用“共享”功能并要求获得许可。</li>
<li>如果应用程序提供了教程，那么在教程序列结尾处请求应用程序的基本权限也是很容易让用户接受的。</li>
</ul>
</li>
<li><strong>多媒体应用失去焦点进入后台是暂停播放</strong><ul>
<li>应用程序在用户接到电话时进入后台并且失去焦点，并且只有在呼叫停止后才能重新调整焦点。在这些情况下的常见方法（例如媒体播放器在通话期间静音或暂停）是使用PhoneStateListener监听呼叫状态的更改或监听android.intent.action.PHONE_STATE的广播。该解决方案的问题在于它需要READ_PHONE_STATE权限，这会强制用户授予对各种敏感数据的访问权限，例如设备和SIM硬件ID以及来电的电话号码。</li>
<li>应用可以通过请求AudioFocus来避免此问题，因为它不需要明确权限（因为它不访问敏感信息）。只需将代码置于onAudioFocusChange()事件处理程序中所需的代码，并在操作系统移动其音频焦点时自动运行。</li>
</ul>
</li>
<li><strong>确定应用运行的设备标识</strong><ul>
<li>应用程序可能具有对特定设备的偏好或消息传递（例如，在服务器为用户保存设备特定的播放列表，以便用户可以为他们的汽车和家中有不同的播放列表）。一种常见的解决方案是利用设备标识符，例如设备IMEI，但这需要设备ID和呼叫信息权限组（M +中的PHONE）。它还使用无法重置并在所有应用程序之间共享的标识符。</li>
<li>使用这些类型的标识符有两种选择：<ul>
<li>使用com.google.android.gms.iid InstanceID API。 getInstance（上下文上下文）.getID()将为应用程序实例返回唯一的设备标识符。结果是一个应用程序实例作用域标识符，可以在存储有关应用程序的信息时用作键，并在用户重新安装应用程序时重置。</li>
<li>使用基本系统函数（如randomUUID()）创建属于应用程序存储空间的自己的标识符。</li>
</ul>
</li>
</ul>
</li>
<li><strong>为广告和用户分析功能创建唯一标识符</strong><ul>
<li>对于广告和用户分析功能，需要一个唯一标识符来为未登录应用的用户构建配置文件（例如，针对广告的用户定位定位或计算广告转化率）。</li>
<li>为广告和用户分析构建配置文件有时需要和其他应用程序共享的标识符。常见的解决方案涉及利用设备标识符，如设备IMEI，它需要设备ID和呼叫信息权限组（API级别23+中的PHONE），并且不能由用户重置。在任何这些情况下，除了使用不可重置的标识符并要求用户特殊的权限外，还将违反Play开发者计划政策。不幸的是，在这些情况下，使用com.google.android.gms.iid InstanceID API或系统函数来创建应用程序范围ID不是合适的解决方案，因为ID可能需要跨应用程序共享。另一种解决方案是通过getId()方法使用AdvertisingIdClient.Info类中的广告标识符。应用可以使用getAdvertisingIdInfo(Context)方法创建AdvertisingIdClient.Info对象，并调用getId()方法以使用标识符。注意这个方法是阻塞的，所以你不应该从主线程调用它;这个方法的详细解释可以在这里找到</li>
</ul>
</li>
<li><strong>了解应用使用的第三方库</strong><ul>
<li>应用中使用的库也需要权限。例如，广告和分析库可能需要访问位置或身份权限组才能实现所需的功能。但从用户的角度来看，权限请求来自你的应用程序，而不是库。</li>
<li>正如用户选择相同功能使用较少权限的应用程序一样，开发人员应该查看其库并选择未使用不必要权限的第三方SDK。例如，尝试避免需要身份权限组的库，除非存在明确的面向用户的原因，为什么应用程序需要这些权限。特别是，对于提供位置功能的库，请确保您不需要请求FINE_LOCATION权限，除非使用基于位置的定位功能。</li>
</ul>
</li>
<li><strong>解释为什么需要权限</strong><ul>
<li>调用requestPermissions()时系统显示的权限对话框表示应用需要什么权限，但没有说明原因。在某些情况下，用户可能会觉得令人费解的。因此在调用requestPermissions()之前需要向用户解释为什么你的应用程序需要权限。</li>
<li>如果仅使用属于某个权限组的API调用的一小部分，则有助于明确列出正在使用哪些权限以及原因。例如：<ul>
<li>如果只使用粗略位置，请让用户在应用说明中或在有关应用的帮助文章中了解这一点。</li>
<li>如果需要访问短信以接收验证码，以保护用户免遭欺诈，请让用户在应用说明中和/或第一次访问数据时了解相关信息。</li>
<li>注意：如果应用程序的适配版本是Android 8.0（API级别26）或更高，请不要请求READ_SMS权限作为验证用户凭据的一部分。相反，请使用createAppSpecificSmsToken()生成特定于应用程序的令牌，然后将此令牌传递给可发送验证SMS消息的其他应用程序或服务。</li>
</ul>
</li>
<li>让用户实时了解敏感数据访问也是有利的也是有利的。例如，如果应用正在访问摄像头或麦克风，最好让用户知道应用程序中某处的通知图标或通知托盘中的通知图标（如果应用程序在后台运行），这表示应用不是在偷偷手机用户数据。</li>
<li>如果需要申请在应用中制作某些内容的权限，但其原因尚不清楚，请找到让用户知道为什么需要最敏感的权限。</li>
</ul>
</li>
</ul>
<h3 id="测试两种权限模式"><a href="#测试两种权限模式" class="headerlink" title="测试两种权限模式"></a>测试两种权限模式</h3><blockquote>
<p>从 Android 6.0 开始，用户在应用运行时允许或者拒绝权限而不是在应用安装时，这导致你需要测试各种条件下app 的表现。在 Android 6.0之前，你可以合理假定你的 app 一直可运行，它拥有所有在 app manifest中声明的权限。在新的权限模式下，你不能这么认为了。</p>
</blockquote>
<ul>
<li><p>以下提示将帮助你验证 Android 6.0及以上系统的权限相关代码问题。</p>
<ul>
<li><p>验证 app 当前权限以及相关代码路径。</p>
</li>
<li><p>测试用户通过权限保护服务和数据。</p>
</li>
<li><p>测试多种权限分别被允许、拒绝的组合情况。比如，相机 app 可能在 manifest 文件中声明了<code>CAMERA</code> 、 <code>READ_CONTACTS</code> 和 <code>ACCESS_FINE_LOCATION</code> 权限。你应该测试每个权限打开和关闭的情况来确保 app 可以优雅地处理所有权限配置情况。记住，从 Android 6.0开始用户可以打开或关闭任意一个app的权限，即便是 targets API 在 22及以下的。</p>
</li>
<li><p>使用 adb 工具通过命令行管理权限：</p>
<ul>
<li><p>以组的形式列出权限和状态：</p>
<p><code>$ adb shell pm list permissions -d -g</code></p>
</li>
<li><p>允许或拒绝一个或多个权限：</p>
<p><code>$ adb shell pm [grant|revoke]</code></p>
</li>
</ul>
</li>
<li><p>为使用权限的服务分析 app</p>
</li>
</ul>
</li>
</ul>
<p>##自定义应用权限</p>
<blockquote>
<p>通过定义自定义权限，应用程序可以与其他应用程序共享其资源和功能。</p>
</blockquote>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote>
<p>Android是一个权限隔离的操作系统，每个应用程序都以不同的系统标识（Linux用户标识和组标识）运行，Linux将应用程序与系统隔离开来。应用可以通过定义权限(其他应用可以请求)来将自身功能展示给其他应用。并且还可以定义自动提供给任何其他使用相同证书签名的应用程序的权限。</p>
</blockquote>
<ul>
<li><strong>应用签名：</strong>所有APK必须使用其开发人员拥有私钥的证书进行签名。此证书标识应用的作者。证书不需要由证书颁发机构签名;对于Android应用程序来说，使用自签名证书是完全可以允许并常用的。 Android中证书的用途是区分应用作者。这允许系统授予或拒绝应用程序访问签名级别的权限，并授予或拒绝应用程序的请求获得与另一个应用程序相同的Linux身份。</li>
<li><strong>用户ID和文件访问权限：</strong>在安装时，Android系统为每个应用提供独有的Linux用户ID。应用在该设备的使用寿命中，应用身份保持不变（UID不变）。同一个软件包在不同的设备上，可能有不同的UID;重要的是每个软件包在给定设备上具有不同的UID。由于安全实施发生在流程级别，因此任何两个软件包的代码通常无法在同一进程中运行，因为它们需要以不同的Linux用户身份运行。您可以使用每个软件包的AndroidManifest.xml清单标记中的sharedUserId属性为它们分配相同的用户ID。通过这样做，这两个包将被视为同一个应用程序，并具有相同的用户标识和文件权限。请注意，为了保持安全性，只有两个使用相同签名签名（并请求相同sharedUserId）的应用将被赋予相同的用户ID。应用程序存储的任何数据都将被分配该应用程序的用户ID，而其他软件包通常无法访问该ID。</li>
</ul>
<h3 id="定义和执行权限"><a href="#定义和执行权限" class="headerlink" title="定义和执行权限"></a>定义和执行权限</h3><ol>
<li><p>要执行权限，首先必须在AndroidManifest.xml中使用一个或多个<permission>元素声明。</permission></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest</span><br><span class="line">  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">  package=&quot;com.example.myapp&quot; &gt;</span><br><span class="line">    </span><br><span class="line">    &lt;permission</span><br><span class="line">      android:name=&quot;com.example.myapp.permission.DEADLY_ACTIVITY&quot;</span><br><span class="line">      android:label=&quot;@string/permlab_deadlyActivity&quot;</span><br><span class="line">      android:description=&quot;@string/permdesc_deadlyActivity&quot;</span><br><span class="line">      android:permissionGroup=&quot;android.permission-group.COST_MONEY&quot;</span><br><span class="line">      android:protectionLevel=&quot;dangerous&quot; /&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>注意：除非所有应用都使用相同的签名证书，否则系统不允许多个应用声明具有相同名称的权限。如果应用声明了权限，则系统不允许用户安装具有相同权限名的其它应用，除非应用的签名证书相同。为避免命名冲突，建议为自定义权限使用反向域名式命名，如com.example.myapp.ENGAGE_HYPERSPACE。</p>
</li>
<li><p>必需的使用protectionLevel属性，来告诉系统如何向用户通知需要许可的应用程序，或者允许谁拥有该许可权。</p>
</li>
<li><p>可选择使用android:permissionGroup属性，来帮助系统向用户显示权限。在大多数情况下，应用应该将其设置为标准系统权限组（在android.Manifest.permission_group中列出），尽管可以自己定义一个组。最好使用现有组，因为这简化了向用户显示的权限UI。</p>
</li>
<li><p>应用需要提供标签和描述权限。这些是用户在查看权限列表（android:label）或单个权限（android:description）上的详细信息时可以看到的字符串资源。标签应该是简短的，用几句话来描述权限所保护的关键功能。描述应该是几个句子，描述应用获取权限做什么。我们的约定是一个两个句子的描述：第一个句子描述权限，第二个句子警告用户在应用程序被授予权限时可能出错的类型。以下CALL_PHONE权限的标签和说明示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;string name=&quot;permlab_callPhone&quot;&gt;directly call phone numbers&lt;/string&gt;</span><br><span class="line">&lt;string name=&quot;permdesc_callPhone&quot;&gt;Allows the app to call</span><br><span class="line">    phone numbers without your intervention. Malicious apps may</span><br><span class="line">    cause unexpected calls on your phone bill. Note that this does not</span><br><span class="line">    allow the app to call emergency numbers.&lt;/string&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><strong>创建一个权限组</strong><ul>
<li>应用可以使用android:permissionGroup属性来帮助系统向用户描述权限。在大多数情况下，会希望将其设置为标准系统组（在android.Manifest.permission_group中列出），但也可以使用<permission-group>定义自己的组。</permission-group></li>
<li><permission-group>元素为一组权限定义了一个标签 - 这两个标签都在清单中用<permission>元素声明并在别处声明。这仅影响将权限分配给用户时的分组方式。 <permission-group>元素不指定属于该组的权限，但是它给该组一个名称。应用可以通过将组名分配给<permission>元素的permissionGroup属性来在组中放置权限。</permission></permission-group></permission></permission-group></li>
</ul>
</li>
<li><strong>自定义权限的建议</strong><ul>
<li>如果正在设计一系列向其它应用公开功能的应用程序，在设计应用程序时请尽量保证每个权限仅定义一次。如果应用程序未使用相同的证书签名，每个权限只能定义一次。即使这些应用程序都使用相同的证书进行签名，最好只定义一次权限。</li>
<li>如果该功能仅适用于使用于提供应用程序签名相同的签名的应用程序，则可以通过使用签名检查来避免定义自定义权限。当其中一个应用程序向另一个应用程序发出请求时，第二个应用程序可以验证这两个应用程序是否已使用相同的证书进行签名，然后再执行该请求。</li>
<li>如果您正在开发仅在自己的设备上安装的应用程序，则应开发并安装管理套件中所有应用程序权限的程序包。这个包不需要自己提供任何服务。它只是声明所有权限，而套件中的其他应用程序则使用<uses-permission>元素请求这些权限。</uses-permission></li>
</ul>
</li>
</ul>

      
    </div>
    
    
    
     <div style="text-align:center;color: #ccc;font-size:14px;">---------------- The End ----------------</div>

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/guide/" <i class="fa fa-tag"></i>guide</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/14/API Guide之应用基础知识/" rel="next" title="API Guide之应用基础知识">
                <i class="fa fa-chevron-left"></i> API Guide之应用基础知识
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/02/API-Guide之Device compatibility/" rel="prev" title="API-Guide之设备兼容性">
                API-Guide之设备兼容性 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!--MOB SHARE BEGIN-->
<div class="-hoofoo-share-title">分享到：</div>
<div class="-hoofoo-share-buttons">
    <div class="-mob-share-weibo -hoofoo-share-weibo -hoofoo-share-ui-button"><i class="fa fa-weibo" aria-hidden="true"></i></div>
    <div class="-mob-share-weixin -hoofoo-share-weixin -hoofoo-share-ui-button"><i class="fa fa-weixin" aria-hidden="true"></i></div>
    <div class="-mob-share-qq -hoofoo-share-qq -hoofoo-share-ui-button"><i class="fa fa-qq" aria-hidden="true"></i></div>
    <div class="-mob-share-twitter -hoofoo-share-twitter -hoofoo-share-ui-button"><i class="fa fa-twitter" aria-hidden="true"></i></div>
    <div class="-hoofoo-share-more -hoofoo-share-ui-button -mob-share-open"><i class="fa fa-ellipsis-h" aria-hidden="true"></i></div>
</div>
<div class="-mob-share-ui" style="display: none">
    <ul class="-mob-share-list">
        <li class="-mob-share-weibo"><p>新浪微博</p></li>
        <li class="-mob-share-weixin"><p>微信</p></li>
        <li class="-mob-share-qzone"><p>QQ空间</p></li>
        <li class="-mob-share-qq"><p>QQ好友</p></li>
        <li class="-mob-share-tencentweibo"><p>腾讯微博</p></li>
        <li class="-mob-share-renren"><p>人人网</p></li>
        <li class="-mob-share-kaixin"><p>开心网</p></li>
        <li class="-mob-share-douban"><p>豆瓣</p></li>
        <li class="-mob-share-youdao"><p>有道云笔记</p></li>
        <li class="-mob-share-mingdao"><p>明道</p></li>
        <li class="-mob-share-pengyou"><p>朋友网</p></li>
        <li class="-mob-share-facebook"><p>Facebook</p></li>
        <li class="-mob-share-twitter"><p>Twitter</p></li>
        <li class="-mob-share-pocket"><p>Pocket</p></li>
        <li class="-mob-share-google"><p>Google+</p></li>
        <li class="-mob-share-tumblr"><p>Tumblr</p></li>
        <li class="-mob-share-instapaper"><p>Instapaper</p></li>
        <li class="-mob-share-linkedin"><p>Linkedin</p></li>
    </ul>
    <div class="-mob-share-close">取消</div>
</div>
<div class="-mob-share-ui-bg"></div>
<script id="-mob-share" src="http://f1.webshare.mob.com/code/mob-share.js?appkey=253a344399ff0"></script>
<!--MOB SHARE END-->
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">作茧自缚</p>
              <p class="site-description motion-element" itemprop="description">格物致知</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Providing-Resources提供资源"><span class="nav-number">1.</span> <span class="nav-text">Providing Resources提供资源</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#资源类型目录"><span class="nav-number">1.1.</span> <span class="nav-text">资源类型目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#提供备用资源"><span class="nav-number">1.2.</span> <span class="nav-text">提供备用资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#限定符命名规则"><span class="nav-number">1.3.</span> <span class="nav-text">限定符命名规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建别名资源"><span class="nav-number">1.4.</span> <span class="nav-text">创建别名资源</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#可绘制对象"><span class="nav-number">1.4.0.1.</span> <span class="nav-text">可绘制对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#布局"><span class="nav-number">1.4.0.2.</span> <span class="nav-text">布局</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串和其他简单值"><span class="nav-number">1.4.0.3.</span> <span class="nav-text">字符串和其他简单值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用资源提供最佳设备兼容性"><span class="nav-number">1.5.</span> <span class="nav-text">利用资源提供最佳设备兼容性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-如何查找最佳匹配资源"><span class="nav-number">1.6.</span> <span class="nav-text">Android 如何查找最佳匹配资源</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Accessing-Resources访问资源"><span class="nav-number">2.</span> <span class="nav-text">Accessing Resources访问资源</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#在-XML-中访问资源"><span class="nav-number">2.1.</span> <span class="nav-text">在 XML 中访问资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问平台资源"><span class="nav-number">2.2.</span> <span class="nav-text">访问平台资源</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Handing-Runtime-Change处理运行时变更"><span class="nav-number">3.</span> <span class="nav-text">Handing Runtime Change处理运行时变更</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#在配置变更期保留对象"><span class="nav-number">3.1.</span> <span class="nav-text">在配置变更期保留对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自行变更配置"><span class="nav-number">3.2.</span> <span class="nav-text">自行变更配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#清单文件结构"><span class="nav-number">3.3.</span> <span class="nav-text">清单文件结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件功能"><span class="nav-number">3.4.</span> <span class="nav-text">文件功能</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#App-Permissions应用权限"><span class="nav-number">4.</span> <span class="nav-text">App Permissions应用权限</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#权限概述"><span class="nav-number">4.1.</span> <span class="nav-text">权限概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#权限许可"><span class="nav-number">4.1.1.</span> <span class="nav-text">权限许可</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#硬件权限"><span class="nav-number">4.1.2.</span> <span class="nav-text">硬件权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#声明权限"><span class="nav-number">4.1.3.</span> <span class="nav-text">声明权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#权限自动调整"><span class="nav-number">4.1.4.</span> <span class="nav-text">权限自动调整</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#权限保护级别"><span class="nav-number">4.1.5.</span> <span class="nav-text">权限保护级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#权限组"><span class="nav-number">4.1.6.</span> <span class="nav-text">权限组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看应用程序的权限"><span class="nav-number">4.1.7.</span> <span class="nav-text">查看应用程序的权限</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在运行时请求权限"><span class="nav-number">4.2.</span> <span class="nav-text">在运行时请求权限</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#检查权限"><span class="nav-number">4.2.1.</span> <span class="nav-text">检查权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#请求权限"><span class="nav-number">4.2.2.</span> <span class="nav-text">请求权限</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#权限请求示例"><span class="nav-number">4.3.</span> <span class="nav-text">权限请求示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Android权限的原则"><span class="nav-number">4.3.1.</span> <span class="nav-text">使用Android权限的原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Android6-0的权限变更"><span class="nav-number">4.3.2.</span> <span class="nav-text">Android6.0的权限变更</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#避免请求不必要的权限"><span class="nav-number">4.3.3.</span> <span class="nav-text">避免请求不必要的权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试两种权限模式"><span class="nav-number">4.3.4.</span> <span class="nav-text">测试两种权限模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#背景"><span class="nav-number">4.3.5.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定义和执行权限"><span class="nav-number">4.3.6.</span> <span class="nav-text">定义和执行权限</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">作茧自缚</span>

  
</div>


  <div class="powered-by">  个人专属</div>




  <div class="theme-info"></div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>
  <a href="https://github.com/xuqinzz"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://zhizhi.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2018/03/20/API-Guide之App-Resources/';
          this.page.identifier = '2018/03/20/API-Guide之App-Resources/';
          this.page.title = 'API Guide之App Resources';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://zhizhi.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  

  

  

  
<script type="text/javascript">
    //微信二维码点击背景关闭
    $('body').delegate('.-mob-share-weixin-qrcode-bg','click', function(){
         $(".-mob-share-weixin-qrcode-close").trigger("click");
    }); 
</script>

<script type="text/javascript" color="255,132,0" opacity='0.6' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script>

</body>
</html>
